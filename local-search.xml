<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>带着问题读源码/vue2/compiler</title>
    <link href="/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/compiler/"/>
    <url>/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/compiler/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的网络请求过程</title>
    <link href="/2021/04/10/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/04/10/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>##</p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>TCP</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2-总体结构(一)</title>
    <link href="/2021/04/08/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%B8%80)/"/>
    <url>/2021/04/08/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么要读-Vue"><a href="#为什么要读-Vue" class="headerlink" title="为什么要读 Vue"></a>为什么要读 Vue</h3><p>Vue 是目前项目正在使用的框架，阅读学习源码能让我更好的使用框架所提供的功能，也可以解答使用过程中所产生的困惑。有人可能会问，Vue2 相关的源码解析文章在网上一大堆，何必要自己去写呢？我只想说，纸上得来终觉浅，绝知此事要躬行。</p><h3 id="Vue3-已经出来了，为什么依然读-Vue2"><a href="#Vue3-已经出来了，为什么依然读-Vue2" class="headerlink" title="Vue3 已经出来了，为什么依然读 Vue2"></a>Vue3 已经出来了，为什么依然读 Vue2</h3><p>原因一是很久以前就读过 Vue2 的源码，理解了基本的原理，但是后来没有坚持去深入，也就荒废了，心里多少还是有点不甘。因此这次相当于从新来过，也是准备出一个系列，既是读源码的记录整理，也是日后问题查询之处。原因二是虽然新版本的语法形式与旧版不同，但最核心的思想是没变的，吃透旧版之后，有机会也会去读读 Vue3，而这也是必须的。活到老，学到老。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>源码基于 version 2.6.14 of Vue</p><p>本系列暂分为8章，当前章节主要是对后续章节做辅助准备。<br>初次阅读源码时，我就时常陷入各种属性方法名之中，我不知道这个属性是在哪儿声明的，它的作用是什么。虽然说读源码最忌讳深入细枝末节，但无穷的属性让我很恐惧，所以本章会理清楚整体的一个逻辑走向，而第一部分主要是罗列跟 Vue 相关的属性和方法。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>Vue 这种框架核心文件都是在 src 文件里，但是入口在 package.json 中可以找到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">"dev"</span>: <span class="hljs-string">"rollup -w -c scripts/config.js --environment TARGET:web-full-dev"</span><br></code></pre></td></tr></table></figure><p>通过上述指令，打开 scripts/config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> aliases = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./alias'</span>)<br><span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> base = p.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> (aliases[base]) &#123;<br><span class="hljs-keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="hljs-number">1</span>))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> path.resolve(__dirname, <span class="hljs-string">'../'</span>, p)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> builds = &#123;<br><span class="hljs-comment">// Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify</span><br><span class="hljs-string">'web-runtime-cjs-dev'</span>: &#123;<br>entry: resolve(<span class="hljs-string">'web/entry-runtime.js'</span>),<br>dest: resolve(<span class="hljs-string">'dist/vue.runtime.common.dev.js'</span>),<br>format: <span class="hljs-string">'cjs'</span>,<br>env: <span class="hljs-string">'development'</span>,<br>banner<br>&#125;,<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>aliases 对象即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>vue: resolve(<span class="hljs-string">'src/platforms/web/entry-runtime-with-compiler'</span>),<br>compiler: resolve(<span class="hljs-string">'src/compiler'</span>),<br>core: resolve(<span class="hljs-string">'src/core'</span>),<br>shared: resolve(<span class="hljs-string">'src/shared'</span>),<br>web: resolve(<span class="hljs-string">'src/platforms/web'</span>),<br>weex: resolve(<span class="hljs-string">'src/platforms/weex'</span>),<br>server: resolve(<span class="hljs-string">'src/server'</span>),<br>sfc: resolve(<span class="hljs-string">'src/sfc'</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>结合上面两部分代码可以知道，入口在 ‘src/platforms/web/entry-runtime.js’ 中, 即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'./runtime/index'</span><br></code></pre></td></tr></table></figure><p>继续打开 src/platforms/web/runtime/index</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这里指明了 Vue 的来源</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'core/index'</span><br><br><span class="hljs-comment">// 如下为 Vue 添加了相关属性，</span><br>Vue.config.mustUseProp = mustUseProp<br>Vue.config.isReservedTag = isReservedTag<br>Vue.config.isReservedAttr = isReservedAttr<br>Vue.config.getTagNamespace = getTagNamespace<br>Vue.config.isUnknownElement = isUnknownElement<br><br>Vue.prototype.__patch__ = inBrowser ? patch : noop<br><br><span class="hljs-comment">// public mount method</span><br>Vue.prototype.$mount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">el?: string | Element,</span></span><br><span class="hljs-function"><span class="hljs-params">hydrating?: boolean</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Component</span> </span>&#123;<br>el = el &amp;&amp; inBrowser ? query(el) : <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">return</span> mountComponent(<span class="hljs-keyword">this</span>, el, hydrating)<br>&#125;<br></code></pre></td></tr></table></figure><p>从上可知， Vue 其实来源于我们之前说的 src 文件中，并且为 Vue 原型上添加了 $mount 和 <strong>patch</strong> 方法。</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>从这里开始将会沿着寻找 Vue 构造函数的源头，走马观花式的记录与 Vue 相关的属性及方法。</p><ol><li><p>/src/core/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$isServer = isServerRendering;<br>Vue.prototype.$isServer = <span class="hljs-keyword">this</span>.$vnode &amp;&amp; <span class="hljs-keyword">this</span>.$vnode.ssrContext;<br>Vue.FunctionalRenderContext = &#123;<br>value: FunctionalRenderContext<br>&#125;;<br>Vue.version = <span class="hljs-string">'__VERSION__'</span>;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/index.js  =&gt;  initGlobalAPI(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.config = configDef;<br>Vue.util = &#123;<br>warn,<br>extend,<br>mergeOptions,<br>defineReactive<br>&#125;;<br>Vue.set = <span class="hljs-keyword">set</span>;<br>Vue.delete = del;<br>Vue.nextTick = nextTick;<br>Vue.observable = obj =&gt; &#123;<br>observe(obj)<br><span class="hljs-keyword">return</span> obj<br>&#125;<br><br>Vue.options = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>Vue.options.components = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br>Vue.options.directives = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>Vue.options.filters = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br><br>Vue.options._base = Vue<br><br><span class="hljs-comment">// extend(Vue.options.components, builtInComponents) builtInComponents 即 KeepAlive </span><br>Vue.options.components.KeepAlive = KeepAlive<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/use.js  =&gt;  initUse(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.use = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/mixin.js  =&gt;  initMixin(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.mixin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/extend.js  =&gt;  initExtend(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.cid = <span class="hljs-number">0</span><br>Vue.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/assets.js  =&gt;  initAssetRegisters(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.components = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.directives = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.filters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- Vue 构造函数 --&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span> (<span class="hljs-params">options</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp;<br>!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Vue)<br>) &#123;<br>warn(<span class="hljs-string">'Vue is a constructor and should be called with the `new` keyword'</span>)<br>&#125;<br><span class="hljs-keyword">this</span>._init(options)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/init.js   =&gt; initMixin(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>vm._uid = uid++<br>vm._isVue = <span class="hljs-literal">true</span><br>vm.$options = mergeOptions(<br>resolveConstructorOptions(vm.constructor),<br>options || &#123;&#125;,<br>vm<br>)<br>vm._renderProxy = vm<br>vm._self = vm<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/lifecycle.js   =&gt; initLifecycle(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$parent = parent<br>vm.$root = parent ? parent.$root : vm<br><br>vm.$children = []<br>vm.$refs = &#123;&#125;<br><br>vm._watcher = <span class="hljs-literal">null</span><br>vm._inactive = <span class="hljs-literal">null</span><br>vm._directInactive = <span class="hljs-literal">false</span><br>vm._isMounted = <span class="hljs-literal">false</span><br>vm._isDestroyed = <span class="hljs-literal">false</span><br>vm._isBeingDestroyed = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/events.js   =&gt; initEvents(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._events = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>vm._hasHookEvent = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/render.js   =&gt; initRender(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._vnode = <span class="hljs-literal">null</span> <span class="hljs-comment">// the root of the child tree</span><br>vm._staticTrees = <span class="hljs-literal">null</span> <span class="hljs-comment">// v-once cached trees</span><br>vm.$vnode = vm.$options._parentVnode<br>vm.$slots = resolveSlots(options._renderChildren, renderContext)<br>vm.$scopedSlots = emptyObject<br>vm._c = <span class="hljs-function">(<span class="hljs-params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="hljs-literal">false</span>)<br>vm.$createElement = <span class="hljs-function">(<span class="hljs-params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="hljs-literal">true</span>)<br>vm.$attrs = vm.$vnode.data.attrs || emptyObject<br>vm.$listeners = vm.$options._parentListeners || emptyObject<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; initState(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._watchers = []<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; initProps()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._props = &#123;&#125;<br>vm.$options._propKeys = []<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; initData()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._data = vm.$options.data.call(vm) || vm.$options.data<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/inject.js   =&gt; initProvide()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._provided = vm.$options.provide.call(vm) || vm.$options.provide<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; stateMixin()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$data = &#123;<br><span class="hljs-keyword">get</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._data<br>&#125;<br>&#125;<br>Vue.prototype.$props = &#123;<br><span class="hljs-keyword">get</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._props<br>&#125;<br>&#125;<br>Vue.prototype.$<span class="hljs-keyword">set</span> = <span class="hljs-keyword">set</span><br>Vue.prototype.$delete = del<br>Vue.prototype.$watch = function ()&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/events.js   =&gt; eventsMixin(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$on = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$once = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$off = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$emit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/lifecycle.js   =&gt; lifecycleMixin(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype._update = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$forceUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/render.js   =&gt; renderMixin(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$nextTick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn: Function</span>) </span>&#123;<br><span class="hljs-keyword">return</span> nextTick(fn, <span class="hljs-keyword">this</span>)<br>&#125;<br>Vue.prototype._render = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里，我们就大致整理出了在初始化 Vue 时会声明的相关属性，在后面的源码阅读过程中会起到一个字典的作用。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2-总体结构(二)</title>
    <link href="/2021/04/08/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%BA%8C)/"/>
    <url>/2021/04/08/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一小节，我们整理了 Vue 相关的属性，这一小节则通过框架自带的 demo 来梳理一下 Vue 整体的一个运行流程。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先我们找到本节 demo 目录，路径为 ‘/examples/commits’。将 index.html 中 vue 的引用路径改成 ‘<script src="../../dist/vue.js"></script>‘, 方便调试。</p><p>app.js 里调用了 Vue 构造函数，所以从这里开始吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>el: <span class="hljs-string">'#demo'</span>,<br>data: &#123;<br>branches: [<span class="hljs-string">'master'</span>, <span class="hljs-string">'dev'</span>],<br>currentBranch: <span class="hljs-string">'master'</span>,<br>commits: <span class="hljs-literal">null</span><br>&#125;,<br>created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">this</span>.fetchData()<br>&#125;,<br>watch: &#123;<br>currentBranch: <span class="hljs-string">'fetchData'</span><br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="new-Vue-之前做了什么"><a href="#new-Vue-之前做了什么" class="headerlink" title="new Vue() 之前做了什么"></a>new Vue() 之前做了什么</h3><p>Vue 本身会进行一系列的初始化工作</p><ol><li><p>/src/core/instance/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">initMixin(Vue);<br>stateMixin(Vue);<br>eventsMixin(Vue);<br>lifecycleMixin(Vue);<br>renderMixin(Vue);<br></code></pre></td></tr></table></figure></li><li><p>/src/core/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">initGlobalAPI(Vue);<br><span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">"$isServer"</span>, &#123;<br><span class="hljs-keyword">get</span>: isServerRendering,<br>&#125;);<br><br>Object.defineProperty(Vue.prototype, "$ssrContext", &#123;<br><span class="hljs-keyword">get</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$vnode &amp;&amp; <span class="hljs-keyword">this</span>.$vnode.ssrContext;<br>&#125;,<br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(Vue, <span class="hljs-string">"FunctionalRenderContext"</span>, &#123;<br>value: FunctionalRenderContext,<br>&#125;);<br><br>Vue.version = <span class="hljs-string">"__VERSION__"</span>;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">initUse(Vue);<br>initMixin(Vue);<br>initExtend(Vue);<br>initAssetRegisters(Vue);<br></code></pre></td></tr></table></figure></li></ol><h3 id="new-Vue-做了什么"><a href="#new-Vue-做了什么" class="headerlink" title="new Vue() 做了什么"></a>new Vue() 做了什么</h3><p>new Vue() 实际上调用了自身的 _init 方法，从字典可知， _init 方法 在 ‘/src/core/instance/init.js’ 中的 initMixin 方法里。<br>忽略部分代码后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span>;<br>Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options?: Object</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> vm: Component = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// a uid</span><br>  vm._uid = uid++;<br><br>  <span class="hljs-comment">// 这个标识可以避免 vm 被观察系统观察</span><br>  vm._isVue = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 将通过自定义策略合并配置项后的值赋值给 $options</span><br>  vm.$options = mergeOptions(<br>    resolveConstructorOptions(vm.constructor),<br>    options || &#123;&#125;,<br>    vm<br>  );<br><br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">"production"</span>) &#123;<br>    <span class="hljs-comment">// 如果不是生产环境就初始化代理相关操作</span><br>    initProxy(vm);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    vm._renderProxy = vm;<br>  &#125;<br><br>  vm._self = vm;<br>  <span class="hljs-comment">// 初始化声明周期</span><br>  initLifecycle(vm);<br>  <span class="hljs-comment">// 初始化事件机制</span><br>  initEvents(vm);<br>  <span class="hljs-comment">// 初始化渲染相关</span><br>  initRender(vm);<br>  <span class="hljs-comment">// 调用 beforeCreate 钩子</span><br>  callHook(vm, <span class="hljs-string">"beforeCreate"</span>);<br>  <span class="hljs-comment">// 在 data 或 props 被处理前初始化注入</span><br>  initInjections(vm); <span class="hljs-comment">// resolve injections before data/props</span><br>  <span class="hljs-comment">// 初始化对 data 和 props 相关操作</span><br>  initState(vm);<br>  <span class="hljs-comment">// 在 data 或 props 被处理后初始化注入</span><br>  initProvide(vm); <span class="hljs-comment">// resolve provide after data/props</span><br>  <span class="hljs-comment">// 调用 created 钩子</span><br>  callHook(vm, <span class="hljs-string">"created"</span>);<br><br>  <span class="hljs-comment">// 如果存在 el 属性，则进行挂载操作</span><br>  <span class="hljs-keyword">if</span> (vm.$options.el) &#123;<br>    vm.$mount(vm.$options.el);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上可知，_init 方法主要做了如下几件事：</p><ol><li>为 Vue 实例添加 $options 属性</li><li>初始化相关属性。</li><li>在渲染操作相关初始化完成之后和属性注入相关初始化之前调用 beforeCreate 钩子</li><li>在依赖相关初始化完成之后和 Dom 挂载之前调用 created 钩子</li><li>挂载 Dom</li></ol><h3 id="options-合并策略"><a href="#options-合并策略" class="headerlink" title="options 合并策略"></a>options 合并策略</h3><p>我们使用 Vue 构造函数时传入的 options 会经过一系列的合并，合并之后的 options 会被赋值给实例的 $options 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// merge options</span><br><span class="hljs-keyword">if</span> (options &amp;&amp; options._isComponent) &#123;<br>  initInternalComponent(vm, options);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  vm.$options = mergeOptions(<br>    resolveConstructorOptions(vm.constructor),<br>    options || &#123;&#125;,<br>    vm<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>因为动态 options 的合并耗时较长，因此只对外部组件采取动态合并的方式。</p><p>先看看 resolveConstructorOptions 方法，vm 是 Vue 实例，vm.constructor 指的是 Vue，代码简化后如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> options = Ctor.options;<br><span class="hljs-keyword">if</span> (Ctor.super) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">return</span> options;<br></code></pre></td></tr></table></figure><p>依据字典，我们可以知道，Vue.options 的值可以表示成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.options = &#123;<br>  components: &#123;&#125;,<br>  directives: &#123;&#125;,<br>  filters: &#123;&#125;,<br>  _base: Vue,<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例中 options 并没有指定 super 属性，因此该方法直接 return options</p><p>回到 mergeOptions, 一个参 parent 即 Vue.options, 第二个参 child 是构造函数的入参，第三个是 Vue 实例。</p><p>首先是调用 checkComponents(child)，对 components 中声明的名称做格式上的校验，必须符合 html5 标准，并且不能使用内置的 html 标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkComponents</span>(<span class="hljs-params">options</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> options.components) &#123;<br>    validateComponentName(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是对 props、inject、directives 这些参数进行格式化，最后都形成对象的形式。</p><p>下面开始真正的合并。</p><p>第一步，将尚未合并过的 child 中的 extend 和 mixins 属性合并到 parent 中。<br>第二步，按顺序将 parent 和 child 的属性存入到声明的空对象 options 中。</p><p>需要注意的是在对 child 处理时，只对 parent 中不存在的属性做合并，可以避免对 Vue.options 属性的覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> child) &#123;<br>  <span class="hljs-keyword">if</span> (!hasOwn(parent, key)) &#123;<br>    mergeField(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来重点看下 mergeField 方法，这个是整个合并策略的核心</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeField</span>(<span class="hljs-params">key</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> strat = strats[key] || defaultStrat;<br>  options[key] = strat(parent[key], child[key], vm, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，strats 就是一个对象，它的属性是一个个用来处理不同类型属性的策略方法。</p><p>除了 strats，还有一个默认策略方法 defaultStrat</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> defaultStrat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> childVal === <span class="hljs-literal">undefined</span> ? parentVal : childVal;<br>&#125;;<br></code></pre></td></tr></table></figure><p>逻辑很简单：如果 childVal 存在，返回 childVal，否则返回 parentVal。</p><p>以下是 strats 的策略方法：</p><h4 id="1、el，propsData"><a href="#1、el，propsData" class="headerlink" title="1、el，propsData"></a>1、el，propsData</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.el = strats.propsData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, child, vm, key</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 使用默认策略</span><br>  <span class="hljs-keyword">return</span> defaultStrat(parent, child);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2、data"><a href="#2、data" class="headerlink" title="2、data"></a>2、data</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.data = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal, vm</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!vm) &#123;<br>    <span class="hljs-keyword">if</span> (childVal &amp;&amp; <span class="hljs-keyword">typeof</span> childVal !== <span class="hljs-string">"function"</span>) &#123;<br>      warn(<br>        <span class="hljs-string">'The "data" option should be a function '</span> +<br>          <span class="hljs-string">"that returns a per-instance value in component "</span> +<br>          <span class="hljs-string">"definitions."</span>,<br>        vm<br>      );<br><br>      <span class="hljs-keyword">return</span> parentVal;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mergeDataOrFn(parentVal, childVal);<br>  &#125;<br>  <span class="hljs-keyword">return</span> mergeDataOrFn(parentVal, childVal, vm);<br>&#125;;<br></code></pre></td></tr></table></figure><p>mergeDataOrFn 返回的方法里会调用 mergeData 方法，我们跳过直接看 mergeData</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeData</span>(<span class="hljs-params">to, from</span>) </span>&#123;<br>  <span class="hljs-comment">// 如果不存在子项，直接返回父项</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">return</span> to;<br>  &#125;<br>  <span class="hljs-keyword">var</span> key, toVal, fromVal;<br><br>  <span class="hljs-keyword">var</span> keys = hasSymbol ? <span class="hljs-built_in">Reflect</span>.ownKeys(<span class="hljs-keyword">from</span>) : <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">from</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>    key = keys[i];<br>    <span class="hljs-comment">// 如果属性已经被 oberved， 则直接跳过</span><br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">"__ob__"</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    toVal = to[key];<br>    fromVal = <span class="hljs-keyword">from</span>[key];<br>    <span class="hljs-comment">// 如果父项没有当前属性，则开启合并(覆盖)</span><br>    <span class="hljs-keyword">if</span> (!hasOwn(to, key)) &#123;<br>      <span class="hljs-keyword">set</span>(to, key, fromVal);<br>    &#125; else if (<br>      // 如果当前父属性和子属性都为对象且不相等，则递归合并(覆盖)<br>      toVal !== fromVal &amp;&amp;<br>      isPlainObject(toVal) &amp;&amp;<br>      isPlainObject(fromVal)<br>    ) &#123;<br>      mergeData(toVal, fromVal);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、声明周期钩子"><a href="#3、声明周期钩子" class="headerlink" title="3、声明周期钩子"></a>3、声明周期钩子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">LIFECYCLE_HOOKS.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hook</span>) </span>&#123;<br>  strats[hook] = mergeHook;<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeHook</span>(<span class="hljs-params">parentVal, childVal</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = childVal<br>    ? parentVal<br>      ? parentVal.concat(childVal)<br>      : <span class="hljs-built_in">Array</span>.isArray(childVal)<br>      ? childVal<br>      : [childVal]<br>    : parentVal;<br>  <span class="hljs-keyword">return</span> res ? dedupeHooks(res) : res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dedupeHooks</span>(<span class="hljs-params">hooks</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hooks.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (res.indexOf(hooks[i]) === <span class="hljs-number">-1</span>) &#123;<br>      res.push(hooks[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>mergeHook 中 parentVal 和 childVal 处理后 res 情况如下：</p><ul><li>childVal 存在<ul><li>parentVal 存在，将 childVal 合并进 parentVal 中</li><li>parentVal 不存在，保证 childVal 为数组或处于数组中</li></ul></li><li>childVal 不存在，则返回 parentVal</li></ul><p>res 可能存在重复的 hook，所以 dedupeHooks 坐了一个去重<br>mergeHook 最后返回的值就是一个包含合并后生命周期钩子的数组</p><h4 id="4、components-directives-filters"><a href="#4、components-directives-filters" class="headerlink" title="4、components, directives, filters"></a>4、components, directives, filters</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">ASSET_TYPES.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>&#123;<br>  strats[type + <span class="hljs-string">"s"</span>] = mergeAssets;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这三类都采用 mergeAssets 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeAssets</span>(<span class="hljs-params">parentVal, childVal, vm, key</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">Object</span>.create(parentVal || <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span> (childVal) &#123;<br>    assertObjectType(key, childVal, vm);<br>    <span class="hljs-keyword">return</span> extend(res, childVal);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有 childVal 存在时，才会执行合并(覆盖)操作，否则只返回 parentVal 原型链下级对象</p><h4 id="5、watch"><a href="#5、watch" class="headerlink" title="5、watch"></a>5、watch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.watch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal, vm, key</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (!childVal) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(parentVal || <span class="hljs-literal">null</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (!parentVal) &#123;<br>    <span class="hljs-keyword">return</span> childVal;<br>  &#125;<br>  <span class="hljs-keyword">var</span> ret = &#123;&#125;;<br>  extend(ret, parentVal);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key$<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> childVal) &#123;<br>    <span class="hljs-keyword">var</span> parent = ret[key$<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">var</span> child = childVal[key$<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (parent &amp;&amp; !<span class="hljs-built_in">Array</span>.isArray(parent)) &#123;<br>      parent = [parent];<br>    &#125;<br>    ret[key$<span class="hljs-number">1</span>] = parent<br>      ? parent.concat(child)<br>      : <span class="hljs-built_in">Array</span>.isArray(child)<br>      ? child<br>      : [child];<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;;<br></code></pre></td></tr></table></figure><p>watch 合并后的对象 ret 的值是数组，保证每一个 key 可以包含多个 watcher，而且 watcher 不能被覆盖，因此这里不会有去重操作</p><h4 id="6、props，methods，inject"><a href="#6、props，methods，inject" class="headerlink" title="6、props，methods，inject"></a>6、props，methods，inject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.props =<br>strats.methods =<br>strats.inject =<br>strats.computed =<br><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal, vm, key</span>) </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 如果 parentVal 不存在，直接返回 childVal</span><br><span class="hljs-keyword">if</span> (!parentVal) &#123;<br><span class="hljs-keyword">return</span> childVal;<br>&#125;<br><span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">// 将 parentVal 的属性存入 ret 中</span><br>extend(ret, parentVal);<br><span class="hljs-comment">// 如果 childVal 存在，将 childVal 的属性存入 ret 中</span><br><span class="hljs-keyword">if</span> (childVal) &#123;<br>extend(ret, childVal);<br>&#125;<br><span class="hljs-comment">// 返回 ret</span><br><span class="hljs-keyword">return</span> ret;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7、provide-采用-mergeDataOrFn"><a href="#7、provide-采用-mergeDataOrFn" class="headerlink" title="7、provide 采用 mergeDataOrFn"></a>7、provide 采用 mergeDataOrFn</h4><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上，我们梳理了在使用 Vue 时，它自身都做了哪些工作。并且着重解析了 options 合并策略，简单总结一下：</p><p>1、el、propsData</p><ul><li>如果 child 不存在，返回 parent，否则返回 child</li></ul><p>2、data、provide</p><ul><li>如果 child 不存在，返回 parent</li><li>如果 parent 存在，遍历 child 的属性，<ul><li>如果 parent 不存在该属性，则将属性赋予 parent</li><li>如果 parent 存在该属性，并且 parentVal 与 childVal 同为对象不相等，则递归合并 parentVal 与 childVal</li></ul></li></ul><p>3、components, directives, filters<br>如果 child 存在，合并 child 属性，否则返回空对象</p><p>4、props，methods，inject</p><ul><li>如果 parent 不存在，返回 child</li><li>如果 parent 存在或 child 存在，将各自的属性赋予返回的对象中</li></ul><p>5、watch 和 LIFECYCLE_HOOKS<br>相同点：如果 parent 和 child 存在，保证它们都是数组形式，将 child 并入 到 parent 中<br>不同点：LIFECYCLE_HOOKS 最后的结果需要去重，而 watch 不用</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>axios-总体结构</title>
    <link href="/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <url>/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><strong>本文基于 axios 版本 0.21.1</strong></p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在根目录下找到 index.js，里面只有一句代码，将 axios 进行导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/axios'</span>);<br></code></pre></td></tr></table></figure><p>找到 lib 下的 axios.js 文件</p><ul><li><p>首先引入了相关文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 工具函数库</span><br><span class="hljs-keyword">var</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils'</span>);<br><span class="hljs-comment">// bind 方法，返回 function wrap</span><br><span class="hljs-keyword">var</span> bind = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers/bind'</span>);<br><span class="hljs-comment">// Axios 构造函数</span><br><span class="hljs-keyword">var</span> Axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/Axios'</span>);<br><span class="hljs-comment">// 合并参数</span><br><span class="hljs-keyword">var</span> mergeConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/mergeConfig'</span>);<br><span class="hljs-comment">// 默认设置和属性</span><br><span class="hljs-keyword">var</span> defaults = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./defaults'</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建 axios 实例的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInstance</span> (<span class="hljs-params">defaultConfig</span>) </span>&#123;<br><span class="hljs-comment">// 创建 Axios 实例</span><br><span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> Axios(defaultConfig);<br><br><span class="hljs-keyword">var</span> instance = bind(Axios.prototype.request, context);<br>utils.extend(instance, Axios.prototype, context);<br>utils.extend(instance, context);<br><br><span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>​bind 方法代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span> (<span class="hljs-params">fn, thisArg</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>args[i] = <span class="hljs-built_in">arguments</span>[i];<br>&#125;<br><span class="hljs-keyword">return</span> fn.apply(thisArg, args);<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>  bind 方法的逻辑很简单，就是返回 一个wrap 函数，函数内部会使用 context 调用 Axios.prototype.request。bind执行完后就将 Axios.prototype 和 context 的属性赋值给 wrap 函数。<br>  在该文件后续部分我们可以看到以下两行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">var</span> axios = createInstance(defaults);<br><span class="hljs-built_in">module</span>.exports = axios;<br></code></pre></td></tr></table></figure><p>执行 createInstance 方法返回的 instance 赋值给了 axios，那么 axios 的值就是 wrap 函数，这也就是为什么我们使用 axios 时，既可以调用它的方法，也可以直接执行它的原因。</p></li></ul><p>到这里，我们明白了 axios 是什么以及如何创建它的实例。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>前面的处理将 Axios 相关属性赋予给了 wrap 函数，那到底是哪些属性呢？该小节将会详细了解下构造函数 Axios。</p><p><strong>文件位于  axios/core/Axios</strong></p><p>首先引入所需依赖，大概知道是干什么的就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对请求路径进行一些格式化</span><br><span class="hljs-keyword">var</span> buildURL = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers/buildURL'</span>);<br><span class="hljs-comment">// 拦截器构造函数</span><br><span class="hljs-keyword">var</span> InterceptorManager = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./InterceptorManager'</span>);<br><span class="hljs-comment">// 发起 request 请求</span><br><span class="hljs-keyword">var</span> dispatchRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dispatchRequest'</span>);<br></code></pre></td></tr></table></figure><p>接着往下看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Axios</span> (<span class="hljs-params">instanceConfig</span>) </span>&#123;<br><span class="hljs-keyword">this</span>.defaults = instanceConfig;<br><span class="hljs-comment">// 拦截器对象</span><br><span class="hljs-keyword">this</span>.interceptors = &#123;<br>request: <span class="hljs-keyword">new</span> InterceptorManager(),<br>response: <span class="hljs-keyword">new</span> InterceptorManager()<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在创建实例时可接收一个配置参数</li><li>将接收的配置赋值给自身的 defaults 属性</li><li>拥有一个 拦截器对象，该对象包括请求拦截器和相应拦截器</li><li>拦截器实例是在创建 Axios 实例时才会创建</li></ul><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在日常使用中，拦截器的配置是最重要的一部分。我们通过上方路径找到拦截器构造函数文件。</p><p>​        构造函数拥有一个 handlers 数组，用来存储拦截器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InterceptorManager</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">this</span>.handlers = [];<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后给构造函数原型添加方法函数</p><ol><li><p>使用 use 方法添加一个新的拦截器，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">InterceptorManager.prototype.use = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">use</span> (<span class="hljs-params">fulfilled, rejected, options</span>) </span>&#123;<br><span class="hljs-keyword">this</span>.handlers.push(&#123;<br>fulfilled: fulfilled,<br>rejected: rejected,<br>synchronous: options ? options.synchronous : <span class="hljs-literal">false</span>,<br>runWhen: options ? options.runWhen : <span class="hljs-literal">null</span><br>&#125;);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handlers.length - <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>每个拦截器包括四个属性：<ol><li>fulfilled：一个方法，在请求或相应被 then 处理前执行</li><li>rejected：一个方法，在请求或相应被 reject 处理前执行</li><li>synchronous：请求拦截器是否采用同步执行机制</li><li>runwhen：表明请求拦截器什么情况下执行。默认为 null，也可以是一个函数。</li></ol></li><li>use 方法返回当前拦截器在拦截器数组中的位置下标</li></ol></li><li><p>使用 eject 方法清除一个拦截器。参数 id 就是拦截器在数组中的下标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">InterceptorManager.prototype.eject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eject</span> (<span class="hljs-params">id</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlers[id]) &#123;<br><span class="hljs-comment">// 将下标为 id 处的拦截器置为 null</span><br><span class="hljs-keyword">this</span>.handlers[id] = <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 forEach 方法执行符合条件的拦截器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">InterceptorManager.prototype.forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span> (<span class="hljs-params">fn</span>) </span>&#123;<br><span class="hljs-comment">// 遍历拦截器存储数组，执行 fn 时会过滤掉数组中被置为 null 的值。</span><br>utils.forEach(<span class="hljs-keyword">this</span>.handlers, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachHandler</span> (<span class="hljs-params">h</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (h !== <span class="hljs-literal">null</span>) &#123;<br>fn(h);<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="挂载方法"><a href="#挂载方法" class="headerlink" title="挂载方法"></a>挂载方法</h3><p>构造函数内部添加完属性后，紧接着就是在构造函数原型上添加相应方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 为 Axios 原型挂载 request 和 getUri 方法</span><br>Axios.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;<br>Axios.prototype.getUri = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUri</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;<br><br><span class="hljs-comment">// 为 Axios 原型挂载支持的 method</span><br>utils.forEach([<span class="hljs-string">'delete'</span>, <span class="hljs-string">'get'</span>, <span class="hljs-string">'head'</span>, <span class="hljs-string">'options'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodNoData</span> (<span class="hljs-params">method</span>) </span>&#123;<br>Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, config</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<br>method: method,<br>url: url,<br><span class="hljs-comment">// 使用这些 method时，有可能不会传 data 属性，所以使用默认的 data</span><br>data: (config || &#123;&#125;).data <br>&#125;));<br>&#125;;<br>&#125;);<br>utils.forEach([<span class="hljs-string">'post'</span>, <span class="hljs-string">'put'</span>, <span class="hljs-string">'patch'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodWithData</span> (<span class="hljs-params">method</span>) </span>&#123;<br>Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, data, config</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<br>method: method,<br>url: url,<br>data: data<br>&#125;));<br>&#125;;<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中包括 HTTP 请求同名的方法 。这些方法会被代理给原型的 request 方法，Axios 将支持的请求的 methods 按照是否需要默认 data 属性分为两类，现在来看看 request 方法的实现。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul><li><p>首先是基本参数的一个默认设置以及合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 兼容 axios('example/url'[, config]) 这种传参方式</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config === <span class="hljs-string">'string'</span>) &#123;<br>    config = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || &#123;&#125;;<br>    config.url = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    config = config || &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 合并 config</span><br>config = mergeConfig(<span class="hljs-keyword">this</span>.defaults, config);<br><br><span class="hljs-comment">// 设置 config.method， 默认小写，默认 get 方法</span><br><span class="hljs-keyword">if</span> (config.method) &#123;<br>    config.method = config.method.toLowerCase();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaults.method) &#123;<br>    config.method = <span class="hljs-keyword">this</span>.defaults.method.toLowerCase();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    config.method = <span class="hljs-string">'get'</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对拦截器队列的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 请求拦截器队列</span><br><span class="hljs-keyword">var</span> requestInterceptorChain = [];<br><span class="hljs-comment">// 请求拦截器是否同步执行</span><br><span class="hljs-keyword">var</span> synchronousRequestInterceptors = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">this</span>.interceptors.request.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unshiftRequestInterceptors</span> (<span class="hljs-params">interceptor</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> interceptor.runWhen === <span class="hljs-string">'function'</span> &amp;&amp; interceptor.runWhen(config) === <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为 interceptor.synchronous 默认为 false，所以 synchronousRequestInterceptors 默认为 false，</span><br>    synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous;<br><br>    <span class="hljs-comment">// 每个拦截器由执行成功和执行失败处理方法组成</span><br>    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);<br>&#125;);<br><br><span class="hljs-comment">// 响应拦截器链</span><br><span class="hljs-keyword">var</span> responseInterceptorChain = [];<br><br><span class="hljs-keyword">this</span>.interceptors.response.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushResponseInterceptors</span> (<span class="hljs-params">interceptor</span>) </span>&#123;<br>    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>请求拦截器 执行机制的处理</p><p>​        请求拦截器 执行机制由上面的 synchronousRequestInterceptors 决定，分为 异步和同步两种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> promise;<br><br><span class="hljs-comment">// 异步执行</span><br><span class="hljs-keyword">if</span> (!synchronousRequestInterceptors) &#123;<br><span class="hljs-comment">// 调用处理方法队列</span><br>    <span class="hljs-keyword">var</span> chain = [dispatchRequest, <span class="hljs-literal">undefined</span>];<br><span class="hljs-comment">// 将请求拦截器处理方法和响应拦截器处理方法分别放入队列前后</span><br>    <span class="hljs-built_in">Array</span>.prototype.unshift.apply(chain, requestInterceptorChain);<br>    chain.concat(responseInterceptorChain);<br><br>    promise = <span class="hljs-built_in">Promise</span>.resolve(config);<br>    <span class="hljs-comment">// 将包含了请求拦截器的 chain 交给 promise 来处理  </span><br>    <span class="hljs-keyword">while</span> (chain.length) &#123;<br>        promise = promise.then(chain.shift(), chain.shift());<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br><br><span class="hljs-comment">// 同步执行</span><br><span class="hljs-keyword">var</span> newConfig = config;<br><br><span class="hljs-comment">// 先一次性执行完请求拦截器</span><br><span class="hljs-keyword">while</span> (requestInterceptorChain.length) &#123;<br>    <span class="hljs-keyword">var</span> onFulfilled = requestInterceptorChain.shift();<br>    <span class="hljs-keyword">var</span> onRejected = requestInterceptorChain.shift();<br>    <span class="hljs-keyword">try</span> &#123;<br>        newConfig = onFulfilled(newConfig);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        onRejected(error);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 再异步执行 dispatchRequest（如 XHR），</span><br>    promise = dispatchRequest(newConfig);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>&#125;<br><span class="hljs-comment">// 最后异步执行响应拦截器</span><br><span class="hljs-keyword">while</span> (responseInterceptorChain.length) &#123;<br>    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());<br>&#125;<br><br><span class="hljs-keyword">return</span> promise;<br></code></pre></td></tr></table></figure><p>对拦截器处理的总结：</p><ul><li>存在三个 chain：请求拦截器 requestInterceptorChain 、响应拦截器 responseInterceptorChain、真正的 request 调用 originChain</li><li>拦截器以成对的形式存在，放入对应的拦截器 chain 中</li><li>请求拦截器对依次插入到 chain 头；相应拦截器对依次插入到 chain 尾</li><li>请求拦截器可以同步执行也可以异步执行：<ul><li>如果是异步执行，则会将requestInterceptorChain 插入到 originChain 队头，将 responseInterceptorChain 插入到 originChain 队尾；然后对 originChain 内的元素放入 promise.then 中执行</li><li>如果是同步执行，则会将 requestInterceptorChain 内的元素以迭代的方式执行完毕，然后执行 originChain 内的 request，最后将 responseInterceptorChain 内的元素放入 promise.then 中执行</li></ul></li></ul><p>最后通过一张图来理解请求拦截器处理不同的机制</p></li></ul><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/axios_%E6%89%A7%E8%A1%8C%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt="axios 执行图"></p>]]></content>
    
    
    <categories>
      
      <category>Axios</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析 generator 与 async 原理</title>
    <link href="/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>geneartor 和 async 都是 js 处理异步操作发展历程的产物，它们让异步编程越来越像同步编程。但是由于采用新的语法、关键字，它们是如何做到“类同步”操作的，我们不得而知，因此这篇文章将会窥探内部的秘密。</p><p>下面将借助 babel 本地编译示例代码来进行分析。</p><h2 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h2><p> 一、全局安装 regenerator</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i regenerator -g<br></code></pre></td></tr></table></figure><p> 二、编译 generator</p><p>​    命令加上 –include-runtime，可以得到完整的编译代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">regenerator --include-runtime test.js &gt; test-fill.js<br></code></pre></td></tr></table></figure><p>test-fill.js 就是编译后的代码文件。</p><h2 id="解析-generator"><a href="#解析-generator" class="headerlink" title="解析 generator"></a>解析 generator</h2><p>现在有如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">let</span> gen = genFn();<br>gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>调用 genFn 并不会直接执行，而是会返回一个 generator 对象，每次调用它的 next 方法会执行一个 yield 语句，并返回当前的值及状态。</p><p>这是编译后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _marked = <span class="hljs-comment">/*#__PURE__*/</span>regeneratorRuntime.mark(genFn);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>_context.next = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>_context.next = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>_context.next = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<br><span class="hljs-keyword">return</span> _context.stop();<br>&#125;<br>&#125;<br>&#125;, _marked);<br>&#125;<br><br><span class="hljs-keyword">var</span> g = genFn();<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br></code></pre></td></tr></table></figure><p>可以看到 genFn 被改写了，调用 regeneratorRuntime.wrap 方法创建，其中传给 wrap 方法的 genFn$ 函数，里面的逻辑很简单，是一个永远都会执行的迭代，里面 switch 中的 case 是原代码中 yield 关键字所在的行数，genFn$ 的参数 _context 记录了原代码的执行上下文内容，每次调用 next 方法，实际上就会调用 genFn$，然后执行对应的逻辑。</p><p>大致的流程弄清楚之后，再来看看 regeneratorRuntime。</p><p>wrap 方法第二个参是 mark(genFn) 的值， mark 方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> $<span class="hljs-built_in">Symbol</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"function"</span> ? <span class="hljs-built_in">Symbol</span> : &#123;&#125;;<br><span class="hljs-keyword">var</span> iteratorSymbol = $<span class="hljs-built_in">Symbol</span>.iterator || <span class="hljs-string">"@@iterator"</span>;<br><br><span class="hljs-keyword">var</span> toStringTagSymbol = $<span class="hljs-built_in">Symbol</span>.toStringTag || <span class="hljs-string">"@@toStringTag"</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GeneratorFunctionPrototype</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-keyword">var</span> IteratorPrototype = &#123;&#125;;<br>IteratorPrototype[iteratorSymbol] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;;<br>GeneratorFunctionPrototype.prototype = <span class="hljs-built_in">Object</span>.create(IteratorPrototype);<br><br>exports.mark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">genFun</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.setPrototypeOf) &#123;<br><span class="hljs-built_in">Object</span>.setPrototypeOf(genFun, GeneratorFunctionPrototype);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>genFun.__proto__ = GeneratorFunctionPrototype;<br>define(genFun, toStringTagSymbol, <span class="hljs-string">"GeneratorFunction"</span>);<br>&#125;<br>genFun.prototype = <span class="hljs-built_in">Object</span>.create(Gp);<br><span class="hljs-keyword">return</span> genFun;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>IteratorPrototype 对象添加 Symbol.iterator属性，使得 IteratorPrototype 拥有 Iterator 接口</li><li>GeneratorFunctionPrototype 函数的原型指向 IteratorPrototype ，所以 GeneratorFunctionPrototype 也拥有 Iterator 接口</li><li>genFun 的   <strong>proto</strong>  指向 GeneratorFunctionPrototype ，同理 genFun  拥有 Iterator 接口</li><li>mark 返回 genFun</li></ol><p>也就是说 mark 方法返回一个拥有 Iterator 接口 genFun。现在看下 wrap 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span> (<span class="hljs-params">innerFn, outerFn, self, tryLocsList</span>) </span>&#123;<br><span class="hljs-comment">// 确保 protoGenerator 拥有 Itrator 接口</span><br><span class="hljs-keyword">var</span> protoGenerator = outerFn &amp;&amp; outerFn.prototype <span class="hljs-keyword">instanceof</span> Generator ? outerFn : Generator;<br><span class="hljs-keyword">var</span> generator = <span class="hljs-built_in">Object</span>.create(protoGenerator.prototype);<br><span class="hljs-comment">// context 即 genFn$ 的参数 _context </span><br><span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> Context(tryLocsList || []);<br><br><span class="hljs-comment">// ._invoke 方法整合了 next、throw 和 return 方法</span><br>generator._invoke = makeInvokeMethod(innerFn, self, context);<br><br><span class="hljs-keyword">return</span> generator;<br>&#125;<br><br><span class="hljs-comment">// _invoke 即内部的 invoke</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeInvokeMethod</span> (<span class="hljs-params">innerFn, self, context</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg</span>) </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看看 _invoke 在哪儿调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Gp = GeneratorFunctionPrototype.prototype = Generator.prototype<br><br>defineIteratorMethods(Gp);<br><span class="hljs-comment">// 为 Generator 添加 prototype 添加 next、throw、return 方法</span><br><span class="hljs-comment">// 并且这些方法都会调用 _invoke 方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineIteratorMethods</span> (<span class="hljs-params">prototype</span>) </span>&#123;<br>[<span class="hljs-string">"next"</span>, <span class="hljs-string">"throw"</span>, <span class="hljs-string">"return"</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>define(prototype, method, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._invoke(method, arg);<br>&#125;);<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些弄明白之后，可以简单理一下编译后代码的执行步骤：</p><ol><li>var g = genFn();<ol><li>genFn() 返回 generator 对象，拥有 _invoke 方法</li><li>g 拥有 _invoke</li></ol></li><li>g.next();<ol><li>g 的 next 方法会调用 _invoke 方法</li><li>g.next()  ==&gt;  g._invoke();</li></ol></li></ol><p>到这里就可以去看看 invoke 是如何实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// 四种状态：开始、执行中、暂停执行、结束</span><br><span class="hljs-keyword">var</span> GenStateSuspendedStart = <span class="hljs-string">"suspendedStart"</span>;<br><span class="hljs-keyword">var</span> GenStateExecuting = <span class="hljs-string">"executing"</span>;<br><span class="hljs-keyword">var</span> GenStateSuspendedYield = <span class="hljs-string">"suspendedYield"</span>;<br><span class="hljs-keyword">var</span> GenStateCompleted = <span class="hljs-string">"completed"</span>;<br><br><span class="hljs-comment">// generator 方法执行的状态</span><br><span class="hljs-keyword">var</span> state = GenStateSuspendedStart;<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg</span>) </span>&#123;<br><span class="hljs-comment">// 方法体内的语句执行过程中不允许继续执行</span><br>    <span class="hljs-keyword">if</span> (state === GenStateExecuting) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Generator is already running"</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (state === GenStateCompleted) &#123;<br>        <span class="hljs-keyword">if</span> (method === <span class="hljs-string">"throw"</span>) &#123;<br>            <span class="hljs-keyword">throw</span> arg;<br>        &#125;<br>    &#125;<br><br>    context.method = method;<br>    context.arg = arg;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 省略容错逻辑</span><br>        <br>        state = GenStateExecuting;<br><br><span class="hljs-comment">// fn.call(obj, arg)</span><br><span class="hljs-comment">// fn 即 genFn$，arg 即为 context</span><br><span class="hljs-comment">//function tryCatch (fn, obj, arg) &#123;</span><br>        <span class="hljs-comment">//    try &#123;</span><br>        <span class="hljs-comment">//        return &#123; type: "normal", arg: fn.call(obj, arg) &#125;;</span><br>        <span class="hljs-comment">//    &#125; catch (err) &#123;</span><br>        <span class="hljs-comment">//        return &#123; type: "throw", arg: err &#125;;</span><br>        <span class="hljs-comment">//    &#125;</span><br>        <span class="hljs-comment">//&#125;</span><br>       <br>       <span class="hljs-comment">// 在这里调用 genFn$ 方法</span><br>        <span class="hljs-keyword">var</span> record = tryCatch(innerFn, self, context);<br>        <br>        <span class="hljs-keyword">if</span> (record.type === <span class="hljs-string">"normal"</span>) &#123; <span class="hljs-comment">// 执行 genFn$ 成功会走如下逻辑</span><br>        <span class="hljs-comment">// 如果语句执行完毕则结束执行，否则暂停执行</span><br>        state = context.done<br>                    ? GenStateCompleted<br>                    : GenStateSuspendedYield;<br>            <span class="hljs-comment">// 返回执行 yield 的结果</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                value: record.arg,<br>                done: context.done<br>            &#125;;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (record.type === <span class="hljs-string">"throw"</span>) &#123; <span class="hljs-comment">// 遇到错误则将方法改为 throw，进入下一个循环执行容错逻辑</span><br>            state = GenStateCompleted;<br>            context.method = <span class="hljs-string">"throw"</span>;<br>            context.arg = record.arg;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>invoke 通过调用的方法进行不同的操作。遇到  throw 直接 throw 错误；遇到 return 会去 complete generator；遇到 next，就会调用 genFn$ 方法，最终返回一个 value 和 done 属性的对象。</p><h2 id="解析-async"><a href="#解析-async" class="headerlink" title="解析 async"></a>解析 async</h2><p>对于 async 函数，依然使用上面的方法进行编译处理。async 编译后的代码与 generator 编译后的 regeneratorRuntime 对象是一样的，因此我们只需要关注不同点就可以了。</p><p>编译前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-number">2</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> p();<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>asyncFn();<br><span class="hljs-comment">// 2 1 1</span><br></code></pre></td></tr></table></figure><p>编译后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>resolve(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> a, b, c;<br><span class="hljs-keyword">return</span> regeneratorRuntime.async(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>_context.next = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(p());<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>a = _context.sent;<br>_context.next = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>b = _context.sent;<br>_context.next = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>c = _context.sent;<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br><span class="hljs-built_in">console</span>.log(c);<br><span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<br><span class="hljs-keyword">return</span> _context.stop();<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-built_in">Promise</span>);<br>&#125;<br><br>asyncFn();<br></code></pre></td></tr></table></figure><p>与 generator 编译之后的代码基本相同，不同的是</p><ol><li>调用的是 regeneratorRuntime.async 方法，接收4个参，其中最后一个是 Promise</li><li>内部方法 return  regeneratorRuntime.awrap, 即将 await xx 改为 regeneratorRuntime.awrap(xx)</li></ol><p>按照顺序，先来看看 async 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">exports.async = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">innerFn, outerFn, self, tryLocsList, PromiseImpl</span>) </span>&#123;<br><span class="hljs-comment">// 确保 PromiseImpl 是 Promise</span><br>    <span class="hljs-keyword">if</span> (PromiseImpl === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) PromiseImpl = <span class="hljs-built_in">Promise</span>;<br>    <br>    <span class="hljs-keyword">var</span> iter = <span class="hljs-keyword">new</span> AsyncIterator(<br>    <span class="hljs-comment">// wrap 方法返回一个 generator 对象</span><br>        wrap(innerFn, outerFn, self, tryLocsList),<br>        PromiseImpl<br>    );<br><span class="hljs-comment">// iter.next() 是一个 promise 对象</span><br>    <span class="hljs-keyword">return</span> exports.isGeneratorFunction(outerFn)<br>        ? iter<br>        : iter.next().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;   <br>            <span class="hljs-keyword">return</span> result.done ? result.value : iter.next();<br>        &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>new AsyncIterator 内部做了些什么工作呢？简化之后就很明了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AsyncIterator</span> (<span class="hljs-params">generator, PromiseImpl</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg, resolve, reject</span>) </span>&#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueue</span> (<span class="hljs-params">method, arg</span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callInvokeWithMethodAndArg</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 返回 promise 实例</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PromiseImpl(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>                invoke(method, arg, resolve, reject);<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">var</span> previousPromise;<br>        <span class="hljs-keyword">return</span> previousPromise = callInvokeWithMethodAndArg();<br>    &#125;<br>    <span class="hljs-keyword">this</span>._invoke = enqueue;<br>&#125;<br></code></pre></td></tr></table></figure><p>defineIteratorMethods 方法将 next(还有 throw、return) 方法代理给了 _invoke，所以 iter.next() 会调用_invoke，即 enqueue，而 enqueue 返回一个 promise 实例，因此可以调用 then 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">iter.next().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;   <br>    <span class="hljs-keyword">return</span> result.done ? result.value : iter.next();<br>&#125;)<br></code></pre></td></tr></table></figure><p>这段是控制 await 顺序执行的开始和结束</p><p>首先执行 iter.next()，相当于执行  enqueue，进而执行 invoke。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg, resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> record = tryCatch(generator[method], generator, arg);<br>    <span class="hljs-keyword">if</span> (record.type === <span class="hljs-string">"throw"</span>) &#123;<br>        reject(record.arg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">var</span> result = record.arg;<br>        <span class="hljs-keyword">var</span> value = result.value;<br>        <span class="hljs-keyword">if</span> (value &amp;&amp;<br>            <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> &amp;&amp;<br>            hasOwn.call(value, <span class="hljs-string">"__await"</span>)) &#123;<br>            <span class="hljs-keyword">return</span> PromiseImpl.resolve(value.__await).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>                invoke(<span class="hljs-string">"next"</span>, value, resolve, reject);<br>            &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>                invoke(<span class="hljs-string">"throw"</span>, err, resolve, reject);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> PromiseImpl.resolve(value).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">unwrapped</span>) </span>&#123;<br>            result.value = unwrapped;<br>            resolve(result);<br>        &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> invoke(<span class="hljs-string">"throw"</span>, error, resolve, reject);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行步骤如下：</p><ol><li>var record = tryCatch(generator[method], generator, arg);<ol><li>因为 generator[method] 代理给了 _invoke。因此会执行 return { type: “normal”, arg: <em>fn</em>.call(<em>obj</em>, <em>arg</em>) };所以这里的_invoke 是 generator 的 _invoke，而不是 iter 的_invoke。</li><li>接下来执行 _invoke 的步骤与 generator 函数一样，执行被包裹的函数，最终会返回 {value: xx, done: xx} 对象，但不一样的是，如果函数体没有执行完毕之前，value 是一个对象，有一个 __await 属性。</li></ol></li><li>如果 tryCatch 执行失败，则直接 reject。</li><li>如果执行成功：<ol><li>如果函数体内的 await 还未执行结束，则会将 record.value.__await 值当作参数，递归调用 invoke 方法</li><li>如果函数体执行完毕，此时的 value 是 undefined，将 record 用异步的方式返回，就会执行 iter.next() 的 then 方法内的回调，这里就是直接执行 return result.value。 因此 async 默认返回 undefined。</li></ol></li></ol><p>到这里，我们就简单理解了 generator 和 async 函数内部的工作原理。其中，async 是在 generator 的基础上工作的，它使用递归方式取代多个 next 方法调用。</p><p>奉上一张编译后代码中方法调用的简图以作参考。</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/babel_%E7%BC%96%E8%AF%91_async_generator.png" srcset="/img/loading.gif" lazyload alt="babel 编译 async&amp;generator"></p><h2 id="实现一个简版-async"><a href="#实现一个简版-async" class="headerlink" title="实现一个简版 async"></a>实现一个简版 async</h2><p>通过上面的分析，我们可以知道，async 就是一个不需要手动执行 next 方法的 generator，明白了这点就好动手了。</p><p>先上一个示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span> (<span class="hljs-params">filename, duration</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(filename)<br>            resolve(filename)<br>        &#125;, duration)<br>    &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">let</span> g = genFn();<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><br><span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 4, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 5, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br><span class="hljs-comment">// b.txt   3秒后输出</span><br><span class="hljs-comment">// a.txt   5秒后输出</span><br></code></pre></td></tr></table></figure><p>如上例所示，在实现 async 有2个问题需要解决：</p><ol><li>如何保证异步代码按调用顺序去执行（异步代码默认使用 promise 包裹）</li><li>如何自动调用 next</li></ol><p>先来实现自动调用，首先想到的是声明一个方法，在里面去执行 next 方法，然后递归调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params">genFn</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeNext</span> (<span class="hljs-params">generator</span>) </span>&#123;<br>        <span class="hljs-comment">// 在这里执行 next 方法</span><br>        <span class="hljs-keyword">let</span> result = generator.next();<br>        <span class="hljs-comment">// 如果调用结束就不再继续调用</span><br>        <span class="hljs-keyword">if</span> (result.done === <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        invokeNext(generator)<br>    &#125;<br><span class="hljs-comment">// 获取遍历器对象</span><br>    <span class="hljs-keyword">let</span> g = genFn.call(<span class="hljs-literal">null</span>);<br>    invokeNext(g)<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn_</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-comment">// 无异步代码可以按顺序执行</span><br><span class="hljs-comment">// &#123; value: 1, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 2, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 4, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 5, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br><br><span class="hljs-comment">// 对于前面异步代码的执行就会出先问题</span><br></code></pre></td></tr></table></figure><p>js 处理异步操作有多种方式，除了 generator 和 async，我们还有 promise，所以考虑用 promise 来管理每个 next 的调用顺序，事情就变得简单了，完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params">genFn</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeNext</span> (<span class="hljs-params">generator</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> value = generator.next();<br>            resolve(value)<br>        &#125;).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(result);<br>            <span class="hljs-keyword">if</span> (result.done === <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果是 promise 对象，则需要在 then 方法回调里去调用下一个 next</span><br>            <span class="hljs-keyword">if</span> (result.value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>                result.value.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    invokeNext(generator)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                invokeNext(generator)<br>            &#125;<br>        &#125;, err =&gt; &#123;<br>            reject(err);<br>        &#125;)<br>    &#125;<br>    <br>    <span class="hljs-keyword">const</span> g = genFn.call(<span class="hljs-literal">null</span>);<br>    invokeNext(g)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Generator</tag>
      
      <tag>Async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弄懂 event loop</title>
    <link href="/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/"/>
    <url>/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-event-loop"><a href="#什么是-event-loop" class="headerlink" title="什么是 event loop"></a>什么是 event loop</h2><p>简单来说，event loop 就是 JavaScript 宿主处理事件执行的一种机制。</p><p>js 以前是专门用来处理浏览器交互的，比如说 DOM 点击事件等，因此被设计成单线程，所谓单线程，就是同一时间只能处理一件事情，这也就保证了页面中一次只能处理一个事件，避免造成交互混乱的问题。</p><p><strong>开始之前，需要明确的是 JavaScript引擎是单线程的，但是 js 运行环境是多线程。因为浏览器是多线程的，除了 js 引擎线程，还包括 GUI 渲染线程、定时器触发线程、HTTP 请求线程以及 DOM 事件触发线程；node也可以使用 child_process 创建多个子线程。</strong></p><p>现在有事件 A 和 B，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> A = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> B = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);<br>&#125;<br><br>A();<br>B();<br></code></pre></td></tr></table></figure><p>按照单线程的要求，需要等到 A 执行完毕，才会执行 B，那么打印顺序会是如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);<br></code></pre></td></tr></table></figure><p>但实际上的顺序是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);<br></code></pre></td></tr></table></figure><p>这就是 event loop 机制在起作用，因为 console.log(‘i am B’) 是同步任务，而 setTimeout 是异步任务，同步任务执行完才会去执行异步任务</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><ul><li>什么是宏任务和微任务？</li></ul><p>这里有几个概念容易混淆，那就是同步任务和异步任务，宏任务和微任务。js 的代码执行遵循在代码块内从上往下执行的规则，同步任务会依次执行；而异步任务则会分为宏任务和微任务，比如 setTimeout 的第一个参数是宏任务，promise.then 中注册的方法是微任务，会按照宏任务和微任务的执行规则进行执行。</p><ul><li>宏任务和微任务有哪些？</li></ul><p>js 执行的宿主环境有浏览器和 Node,  所以我们通过宿主环境的不同来整理这些异步任务：</p><table><thead><tr><th>宏任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>setTimeout</td><td>√</td><td>√</td></tr><tr><td>setInterval</td><td>√</td><td>√</td></tr><tr><td>setImmediate</td><td>x</td><td>√</td></tr><tr><td>I/O</td><td>√</td><td>√</td></tr><tr><td>requestAnimationFrame</td><td>√</td><td>x</td></tr></tbody></table><table><thead><tr><th>微任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>mutationObserver</td><td>√</td><td>x</td></tr><tr><td>promise</td><td>√</td><td>√</td></tr><tr><td>process.nextTick</td><td>x</td><td>√</td></tr></tbody></table><ul><li>宏任务和微任务的执行顺序</li></ul><p>要点一：一个宏任务里可能会包含多个微任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 promise 里的 同步任务'</span>)<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务1'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务2'</span>)<br>&#125;)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 setTimeout 里的 宏任务'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们来分析下这段代码里的宏任务和微任务有哪些：<br>宏任务：setTimeout 的回调<br>微任务：两个 then 方法的回调</p><p>要点二：宏任务是一个一个执行的，而微任务是批量执行的，当前批次微任务没有完成之前，下一个宏任务不会执行</p><p>因此执行顺序是:</p><ol><li>遇到 promise，参数里面的代码是同步的，所有会先执行 console.log(‘我是 promise 里的 同步任务’)</li><li>执行两个 then 方法的回调</li><li>执行 setTimeout 的回调</li></ol><p>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// console.log('我是 promise 里的 同步任务')</span><br><span class="hljs-comment">// console.log('我是微任务1')</span><br><span class="hljs-comment">// console.log('我是微任务2')</span><br><span class="hljs-comment">// console.log('我是 setTimeout 里的 宏任务')</span><br></code></pre></td></tr></table></figure><h2 id="浏览器下的-event-loop"><a href="#浏览器下的-event-loop" class="headerlink" title="浏览器下的 event loop"></a>浏览器下的 event loop</h2><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/%E6%B5%8F%E8%A7%88%E5%99%A8_event_loop.png" srcset="/img/loading.gif" lazyload alt="浏览器 event loop"></p><p>如图所示，代码执行步骤如下：</p><ol><li>js 在执行代码时，会将代码放入执行栈中，遇到同步任务，会依次执行；遇到如 DOM 点击事件、ajax 以及 定时器等异步任务，浏览器会交给其他辅线程调用 WebApis  进行处理。</li><li>如果 WebApis 处理的异步任务有了结果，就会将该任务推入到回调队列（callback queue）中，回调队列分为宏任务队列和微任务队列。</li><li>一旦执行栈内（stack）的任务执行完成，就会将回调队列里的任务放入执行栈中执行，顺序如下：<ol><li>如果微任务队列中存在任务，则一次性执行所有微任务</li><li>将宏任务队列的第一个任务放入执行栈中执行</li></ol></li></ol><p>以上步骤的循环就是浏览器中的 event loop。</p><p>看一个简单例子感受下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;)<br><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'success'</span>)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback3</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'start'</span>)<br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ol><li>遇到 setTimeout，等待时间到达后将 callback1 放入宏任务队列</li><li>遇到 promise.then，等待时间到达后将 callback2 与 callback3  按顺序放入微任务队列</li><li>执行同步任务 console.log。</li><li>执行完同步任务，将微任务队列里的任务一次性执行</li><li>微任务执行完之后，执行宏任务队列的第一个任务</li></ol><h2 id="node-下的-event-loop"><a href="#node-下的-event-loop" class="headerlink" title="node 下的 event loop"></a>node 下的 event loop</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">   ┌───────────────────────────┐                             <br>┌─&gt;│           timers          │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐                                    <br>│  │     pending callbacks     │                             <br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │       idle, prepare       │<br>│  └─────────────┬─────────────┘      ┌───────────────┐<br>│  ┌─────────────┴─────────────┐      │   incoming:   │<br>│  │           poll            │&lt;─────┤ connections,  │<br>│  └─────────────┬─────────────┘      │   data, etc.  │<br>│  ┌─────────────┴─────────────┐      └───────────────┘<br>│  │           check           │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>└──┤      close callbacks      │<br>   └───────────────────────────┘<br></code></pre></td></tr></table></figure><p>如上图所示，node 中的 event loop 分为6个循环阶段，当 node.js 启动的时候，会初始化 event loop</p><ul><li>timers： 这个阶段执行 setTimeout 和 setInterval 的回调函数</li><li>pending callbacks：在下一个循环中执行 I/O 回调函数</li><li>idle, prepare：只在 node 内部触发</li><li>poll：获取新的 I/O 事件，在适当的时候阻塞在这里</li><li>check：执行 setImmediate 的回调函数</li><li>close callbacks：执行关闭事件的回调函数，如 socket.on(‘close’, … )</li></ul><p>下面主要对 timers、poll、check 三个阶段进行解析：</p><h3 id="一、timers"><a href="#一、timers" class="headerlink" title="一、timers"></a>一、timers</h3><p>timers 阶段的回调函数可能并不会按照设定的时间延迟去执行，因为 event loop 初始化或者其他阶段回调函数的长时间执行会延迟它们的执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAsyncOperation</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-comment">// 假设读取文件需耗时 95ms</span><br>    fs.readFile(<span class="hljs-string">'./a.txt'</span>, callback)<br>&#125;<br><br>cosnt timeoutScheduled = <span class="hljs-built_in">Date</span>.now();<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> delay = <span class="hljs-built_in">Date</span>.now() - timeoutScheduled;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);<br>&#125;, <span class="hljs-number">100</span>)<br><br>someAsyncOperation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> startCallbackTime = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - startCallbackTime &lt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上方示例在 node 里的大致执行步骤如下：</p><ol><li>timer 阶段：因为需要延迟 100ms，所以当前没有 callback 需要执行，进入 pending callback 阶段</li><li>pending callback阶段：没有 I/O 回调需要执行，进入 idle，</li><li>idle 忽略</li><li>poll 阶段：因为此时有 I/O 操作，因此会阻塞在这里，等待95ms至文件读取结束，然后将 callback 放入队列进行执行，耗时10ms。调用结束后，当前队列为空，检查 timers，发现设定时间为95ms，当前运行时间超时了，因此进入 timer 阶段执行回调，所以会打印出”105ms has passed since I was scheduled”</li></ol><h3 id="二、poll"><a href="#二、poll" class="headerlink" title="二、poll"></a>二、poll</h3><p>poll 阶段主要有两个功能：</p><p>1.计算它应该阻塞和轮询 I/O 多长时间</p><p>2.处理该阶段事件</p><p>当 event loop 进入 poll 阶段并且未设定定时器，会出现下面中的某个情况：</p><ul><li>如果 poll 的队列不为空，那么就会遍历队列，并异步执行完所有回调函数，或者执行耗时达到系统设定的最大时间</li><li>如果 poll 队列为空，那以下情况中的一个会出现：<ol><li>如果代码设定了 setImmediate 方法，event loop 会结束 poll 阶段，进入 check 阶段去执行 check 队列</li><li>如果没有设定 setImmediate 方法，就会阻塞在 poll 阶段，直到有 poll callback 添加到队列中，然后立刻执行。</li></ol></li></ul><p>如果 event loop 进入 poll 阶段并且设定了定时器：</p><ul><li>一旦 poll 队列处于空闲状态，event loop 会查看 timers 里的回调函数，如果至少有一个回调函数的时间到了，event loop 会按循环顺序进入 timers 阶段去执行这些回调函数。</li><li>按循环顺序说的是 event loop 不会直接进入 timers 阶段，而是要先进入 check、close callback 之后，再进入 timers 阶段。</li></ul><h3 id="三、check"><a href="#三、check" class="headerlink" title="三、check"></a>三、check</h3><ul><li>这个阶段用来存放 setImmediate 回调函数，如果代码中设定了，那么 event loop 不会阻塞等待在 poll 阶段，而是会进入 check 阶段。</li><li>当 poll 阶段结束，进入check 阶段后，会调用 libuv api 去执行回调函数</li></ul><h3 id="四、API-比较"><a href="#四、API-比较" class="headerlink" title="四、API 比较"></a>四、API 比较</h3><ul><li><p>setTimeout 和 setImmediate</p><ol><li>setTimeout 设定一个任务在等待指定时间后去执行</li><li>setImmediate 在 poll 阶段完成后立即去调用它设定的代码</li><li>它们回调函数执行的顺序依据它们执行的方式会有不同：如果它们的执行不在 I/O 操作里，那么顺序时不定的，如果在 I/O 中，永远都是 setImmediate 最先执行</li></ol></li><li><p>process.nextTick</p></li></ul><p>在技术上来说，nextTick 不属于 event loop 的一部分，凡是放进 nextTick 队列的回调函数会在下一次 event loop 循环开始前执行。需要注意的是，正是因为这个特性，如果递归调用 nextTick，会导致下一次 event loop 无法开始。</p><h3 id="node-中宏任务和微任务"><a href="#node-中宏任务和微任务" class="headerlink" title="node 中宏任务和微任务"></a>node 中宏任务和微任务</h3><p>因为 node 中的 宏任务分处于不同的阶段，并且微任务中的 process.nextTick 都是先于其它微任务执行，所以可以理解为 有4个宏任务队列以及2个微任务队列。</p><p>这里为了便于理解，借用一张图：</p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a8667e6b79cc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" lazyload alt="node-eventloop" style="zoom:80%;;margin-left:0" /><p>这里的宏任务和微任务流程模型与浏览器的相同，区别在于：</p><ol><li>node 中的宏任务队列执行顺序取决于 event loop 所处的阶段</li><li>微任务中，process.nextTick 独处一个队列，比其他微任务要早执行</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>event loop 相当于一个总指挥，负责 js 任务的协调与调度。</p><p>参考文献 <a href="https://juejin.cn/post/6844903670291628046#heading-5" target="_blank" rel="noopener">https://juejin.cn/post/6844903670291628046#heading-5</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Event Loop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟着规范实现一个功能完备的Promise</title>
    <link href="/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/"/>
    <url>/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/</url>
    
    <content type="html"><![CDATA[<p>一直以来，对于 promise，只知道如何使用，其内部的运作机制却不得而知。本着知其然，知其所以然（为了让自己用得安心）的理念，决定跟着规范去了解底层的原理，并手写一个功能完备的 MyPromise.</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>promise 是一个对象或者函数，拥有 then 方法</li><li>thenable 可以理解为一个拥有 then 方法的对象或函数</li><li>value 是一个合法的 JavaScript值</li><li>reason 用来表示 promise 拒绝的原因</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>promise 初始状态为 pending，可以转变成 fulfilled 或者 rejected</li><li>如果状态是 fulfilled，则不能转变为 rejected 或者 pending。rejected 同理。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面开始尝试第一版：</p><p>平时都是通过 new 来创建一个 promise 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>    resolve(<span class="hljs-string">'xxx'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>于是首先创建一个 promise 构造函数，接收一个方法 executor 作为参数, 在内部直接执行，并且传入两个方法以供使用者使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>    <br>    executor(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果调用 resolve 方法，会将 Promise实例 状态转变成 fulfilled，如果调用 reject 方法，则会将 Promise 实例状态转变成 rejected。所以接下来给 MyPromise 构造函数添加相应属性，并实现 resolve 和 reject。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'pending'</span>;<br>    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只有处于 pending 状态，才能发生状态改变</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;<br>            <span class="hljs-keyword">this</span>.reason = reason;<br>        &#125;<br>    &#125;<br>    <br>    executor(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数建造完毕，现在来处理最主要的部分 then 方法，这也是规范给出详细标准的一部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以接收两个方法作为参数, 在内部可以根据 MyPromise 实例的状态进行相应的操作</span><br>MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 then 执行的时候，如果 status 是 fulfilled 或者 rejected 状态，可以直接执行 onFulfilled 或者 onRejected 方法，但如果依然还是 pending，需要将这些执行操作放入等待区，也就是存入到回调队列中，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;)<br>        <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            onRejected(<span class="hljs-keyword">this</span>.reason)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>        onFulfilled(<span class="hljs-keyword">this</span>.value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>        onRejected(<span class="hljs-keyword">this</span>.reason)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在，待执行栈已经存在了状态改变的回调，需要在合适的时机去执行，所以需要完善 resolve 和 reject 方法。一旦状态改变，则将带执行栈中的回调全部执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;<br>    <span class="hljs-keyword">this</span>.value = value;<br>    <span class="hljs-comment">// 执行回调</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onFulfilledStack.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onFulfilledStack.shift()(<span class="hljs-keyword">this</span>.value);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;<br>    <span class="hljs-keyword">this</span>.reason = reason;<br>    <span class="hljs-comment">// 执行回调</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onRejectedStack.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onRejectedStack.shift()(<span class="hljs-keyword">this</span>.reason);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道then 方法必须返回一个 promise，因此需要对 then 方法进一步改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就要思考一下，then 方法为什么要返回一个 promise？ 原因是每一个 promise 都会有一个 then 方法，而如果 then 方法也返回一个 promise，那么这个 then 也会有一个 then 方法，于是可以像下方代码一样链式调用 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).then().then()<br></code></pre></td></tr></table></figure><p>但还有个原因。我们不仅可以像上方一样 resolve 一个基本值，也可以 resolve 一个 promise，如下方例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">_resolve, _reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            _resolve(<span class="hljs-string">'success'</span>)<br>        &#125;, <span class="hljs-number">2000</span>)<br>    &#125;))<br>&#125;).then().then()<br></code></pre></td></tr></table></figure><p>因为被 resolve 的 promise 的状态是尚未改变的，因此可以将这个 promise 放进 then 返回的这个 promise 内去等待状态改变，所以这一步我们将 then 方法内原先的处理逻辑挪到这个返回的 promise 内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> _promise = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 因为 onFulfilled(this.value) 和 onRejected(this.reason) 可能返回一个 thenable，因此需要将下方代码移入新 promise内部去执行</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            &#125;)<br>            <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onRejected(<span class="hljs-keyword">this</span>.reason)<br>            &#125;)<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>            onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>            onRejected(<span class="hljs-keyword">this</span>.reason)<br>        &#125;<br>    &#125;)<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>有个问题，我们在内部直接调用 onFulfilled 和 onRejected，但却没有对这两个方法类型进行错误处理，也就是必须保证它们是 function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// 设置默认的回调方法（需原样返回传进来的值或者抛出同样的值），可以保证 promise 结果能够透传</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个处理，如果 onFulfilled 和 onRejected 不是 function，那么就将它们赋值成方法，并且将接收到的值进行相应处理：如果是 onFulfilled，直接将值 return，如果是 onRejected, 主动抛出一个错误。这也就实现了 promise 值的透传</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).then().then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value)  <span class="hljs-comment">// success</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>目前为止，MyPromise 已经具备了可实例化，可执行同步任务的功能。但还无法执行异步任务。</p><p>规范2.2.4： onFulfilled or onRejected must not be called until the execution context stack contains only platform code。</p><p>意思是：onFulfilled 和 onRejected 方法需要异步执行。</p><p>接下来对 then 方法进行进一步完善, 将它们的执行丢到异步环境中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">let</span> _promise = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    onFulfilled(<span class="hljs-keyword">this</span>.value);<br>                &#125;)<br>                <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    onRejected(<span class="hljs-keyword">this</span>.reason)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            &#125;)<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onRejected(<span class="hljs-keyword">this</span>.reason)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>规范2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x)</p><p>意思是： 对 onFulfilled 或者 onRejected 返回的值 x 进行 resolvePromise 操作，即需要将 x 当作一个 thenable 来对待，then 返回的 promise 的 状态需要 x 的状态来决定。</p><p>这里需要注意： resolvePromise 需要 promise2（即 then 返回的 promise） 和 x 这两个参，但是 promise2 的状态需要它自身 resolve 和 reject 去改变，因此将 resolve 和 reject 也带上。</p><p>改动如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>    <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            resolvePromise(_promise, x, resolve, reject)<br>        &#125;)<br>    &#125;)<br>    <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);<br>            resolvePromise(_promise, x, resolve, reject)<br>        &#125;) <br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        resolvePromise(_promise, x, resolve, reject)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);<br>        resolvePromise(_promise, x, resolve, reject)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是实现 resolvePromise 方法了。</p><p>按照规范 2.3 The Promise Resolution Procedure，一步步实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">_promise, x, resolve, reject</span>)</span>&#123;<br>    <span class="hljs-comment">// 2.3.1 如果 _promise 和 x 是同一个对象，reject TypeError</span><br>    <span class="hljs-keyword">if</span> (x === _promise) &#123;<br>        <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;x&#125;</span> should no refer to the same object with MyPromise`</span>))<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当 x 是对象或者函数时：</span><br>    <span class="hljs-comment">// 判断 x.then 方法中 onFulfilled 回调或者 onRejecetd 回调是否执行过</span><br>    <span class="hljs-comment">// 因为规范规定：其中每一个回调只能执行一次</span><br>    <span class="hljs-comment">// 当其中某项执行过，就将 hasCalled 置为 true</span><br>    <span class="hljs-keyword">let</span> hasCalled = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> MyPromsie) &#123;<br>        <span class="hljs-comment">// 如果状态没有改变，则需要调用 then 方法，然后在内部还需要对以后的返回值进行 resolvePromise </span><br>        <span class="hljs-keyword">if</span> (x.status === <span class="hljs-string">'pending'</span>) &#123;<br>            x.then(<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;<br>                resolvePromise(_promise, y, resolve, reject)<br>            &#125;, err =&gt; &#123;<br>                resolvePromise(_promise, err, resolve, reject)<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果状态已经改变，那么 x 就会有一个正常值，假设为 z</span><br>            <span class="hljs-comment">// 执行 x.then(resolve, reject)，会直接调用 resolve(z) 或者 reject(z) ：</span><br>            <span class="hljs-comment">// 2.3.2.2 &amp;&amp; 2.3.2.3</span><br>            x.then(resolve, reject);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(x) === <span class="hljs-string">'[object Object]'</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span>) &#123; <span class="hljs-comment">// x 是对象或者函数</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> then = x.then;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) &#123;<br>                then.call(x, y =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (hasCalled) &#123; <span class="hljs-keyword">return</span> &#125;<br>                    hasCalled = <span class="hljs-literal">true</span>;<br>                    resolvePromise(_promise, y, resolve, reject)<br>                &#125;, err =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (hasCalled) &#123; <span class="hljs-keyword">return</span> &#125;<br>                    hasCalled = <span class="hljs-literal">true</span>;<br>                    reject(err);<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                resolve(x)<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>            <span class="hljs-comment">// 2.3.3.3.4.1</span><br>            <span class="hljs-comment">// if resolvePromise or rejectPromise have been called, ignore it.</span><br>            <span class="hljs-keyword">if</span> (!hasCalled) &#123;<br>                reject(err)<br>            &#125;<br>        &#125;<br>        <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 2.3.4</span><br>        resolve(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果能通过 promiseA+ 测试，说明该版本的 Promise 符合规范，但是还缺少常用的功能，继续完善：</p><p><strong>MyPromise.resolve</strong></p><p>接收一个值，在内部创建一个新的实例，将状态交给新实例去处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(value)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.catch</strong></p><p>接收一个方法，只会在 rejected 状态下执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.finally</strong></p><p>接收一个方法，不论 fulfilled 或者 rejected 都会执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(callback, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.all</strong></p><p>接收一个数组，只有所有项的状态为 fulfilled，最终结果才为 fulfilled，如果有一个 rejected，那么结果就是 rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = [];<br>        <span class="hljs-keyword">let</span> resolveCount = <span class="hljs-number">0</span>;<br>        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                result[index] = value;<br>                resolveCount++;<br>                <span class="hljs-keyword">if</span> (resolveCount === promiseArr.length) &#123;<br>                    resolve(result);<br>                &#125;<br>            &#125;, err =&gt; &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.race</strong></p><p>接收一个数组，结果由第一个状态改变的 thenable 决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value);<br>            &#125;, err =&gt; &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.allSettled</strong></p><p>接收一个数组，只有等到所有项的状态都改变了，不论是 fulfilled 还是 rejected，都只会变成 fulfilled</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> resultArr = [];<br>        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resultArr.push(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: value&#125;);<br>                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;<br>                    resolve(resultArr);<br>                &#125;<br>            &#125;, err =&gt; &#123;<br>                resultArr.push(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: err&#125;);<br>                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;<br>                    resolve(resultArr);<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.any</strong></p><p>接收一个数组，如果其中有一项的状态为 fulfilled， 那么结果就是 fulfilled，否则如果所有都是 rejected，那结果就是 rejected， 并且 reanson 是 ‘AggregateError: All promises were rejected’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.any = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> rejectCount = <span class="hljs-number">0</span>;<br>        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value);<br>            &#125;, err =&gt; &#123;<br>                rejectCount ++;<br>                <span class="hljs-keyword">if</span> (rejectCount === promiseArr.length) &#123;<br>                    reject(<span class="hljs-string">'AggregateError: All promises were rejected'</span>);<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法：</p><p>#安装 promises-aplus-tests</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i promises-aplus-tests -g<br></code></pre></td></tr></table></figure><p>#在代码里加上这段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> defer = &#123;&#125;;<br>    defer.promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        defer.resolve = resolve;<br>        defer.reject = reject;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> defer;<br>&#125;<br></code></pre></td></tr></table></figure><p>#最后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">promises-aplus-tests promise.js<br></code></pre></td></tr></table></figure><p>有一点需要注意：我在实现 promise 内部异步执行时采用的是 setTimeout，而 promise 的 then 方法是一个微任务这与实际有出入。不过用于理解其中的异步理念已经足够了。追求完美的同学可自行实现不同的版本。</p><p>完整代码地址：<a href="https://github.com/yuwengCipher/MyPromise" target="_blank" rel="noopener">https://github.com/yuwengCipher/MyPromise</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说 js 的异步处理机制</title>
    <link href="/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>在 JavaScript 中和生活中都会有异步任务的存在，而异步的产生是有前提条件的，那就是这个任务可以被拆解成两部分。</p><p>举个简单的例子。周末我想喝点排骨汤，把所有步骤都准备好后开火炖。正常来说，这锅汤需要3小时才能煲好，很显然我不会傻傻守在这儿等它3小时，因为我还有别的事要做，比如说看电视，嗑瓜子等等。而是3小时后汤煲好了，我才回去盛起来喝。</p><p>所以这个喝汤任务由两个步骤组成：煲汤 + 喝汤；这个喝汤步骤就是异步的</p><h2 id="设计成异步的原因"><a href="#设计成异步的原因" class="headerlink" title="设计成异步的原因"></a>设计成异步的原因</h2><p>从上面可以知道，如果我傻傻的在锅前等3个小时，那么我看电视、嗑瓜子等事情就得向后延3小时，到最后我这一天做不了什么，所以傻等3小时完全是浪费时间。</p><p>js 是单线程，同一时间只能做一件事，长时间的等待势必会造成资源的浪费</p><h2 id="异步实现方案"><a href="#异步实现方案" class="headerlink" title="异步实现方案"></a>异步实现方案</h2><ul><li>回调函数</li></ul><p>回调函数在 js 代码里随处可见，如给 DOM 添加点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> d = <span class="hljs-built_in">document</span>.getElementId(<span class="hljs-string">'test'</span>);<br>d.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br><span class="hljs-comment">// callback 就是回调函数</span><br></code></pre></td></tr></table></figure><p>node 里去读取一份文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>但是有时候的需求会比较复杂，加入多个任务存在依赖性，就会写出如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>    fs.readFile(<span class="hljs-string">'./test1.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>        fs.readFile(<span class="hljs-string">'./test2.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>深层嵌套让我们很是绝望！</p><ul><li>promise</li></ul><p>幸运的是后来有了 promise，带我们逃离了“回调地狱”，来到新世界：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>        resolve(data);<br>    &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">err, data1</span>)</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        resolve(data1);<br>    &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">err, data2</span>)</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        resolve(data2);<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样写之后是不是看起来清爽了，瞬间头也不晕了，promise 让流程执行的过程更清晰！</p><p>但是你一定见过这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>        resolve(data);<br>    &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>...<br></code></pre></td></tr></table></figure><p>真的是链式调用一时爽，一直链式调用… 就有点难受了。 promise 抑制了回调地狱的横向扩张，却发现自己的纵向扩张也很厉害。</p><ul><li>generator</li></ul><p>generator 函数与普通的函数不同，函数内的代码可以分段执行，也就是说可以暂停执行，凡是需要暂停的地方用 yield 关键字注明。具体用法参考阮老师文章的介绍 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/04/generator.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">let</span> gen = genFn();<br>gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>于是对于上面依次读取文件的例子可以改写成如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟文件请求</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration</span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(filename)<br>        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span><br>        gen.next(filename)<br>    &#125;, duration)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 顺序请求三个文件，期望的是顺序打印出结果</span><br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> gen = genFn();<br>gen.next();<br><br><span class="hljs-comment">// a.txt   5秒后打印</span><br><span class="hljs-comment">// b.txt   8秒后打印</span><br><span class="hljs-comment">// c.txt   9秒后打印</span><br></code></pre></td></tr></table></figure><p>虽然获取文件所需时长 a &gt; b &gt; c, 但是打印的结果却是 a，b，c，也就是说在 generator 函数内，yield 是按上到下执行的，使得代码执行顺序更清晰明了。</p><p>可以看到我需要在文件请求完成之后手动调用 next 方法，因此在实际工作中，我们通常需要将 generator 函数包裹在一个函数内：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callGen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>, gen);<br>        <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>, gen);<br>        <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>, gen);<br>    &#125;<br>    <span class="hljs-keyword">const</span> gen = genFn();<br>    gen.next();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(filename)<br>        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span><br>        g.next(filename)<br>    &#125;, duration)<br>&#125;<br><br>callGen();<br></code></pre></td></tr></table></figure><p>总的来说，generator 函数改善了 promise 的 then “链条”过长的缺点，但是需要额外创建一个函数来包装。</p><ul><li>async await</li></ul><p>作为 ES7 提出的 async 函数，在 generator 基础上进行优化，是目前 js 处理异步操作的最优解决方案，让异步处理代码可读性更强，流程控制更方便。</p><p>我们按照 async 方法的用法来继续优化上面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    <span class="hljs-comment">// 因为 await 关键字后面需要接收一个 promise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            resolve(filename)<br>        &#125;, duration)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>asyncFn();<br><br><span class="hljs-comment">// 9秒后一次性打印</span><br><span class="hljs-comment">// a.txt </span><br><span class="hljs-comment">// b.txt </span><br><span class="hljs-comment">// c.txt</span><br></code></pre></td></tr></table></figure><p>需要注意的是如果 await 后面表达式里包含异步操作但返回的不是 promise，那么就就不会等待到结果返回，比如这样修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (filename === <span class="hljs-string">'a.txt'</span>) &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> filename<br>        &#125;, duration)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                resolve(filename)<br>            &#125;, duration)<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br>asyncFn();<br><br><span class="hljs-comment">// undefined 立刻输出</span><br><span class="hljs-comment">// b.txt     4秒之后输出</span><br><span class="hljs-comment">// c.txt     4秒之后输出</span><br></code></pre></td></tr></table></figure><p>也就是说第一个 await 没有阻塞 console.log(a) 的执行。因此 async 对 await 后面的表达式又两种处理方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> promise<br>   <span class="hljs-keyword">async</span> 会执行表达式并等待有返回值才会继续往下执行代码<br><span class="hljs-number">2.</span> 非 promise<br>   <span class="hljs-keyword">async</span> 执行表达式并立刻获取返回值，如果没有则为 <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js 处理异步的方法经历了 回调函数、promise、generator、async 这四个阶段，每一种新方法都是对前方法的改善，主要处理的点有两点：</p><ol><li>可读性更强</li><li>流程控制更清晰</li></ol>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异步处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
