<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>computed的[怪异]表现</title>
    <link href="/2021/04/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/computed%E7%9A%84%5B%E6%80%AA%E5%BC%82%5D%E8%A1%A8%E7%8E%B0/"/>
    <url>/2021/04/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/computed%E7%9A%84%5B%E6%80%AA%E5%BC%82%5D%E8%A1%A8%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档中说明了 computed 存在的理由，有两条，一是如果插值表达式中的逻辑比较复杂，则可以使用 computed 代替；二是用来封装复杂计算，因为 computed 拥有缓存功能，只有响应式依赖项发生了改变， computed 的值才会改变。个人觉得第一条使用方法也可以代替，主要原因还是第二条，作用很大。但是不知道大家在使用 computed 属性的时候有没有如下疑问：</p><ol><li>computed 其实是一个方法，为什么可以像普通值一样使用，不需要带 () 进行调用</li><li>依赖项的改变如何促使 computed 改变</li><li>为什么 computed 拥有缓存功能</li><li>如果没有在模板中使用，即使依赖项发生改变，computed 也不会重新求值</li><li>如果依赖项不是响应式的，为什么不会重新求值</li></ol><p>刚开始使用的时候，就非常不理解这些不寻常的表现，于是想着通过阅读源码去弄懂这一切，特此记录一下。本文会以官方 demo 为例，</p><h2 id="Vue-如何处理-computed"><a href="#Vue-如何处理-computed" class="headerlink" title="Vue 如何处理 computed"></a>Vue 如何处理 computed</h2><h3 id="computed-为什么可以像普通值一样使用"><a href="#computed-为什么可以像普通值一样使用" class="headerlink" title="computed 为什么可以像普通值一样使用"></a>computed 为什么可以像普通值一样使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"demo"</span>&gt;<br>&lt;p&gt;Computed reversed message: <span class="hljs-string">"&#123;&#123; reversedMessage &#125;&#125;"</span>&lt;<span class="hljs-regexp">/p&gt;</span><br><span class="hljs-regexp">&lt;/</span>div&gt;<br><br>data: &#123;<br>message: <span class="hljs-string">'Hello'</span><br>&#125;,<br>computed: &#123;<br>reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>找到 initState，这是合并完 options 之后执行的方法，里面会调用 initComputed(vm, opts.computed) 处理 computed，opts 就是合并完成的 options。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initComputed</span> (<span class="hljs-params">vm, computed</span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> computed) &#123;<br><span class="hljs-keyword">var</span> userDef = computed[key];<br><span class="hljs-keyword">var</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">'function'</span> ? userDef : userDef.get;<br><span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;<br>defineComputed(vm, key, userDef);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>遍历 computed 对象，获取到 key 对应的方法，如果是浏览器端，就创建一个 watcher。然后判断 vm 是否已经存在该 key 的属性，如果没有就去声明这个 computed 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineComputed</span> (<span class="hljs-params">target, key, userDef</span>) </span>&#123;<br><span class="hljs-keyword">var</span> shouldCache = !isServerRendering();<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">'function'</span>) &#123;<br>sharedPropertyDefinition.get = shouldCache<br>? createComputedGetter(key)<br>: createGetterInvoker(userDef);<br>sharedPropertyDefinition.set = noop;<br>&#125;<br><span class="hljs-comment">// 省略</span><br><span class="hljs-built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition);<br>&#125;<br></code></pre></td></tr></table></figure><p>sharedPropertyDefinition 拥有 get 和 set 方法，set 是 noop，可以忽视，get 分为两种情况：如果不是服务端渲染，那么就是使用 createComputedGetter(‘reversedMessage’) 创建，否则就是 createGetterInvoker(userDef) 创建。最后使用 Object.defineProperty 将 reversedMessage 这个属性添加到 vm 中。准备工作已经做好了，因为 computed 是放在模板中的，那么肯定会经过 render 函数去处理，下面就是 render 函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anonymous</span>(<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">with</span>(<span class="hljs-keyword">this</span>)&#123;<span class="hljs-keyword">return</span> _c(<span class="hljs-string">'div'</span>,&#123;<span class="hljs-attr">attrs</span>:&#123;<span class="hljs-string">"id"</span>:<span class="hljs-string">"demo"</span>&#125;&#125;,[_c(<span class="hljs-string">'p'</span>,[_v(<span class="hljs-string">"Computed reversed message: \""</span>+_s(<span class="hljs-string">"olleH"</span>)+<span class="hljs-string">"\""</span>)])])&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>可以看到  被转换成了 _s(reversedMessage)，当 _s(reversedMessage) 执行的时候，相当于执行 _s(this.reversedMessage)，此时 this.reversedMessage 就会触发前面绑定的 get 方法，也就是 computedGetter。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">computedGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> watcher = <span class="hljs-keyword">this</span>._computedWatchers &amp;&amp; <span class="hljs-keyword">this</span>._computedWatchers[key];<br><span class="hljs-keyword">if</span> (watcher) &#123;<br><span class="hljs-keyword">if</span> (watcher.dirty) &#123;<br>watcher.evaluate();<br>&#125;<br><span class="hljs-keyword">if</span> (Dep.target) &#123;<br>watcher.depend();<br>&#125;<br><span class="hljs-keyword">return</span> watcher.value<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为是浏览器端，所以在 initComputed 内部声明过 watcher，即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> computedWatcherOptions = &#123; <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span> &#125;;<br><span class="hljs-keyword">if</span> (!isSSR) &#123;<br>watchers[key] = <span class="hljs-keyword">new</span> Watcher(<br>vm,<br>getter || noop,<br>noop,<br>computedWatcherOptions<br>);<br>&#125;<br></code></pre></td></tr></table></figure><p>watcher options 的 lazy 设置为 true，在 Watcher 构造函数内会将 dirty 设置成这样 this.dirty = this.lazy，因此 this.dirty = true。也就是说会执行 watcher.evaluate()。watcher.evaluate 方法又会涉及到 watcher.get 方法，因此同时展示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js">Watcher.prototype.evaluate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.get();<br><span class="hljs-keyword">this</span>.dirty = <span class="hljs-literal">false</span>;<br>&#125;;<br><br>Watcher.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span> (<span class="hljs-params"></span>) </span>&#123;<br>pushTarget(<span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">var</span> value;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">this</span>.vm;<br><span class="hljs-keyword">try</span> &#123;<br>value = <span class="hljs-keyword">this</span>.getter.call(vm, vm);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.user) &#123;<br>handleError(e, vm, (<span class="hljs-string">"getter for watcher \""</span> + (<span class="hljs-keyword">this</span>.expression) + <span class="hljs-string">"\""</span>));<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> e<br>&#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.deep) &#123;<br>traverse(value);<br>&#125;<br>popTarget();<br><span class="hljs-keyword">this</span>.cleanupDeps();<br>&#125;<br><span class="hljs-keyword">return</span> value<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先调用 watcehr.get()，会触发 this.getter.call(vm, vm)，即调用 reversedMessage 方法，将 watcher.value 赋值为 ‘olleH’; 最后返回 watcher.value 即 ‘olleH’。那么 render 函数的这部分 [_v(“Computed reversed message: &quot;“+_s(reversedMessage)+”&quot;“)]，就变成了 [_v(“Computed reversed message: &quot;“+_s(“olleH”)+”&quot;“)]。这样就实现了 computed 不带()进行使用了，而是在内部去调用 reversedMessage 方法。这个实现有两个关键点：</p><ol><li>将 computed.reversedMessage 代理给了 vm.rereversedMessage</li><li>使用 object.defineProperty 对 vm.rereversedMessage 进行数据劫持</li></ol><h3 id="computed-如何响应式改变"><a href="#computed-如何响应式改变" class="headerlink" title="computed 如何响应式改变"></a>computed 如何响应式改变</h3><p>在 demo 中 mounted 钩子中加上下面这段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-keyword">this</span>.message = <span class="hljs-string">'cipher'</span><br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure><p>然后可以看到，在一秒后改变 message 的值，页面显示从 Computed reversed message: “olleH” 变成了 Computed reversed message: “rehpic”，符合预期，响应式依赖项改变时，computed 也发生了改变。我们来看看这是怎么实现的。</p><p>message 作为一个响应式属性，在最开始进行响应式设定的时候，它拥有一个 getter 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> dep = <span class="hljs-keyword">new</span> Dep();<br><span class="hljs-keyword">get</span>: function reactiveGetter () &#123;<br><span class="hljs-comment">// 获取 message 当前值</span><br><span class="hljs-keyword">var</span> value = getter ? getter.call(obj) : val;<br><span class="hljs-comment">// 如果收集者存在当前目标</span><br><span class="hljs-keyword">if</span> (Dep.target) &#123;<br><span class="hljs-comment">// 将 Dep.targe 存入 dep.subs 中</span><br>dep.depend();<br><span class="hljs-comment">// 如果 observe 返回的值需要响应式处理</span><br><span class="hljs-keyword">if</span> (childOb) &#123;<br><span class="hljs-comment">// // 将 Dep.targe 存入 childOb.dep.subs 中</span><br>childOb.dep.depend();<br><span class="hljs-comment">// 处理数组情况</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>dependArray(value);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> value<br>&#125;,<br></code></pre></td></tr></table></figure><p>上面已经说过，在内部会调用 reversedMessage 方法去获取最新的值，而这个值就是 this.message.split(‘’).reverse().join(‘’) 返回的，此时又会触发 message 的 get 方法，即上面那段代码。reversedMessage get 方法触发的时候，会执行 pushTarget(this) 将 Dep.target 设置成 this._computedWatchers[‘reversedMessage’]，执行 dep.depend()，最后执行 dep.addSub(watcher) 将 watcher 存入 dep.subs 数组中，这个 dep 是 message 的监听收集器。</p><p>综合上面说的步骤，总结方法执行图如下：</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/computed%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86.png" srcset="/img/loading.gif" lazyload alt="computed依赖收集"></p><p>执行完 watcher.evaluate， reversedMessage(watcher) 就被收集到 message 的订阅者集合中了。</p><p>1秒之后，this.message 变成 cipher，那么就会去执行 message.set。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">set</span>: function reactiveSetter (newVal) &#123;<br><span class="hljs-comment">// 省略</span><br>dep.notify();<br>&#125;<br><br>Dep.prototype.notify = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notify</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">// subs 中拥有 reversedMessage</span><br><span class="hljs-keyword">var</span> subs = <span class="hljs-keyword">this</span>.subs.slice();<br><span class="hljs-comment">// 如果不是异步的，那么就要将 watcher 按照初始化的顺序进行排序。</span><br><span class="hljs-keyword">if</span> (!config.async) &#123;<br>subs.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123; <span class="hljs-keyword">return</span> a.id - b.id; &#125;);<br>&#125;<br><span class="hljs-comment">// 遍历订阅者，执行订阅者的更新操作</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;<br>subs[i].update();<br>&#125;<br>&#125;;<br><br>Watcher.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazy) &#123;<br><span class="hljs-keyword">this</span>.dirty = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sync) &#123;<br><span class="hljs-keyword">this</span>.run();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>queueWatcher(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行到 update 内部时你会发现，在最开始将 lazy 设置成了 true，那么这里并不会进入第二分支去执行 watcher.run，也就是说并不会更新 reversedMessage。那问题来了，reversedMessage是怎么更改的呢？在这之前，我们需要了解的一点是，在 mountComponent 中为 vm 声明过一个 watcher，存在全局的 targetStack 中进行维护。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountComponent</span>(<span class="hljs-params">vm, el, hydrating</span>) </span>&#123;<br>updateComponent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>vm._update(vm._render(), hydrating);<br>&#125;;<br><br><span class="hljs-keyword">new</span> Watcher(vm, updateComponent, noop, &#123;<br>before: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">before</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;<br>callHook(vm, <span class="hljs-string">'beforeUpdate'</span>);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 了解了这个后，再回到上面的 computedGetter，在 watcher.evaluate 执行完之后，紧接着执行下面这一段：</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (Dep.target) &#123;<br>watcher.depend();<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意 watcher.depend 和 dep.depend 执行的逻辑是不同的，前者是将 deps 集合中依次执行 depend，而 dep.depend 是执行单个。此时的 Dep.target 就是 vm(这是watcher)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Watcher.prototype.depend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depend</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> i = <span class="hljs-keyword">this</span>.deps.length;<br><span class="hljs-keyword">while</span> (i--) &#123;<br><span class="hljs-keyword">this</span>.deps[i].depend();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>reversedMessage.deps 里存放的就是收集它自身的 dep，也就是 message 的监听收集器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Dep.prototype.depend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depend</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (Dep.target) &#123;<br>Dep.target.addDep(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>将 vm 存入 message 的 dep.subs 中，此时，dep.subs = [reversedMessage, vm]。到这里初始化操作结束了，页面显示为 Computed reversed message: “olleH”。1秒之后进行 message 的更改操作，重新执行 notify 方法，依旧会在 update 这里终止，不会去执行更新 reversedMessage… 这不是又重走老路子而且还是走不通的？并不是的，这次跟上次不同了，这次 dep.subs 中新增了一个 vm 的 watcher，所以执行完 reversedMessage 的 update，接着会执行 vm 的 update 方法。</p><p>因为 vm.lazy 和 vm.sync 都是 false，所以会走第三分支，执行 queueWatcher(this)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> queue = [];<br><span class="hljs-keyword">var</span> waiting = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> has = &#123;&#125;;<br><span class="hljs-keyword">var</span> flushing = <span class="hljs-literal">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueWatcher</span> (<span class="hljs-params">watcher</span>) </span>&#123;<br><span class="hljs-keyword">var</span> id = watcher.id;<br><span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) &#123;<br>has[id] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (!flushing) &#123;<br>queue.push(watcher);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// if already flushing, splice the watcher based on its id</span><br><span class="hljs-comment">// if already past its id, it will be run next immediately.</span><br><span class="hljs-keyword">var</span> i = queue.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;<br>i--;<br>&#125;<br>queue.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher);<br>&#125;<br><span class="hljs-comment">// queue the flush</span><br><span class="hljs-keyword">if</span> (!waiting) &#123;<br>waiting = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span> (!config.async) &#123;<br>flushSchedulerQueue();<br><span class="hljs-keyword">return</span><br>&#125;<br>nextTick(flushSchedulerQueue);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>flush 默认为 false，将 vm 添加到 queue 中，执行 nextTick(flushSchedulerQueue)，先来看看 nextTick 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> pending = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> callbacks = [];<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">nextTick</span> (<span class="hljs-params">cb, ctx</span>) </span>&#123;<br><span class="hljs-keyword">var</span> _resolve;<br>callbacks.push(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (cb) &#123;<br><span class="hljs-keyword">try</span> &#123;<br>cb.call(ctx);<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>handleError(e, ctx, <span class="hljs-string">'nextTick'</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_resolve) &#123;<br>_resolve(ctx);<br>&#125;<br>&#125;);<br><span class="hljs-keyword">if</span> (!pending) &#123;<br>pending = <span class="hljs-literal">true</span>;<br>timerFunc();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 flushSchedulerQueue 包装在方法内，存入 callbacks 中，然后去执行 timerFunc()，timerFunc 有如下几种情况：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(<span class="hljs-built_in">Promise</span>)) &#123;<br><span class="hljs-keyword">var</span> p = <span class="hljs-built_in">Promise</span>.resolve();<br>timerFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>p.then(flushCallbacks);<br><span class="hljs-keyword">if</span> (isIOS) &#123; setTimeout(noop); &#125;<br>&#125;;<br>isUsingMicroTask = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">'undefined'</span> &amp;&amp; (<br>isNative(MutationObserver) ||<br>MutationObserver.toString() === <span class="hljs-string">'[object MutationObserverConstructor]'</span><br>)) &#123;<br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks);<br><span class="hljs-keyword">var</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-built_in">String</span>(counter));<br>observer.observe(textNode, &#123;<br>characterData: <span class="hljs-literal">true</span><br>&#125;);<br>timerFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span>;<br>textNode.data = <span class="hljs-built_in">String</span>(counter);<br>&#125;;<br>isUsingMicroTask = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">'undefined'</span> &amp;&amp; isNative(setImmediate)) &#123;<br>timerFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>setImmediate(flushCallbacks);<br>&#125;;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>timerFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>setTimeout(flushCallbacks, <span class="hljs-number">0</span>);<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是将 flushCallbacks 作为各种方法的回调函数，而官方的意思是考虑到各平台的差异以及会造成的 bug，按照优先级来说，微任务 &gt; 宏任务，优先使用 promise，最差情况使用 setTimeout。概括来说，就是将一个方法延迟执行。其实 $nextTick 内部就是执行的 nextTick 方法，因此我们可以使用 $nextTick 去延迟执行一个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushCallbacks</span> (<span class="hljs-params"></span>) </span>&#123;<br>pending = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> copies = callbacks.slice(<span class="hljs-number">0</span>);<br>callbacks.length = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; copies.length; i++) &#123;<br>copies[i]();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>flushCallbacks 依次执行 callbacks 集合里的方法，当它执行时就会执行 flushSchedulerQueue 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSchedulerQueue</span> (<span class="hljs-params"></span>) </span>&#123;<br>currentFlushTimestamp = getNow();<br>flushing = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">var</span> watcher, id;<br><br>queue.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123; <span class="hljs-keyword">return</span> a.id - b.id; &#125;);<br><br><span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.length; index++) &#123;<br>watcher = queue[index];<br><span class="hljs-keyword">if</span> (watcher.before) &#123;<br>watcher.before();<br>&#125;<br>id = watcher.id;<br>has[id] = <span class="hljs-literal">null</span>;<br>watcher.run();<br><span class="hljs-comment">// in dev build, check and stop circular updates.</span><br><span class="hljs-keyword">if</span> (has[id] != <span class="hljs-literal">null</span>) &#123;<br>circular[id] = (circular[id] || <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br><span class="hljs-keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;<br>warn(<br><span class="hljs-string">'You may have an infinite update loop '</span> + (<br>watcher.user<br>? (<span class="hljs-string">"in watcher with expression \""</span> + (watcher.expression) + <span class="hljs-string">"\""</span>)<br>: <span class="hljs-string">"in a component render function."</span><br>),<br>watcher.vm<br>);<br><span class="hljs-keyword">break</span><br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> activatedQueue = activatedChildren.slice();<br><span class="hljs-keyword">var</span> updatedQueue = queue.slice();<br><br>resetSchedulerState();<br><br>callActivatedHooks(activatedQueue);<br>callUpdatedHooks(updatedQueue);<br><br><span class="hljs-keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;<br>devtools.emit(<span class="hljs-string">'flush'</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    简单说下流程：</p><ul><li>首先要对 queue 里的 watcher 进行排序。原因有三点：<ol><li>父组件必须要优先与子组件更新（父组件比子组件先创建）</li><li>watcher 分为 user watcher 和 render watcher，user watcher 必须优先与 render watcher（user watcher 比 render watcher 先创建）</li><li>排序后，如果子组件在父组件 watcher 执行过程中被销毁了，就会跳过子组件的 watcher 执行。</li></ol></li><li>遍历 queue，如果 watcher.before 存在，优先执行，比如说 beforeUpdate 钩子函数就是在 vm render watcher.before 中执行的；然后执行 watcher.run()</li><li>执行 activated 和 updated 钩子。</li><li>开发模式下触发 devtools flush 事件</li></ul><p>watcher.run：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">Watcher.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.active) &#123;<br><span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.get();<br><span class="hljs-keyword">if</span> (<br>value !== <span class="hljs-keyword">this</span>.value ||<br>isObject(value) ||<br><span class="hljs-keyword">this</span>.deep<br>) &#123;<br><span class="hljs-comment">// set new value</span><br><span class="hljs-keyword">var</span> oldValue = <span class="hljs-keyword">this</span>.value;<br><span class="hljs-keyword">this</span>.value = value;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.user) &#123;<br><span class="hljs-keyword">var</span> info = <span class="hljs-string">"callback for watcher \""</span> + (<span class="hljs-keyword">this</span>.expression) + <span class="hljs-string">"\""</span>;<br>invokeWithErrorHandling(<span class="hljs-keyword">this</span>.cb, <span class="hljs-keyword">this</span>.vm, [value, oldValue], <span class="hljs-keyword">this</span>.vm, info);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.cb.call(<span class="hljs-keyword">this</span>.vm, value, oldValue);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>首先执行 this.get()，触发 this.getter 方法执行，getter 就是 updateComponent，也就是说会重新走 render -&gt; update 过程。而就是在 render 过程里，会重新走 message 的依赖收集过程，执行 this.reversedMessage() 更新 reversedMessage 的值。</p><p>然后依据条件执行下方逻辑，执行的条件可以是三种种的一种：</p><ol><li>新值与旧值不相等</li><li>value 是对象，因为有可能新值与旧值相等，但是值可能被更新过</li><li>watcher.deep = true</li></ol><p>因为当前的 watcher 是 vm，并且是 render watcher，所以新值和旧值都是 ‘undefined’、watcehr.deep = false，因此不会执行下面的逻辑。</p><p>vnode 的所有 props、directives、events 等都存储在 data 中，那么这个 invokeCreateHooks 就是给我们的 dom 润色。</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/computed%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" srcset="/img/loading.gif" lazyload alt="computed执行流程图"></p><h3 id="为什么-computed-拥有缓存功能"><a href="#为什么-computed-拥有缓存功能" class="headerlink" title="为什么 computed 拥有缓存功能"></a>为什么 computed 拥有缓存功能</h3><p>这个问题其实跟 “如果依赖项不是响应式的，即使改变，computed 为什么不会重新求值” 这个是一样的。</p><p>我在 demo 中增加一个使用 reversedMessage 的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;p&gt;Computed reversed message: <span class="hljs-string">"&#123;&#123; reversedMessage &#125;&#125;"</span>&lt;<span class="hljs-regexp">/p&gt;</span><br><span class="hljs-regexp">&lt;p&gt;multiple message: "&#123;&#123; reversedMessage &#125;&#125;"&lt;/</span>p&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Watcher.prototype.evaluate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.get();<br><span class="hljs-keyword">this</span>.dirty = <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 computedGetter 中，只有 this.dirty = true，才会去执行 watcher.evaluate()，也就是去计算 reversedMessage 的值。当第一次使用 reversedMessage 时，当前的 dirty = true，去计算拿到值赋值给 watcher.value，计算完成之后将 dirty 置为 false；第二次使用时就不会去执行 evaluate，拿到的就是第一次计算的值。这样就实现了缓存的功能。</p><h3 id="如果没有在模板中使用，即使依赖项发生改变，computed-也不会再次执行"><a href="#如果没有在模板中使用，即使依赖项发生改变，computed-也不会再次执行" class="headerlink" title="如果没有在模板中使用，即使依赖项发生改变，computed 也不会再次执行"></a>如果没有在模板中使用，即使依赖项发生改变，computed 也不会再次执行</h3><p>修改 demo 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">mounted () &#123;<br><span class="hljs-keyword">this</span>.reversedMessage;<br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><span class="hljs-keyword">this</span>.message = <span class="hljs-string">'cipher'</span><br>&#125;, <span class="hljs-number">1000</span>)<br>&#125;,<br>computed:&#123;<br>reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'改变 reversedMessage 的值'</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这一次在 mounted 钩子中不带() 使用，会触发 reversedMessage 方法执行，但是1秒之后 message 更改了，但是 reversedMessage 却没有执行。</p><p>我们看上面 computed 执行流程图，_render() 执行会触发 _s(this.reverseMessage)，进而触发计算，调用方法，但是现在我没有在模板中使用，那么在 render 函数中就不会有 _s(this.reverseMessage)，也就不会有后续的计算操作了，因此 computed 方法不会执行。但是为什么在 mounted 中使用 this.reversedMessage() 会报错，而使用 this.reversedMessage 却可以正常使用？</p><p>this.reversedMessage 触发 reversedMessage 的 getter，跟上面提到的执行步骤是一样的，所以会执行 reversedMessage 方法。也就是说 this.reversedMessage() 相当于是 this.reversedMessage()()，this.reversedMessage() 执行完后的值不是方法，所以后面接() 就会报错。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>computed 在日常使用中，产生的诸多疑惑降低了使用它的快感，所以本文依据这些问题从源码的角度去寻求答案，了解设计背后的秘密。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>模板怎么变成真实DOM</title>
    <link href="/2021/04/19/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%A8%A1%E6%9D%BF%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E7%9C%9F%E5%AE%9EDOM/"/>
    <url>/2021/04/19/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%A8%A1%E6%9D%BF%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E7%9C%9F%E5%AE%9EDOM/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>官方文档有过这样一段描述：</p><blockquote><p>Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统</p></blockquote><p>其实 Vue 模板语法与 ejs 等模板语言类似，基本思想就是： template + data = dom。那 Vue 是如何来将模板语法结合数据转译成真实 Dom 呢？本章将会来探究这个秘密。</p><p>了解过编译和转译的应该知道，它们大致都会经历 parse、transform、generate 三个步骤。不同的是，编译通常来说是高级语言向低级语言的变换，而转译则只是语法层面的转换，Vue 的模板向 DOM 的变化就是转译。除了上述三个步骤之外，最后 DOM 的生成还需要 patch 操作。</p><p>开始之前，有必要梳理一下转译过程涉及到的一些重要方法（如下所示）调用及它们之间的关系，做到心中有数，将关注点放在转译步骤上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$mount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">template, options</span>) </span>&#123;&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span> (<span class="hljs-params">ast,options</span>) </span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCompilerCreator</span>(<span class="hljs-params">baseCompile</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCompiler</span> (<span class="hljs-params">baseOptions</span>) </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compile</span>(<span class="hljs-params">template, options</span>) </span>&#123;<br><span class="hljs-keyword">var</span> compiled = baseCompile(template.trim(), finalOptions);<br><span class="hljs-keyword">return</span> compiled<br>&#125;;<br><span class="hljs-keyword">return</span> &#123;<br>compile: compile,<br>compileToFunctions: createCompileToFunctionFn(compile)<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCompileToFunctionFn</span> (<span class="hljs-params">compile</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">compileToFunctions</span> (<span class="hljs-params">template, options, vm</span>) </span>&#123;<br><span class="hljs-keyword">var</span> compiled = compile(template, options);<br>res.render = createFunction(compiled.render, fnGenErrors);<br><span class="hljs-keyword">return</span> res;<br>&#125;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">baseCompile</span>(<span class="hljs-params">template, options</span>) </span>&#123;<br><span class="hljs-keyword">var</span> ast = parse(template.trim(), options);<br><span class="hljs-keyword">return</span> &#123;<br>ast: ast,<br>render: code.render,<br>staticRenderFns: code.staticRenderFns<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>大致的执行顺序及关系是：</p><ol><li>var createCompiler = createCompilerCreator(baseCompile)</li><li>var ref$1 = createCompiler(baseOptions);</li><li>var compileToFunctions = ref$1.compileToFunctions</li><li>$mount();</li><li>var ref = compileToFunctions(template, options)</li><li>var compiled = compile(template, options)</li><li>compiled = baseCompile(template.trim(), finalOptions)</li><li>compiled.ast = parse(template.trim(), options)</li><li>compiled.render = generate(ast, options).render</li><li>ref.render = createFunction(compiled.render, fnGenErrors)</li><li>Vue.$options.render = ref.render</li><li>mount.call(this, el, hydrating)</li></ol><h2 id="转译步骤"><a href="#转译步骤" class="headerlink" title="转译步骤"></a>转译步骤</h2><h3 id="parse"><a href="#parse" class="headerlink" title="parse"></a>parse</h3><p>这一步将 template 作为字符串进行特定规则分析转换成 AST。</p><p>从上面的梳理结果可以看到，真正的 parse 动作从 parse(template.trim(), options) 开始，所以我们从这里开始。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span>(<span class="hljs-params">template, options</span>) </span>&#123;<br><span class="hljs-comment">// 省略代码...</span><br><span class="hljs-keyword">var</span> stack = [];<br><span class="hljs-keyword">var</span> preserveWhitespace = options.preserveWhitespace !== <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> whitespaceOption = options.whitespace;<br><span class="hljs-comment">// root 就是最后的 AST 结果</span><br><span class="hljs-keyword">var</span> root;<br><span class="hljs-keyword">var</span> currentParent;<br><span class="hljs-keyword">var</span> inVPre = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> inPre = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">var</span> warned = <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 省略代码...</span><br>parseHTML(template, &#123;&#125;)<br>&#125;;<br></code></pre></td></tr></table></figure><p>核心是 parseHTML 方法，简单来说就是通过 while 循环，依据标签作为分隔标识将 template 分隔成多个子字符串进行处理。</p><p>因为 template 也是标签，所以选择标签为单位进行对应的 parse 操作；而分隔之后的字符串结构如下图所示，大家一定觉得很眼熟，对，就是多叉树，这个循环过程实际上就是按深度优先原则对多叉树的遍历。</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/templateTree.png" srcset="/img/loading.gif" lazyload alt="templateTree"></p><p>每一个节点就是一个标签、文本字符、空格或者是注释，parseHTML 接受两个参数：template、options，其中 options 拥有 start、end、chars、comment 方法，分别用来处理开始标签、结束标签、文本字符、注释。接下来大致说下整个流程</p><p>首先在循环体内部有两大分支，第一大分支处理正常情况（除了 script、style、textarea 标签），第二个分支就是处理特殊情况，我们先看正常情况的处理操作。</p><ul><li>在当前给定的字符串中查找第一个 ‘&lt;’ 的下标<ul><li>如果下标是 0，处理方式如下：<ul><li>普通注释, ‘–&gt;’ 结尾，如果 options.shouldKeepComment 为 true，则需要保留注释。调用 advance(length)</li><li>特殊注释，’]&gt;’ 结尾，调用 advance(length)</li><li>DOCTYPE 标识，调用 advance(length)</li><li>结束标签，调用 advance(length)，parseEndTag 处理结束标签</li><li>开始标签，handleStartTag 处理开始标签</li></ul></li></ul></li></ul><blockquote><p>advance(length) 的作用就是以 length 为开始点截取 html 剩余部分。</p></blockquote><p>重点看看 handleStartTag 和 parseEndTag。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> startTagMatch = parseStartTag();<br><span class="hljs-keyword">if</span> (startTagMatch) &#123;<br>handleStartTag(startTagMatch);<br>&#125;<br></code></pre></td></tr></table></figure><p>parseStartTag() 方法返回一个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> match = &#123;<br><span class="hljs-comment">// 一个二维数组，内部每一个数组保存开始标签上的一个属性</span><br><span class="hljs-comment">// 内数组形如 [" id=\"demo\"", "id", "=", "demo", start: 4, end: 14]</span><br><span class="hljs-comment">// start 为属性开始下标，end 为属性结束下标</span><br>attrs: <span class="hljs-built_in">Array</span>,<br><span class="hljs-comment">// 标签结束下标</span><br>end: <span class="hljs-built_in">Number</span>,<br><span class="hljs-comment">// 标签开始下标</span><br>start: <span class="hljs-built_in">Number</span>,<br><span class="hljs-comment">// 标签名称</span><br>tagName: <span class="hljs-built_in">String</span>,<br><span class="hljs-comment">// 单标签斜线</span><br>unarySlash: <span class="hljs-built_in">String</span><br>&#125;<br></code></pre></td></tr></table></figure><p>弄清楚了 match 的内容，就可以继续去看看 handleStartTag 方法了。我们主要看后半部分的逻辑。</p><p>声明一个与 match.attrs 长度相同的数组 attrs，通过遍历 attrs，创建一个新对象，对每一项做如下处理：</p><ul><li>将属性名赋值给 name 属性，属性值赋值给 value</li><li>match.attrs.start 去除空格后赋值个 start，end 赋值给 end<br>最后的 attrs 表现如下：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">[<br>&#123;<br>name: <span class="hljs-string">"id"</span>,<br>value: <span class="hljs-string">"demo"</span>,<br>start: <span class="hljs-number">5</span>,<br>end: <span class="hljs-number">14</span>,<br>&#125;<br>]<br></code></pre></td></tr></table></figure><p>上面有声明过 unary，它的作用就是判断当前标签是否是单标签，如果不是单标签，那么就将该标签相关信息用对象包裹，存入 stack 中。</p><p>接着，会调用 options.start(tagName, attrs, unary, match.start, match.end), 我们找到 start 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">start: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">start</span> (<span class="hljs-params">tag, attrs, unary, start$<span class="hljs-number">1</span>, end</span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>在源码中可以看到，最开始调用 createASTElement(tag, attrs, currentParent) 创建 element 对象，后面就是对 element 的一些处理:</p><ol><li>添加相关属性、</li><li>处理 v-for, v-if, v-once 指令、</li><li>是否需要将 element 赋值给 root、</li><li>如果不是单标签，将 element 赋值给 currentParent，并且将 element 存入 stack(parse 方法下的 stack)，反之则调用 closeElement 方法结束标签处理操作。</li></ol><p>后面的一些处理细节暂不做探究，主要看看 createASTElement 创建了一个什么样的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createASTElement</span> (<span class="hljs-params">tag, attrs, parent</span>) </span>&#123;<br><span class="hljs-keyword">return</span> &#123;<br>type: <span class="hljs-number">1</span>,<br>tag: tag,<br>attrsList: attrs,<br>attrsMap: makeAttrsMap(attrs),<br>rawAttrsMap: &#123;&#125;,<br>parent: parent,<br>children: []<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法很简单, 就是返回了一个对象，就是 AST 对象。parent 与 父标签建立联系，children 可以用来存储多个子标签或子元素。其中 type 的值是1，也就是说标签的类型都是1，那文本或者其他类型呢？我们在源码中找到 options.chars 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!inVPre &amp;&amp; text !== <span class="hljs-string">' '</span> &amp;&amp; (res = parseText(text, delimiters))) &#123;<br>child = &#123;<br>type: <span class="hljs-number">2</span>,<br>expression: res.expression,<br>tokens: res.tokens,<br>text: text<br>&#125;;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (text !== <span class="hljs-string">' '</span> || !children.length || children[children.length - <span class="hljs-number">1</span>].text !== <span class="hljs-string">' '</span>) &#123;<br>child = &#123;<br>type: <span class="hljs-number">3</span>,<br>text: text<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码表示出了 text 字符串最终有可能转换成 type 为2和3的 AST：<br>type 为2的情况（同时满足）：</p><ul><li>不处于 v-pre 指令标签下</li><li>text !== ‘ ‘</li><li>parseText 是判断 text 是否是插值语法</li></ul><p>type 为3的情况（满足其一即可）：</p><ul><li>text !== ‘ ‘</li><li>父标签没有子元素</li><li>父标签最后一个子元素的值 !== ‘ ‘</li></ul><p>这里需要说的一点是，type 为3的第三个条件，因为一般换行符都会转换成空格符 ‘ ‘, 为了保证只存在一个换行符，才需要在已经存在子元素的情况下检验最后一个子元素是否是换行符。</p><p>通过上面我们知道了 node 元素类型的处理，现在说说模板指令。Vue 模板涉及到各种指令，增加了非常好用的功能，那这里就简单了解一下 v-for, v-if, v-once。这三个指令的处置在 options.start 方法内。<br>开始之前先在 demo 基础上加上一段代码以便调试。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"demo"</span>&gt;<br>&lt;p v-once&gt;测试 v-once&lt;<span class="hljs-regexp">/p&gt;</span><br><span class="hljs-regexp">&lt;div v-for="record in commits" v-if="commits.length &gt; 0"&gt;</span><br><span class="hljs-regexp">&lt;span&gt;&#123;&#123; record.commit.message &#125;&#125;&lt;/</span>span&gt;<br>&lt;<span class="hljs-regexp">/div&gt;</span><br><span class="hljs-regexp">...</span><br><span class="hljs-regexp">&lt;/</span>div&gt;<br></code></pre></td></tr></table></figure><p>先来说说对 v-for 的处理：</p><ul><li>var exp = getAndRemoveAttr(el, ‘v-for’)。从 attrsList 中获取到 v-for 对应的值 ‘record in commits’</li><li>var res = parseFor(exp)。将 record 和 commits 分别存入 alias 和 for， 即{alias: record, for: commits}</li><li>extend(el, res)。将 alias 和 for 属性存入 element 中</li></ul><p>v-if：</p><ul><li>var exp = getAndRemoveAttr(el, ‘v-if’)。从 attrsList 中获取到 v-if 对应的值 ‘commits.length &gt; 0’</li><li>如果 exp 存在<ul><li>为 el 添加 if 属性，值为 exp</li><li>addIfCondition(el, {exp: exp, block: el})。</li></ul></li><li>如果 exp 不存在<ul><li>如果 v-else 存在，为 el 添加 else 属性，值为 true</li><li>var elseif = getAndRemoveAttr(el, ‘v-else-if’)。 如果 elseif 存在，为 el 添加 elseif 属性，值为 elseif</li></ul></li></ul><p>v-once: var once = getAndRemoveAttr(el, ‘v-once’)。 如果 once 存在，为 el 添加 once 属性，值为 true</p><p>也就是说，指令的处理其实是将指令对应的属性添加到 AST 对象中。到这里，parse 转换生成的 AST 雏形已经出来了，root 对象一旦确定，后面的子标签对象都会存入 children，而子标签也会存在 children，因此 AST 就是这样一棵树。</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/AST.png" srcset="/img/loading.gif" lazyload alt="AST"></p><h3 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h3><p>在明白 template 到 AST 的变化步骤之后，就可以继续探索 AST 是如何生成 render 函数方法。<br>其实这一步主要是将 AST 转换成 render str 函数字符串，然后再通过 new Function(render str) 生成函数方法。由于函数字符串的转换涉及到的情况很多，过程非常复杂，因此这里只是解析一个整体的步骤。</p><blockquote><p>compiled.render = generate(ast, options).render</p></blockquote><p>generate 方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> state = <span class="hljs-keyword">new</span> CodegenState(options);<br><span class="hljs-keyword">var</span> code = ast ? (ast.tag === <span class="hljs-string">'script'</span> ? <span class="hljs-string">'null'</span> : genElement(ast, state)) : <span class="hljs-string">'_c("div")'</span>;<br><span class="hljs-keyword">return</span> &#123;<br>render: (<span class="hljs-string">"with(this)&#123;return "</span> + code + <span class="hljs-string">"&#125;"</span>),<br>staticRenderFns: state.staticRenderFns<br>&#125;<br></code></pre></td></tr></table></figure><p>如果不存在 ast， 那么code 就是 ‘_c(“div”)’，如果存在，则需要判断是否标签名是否是 script，如果不是就走 genElement(options, state) 生成，反之，code 就是 ‘null’。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genElement</span> (<span class="hljs-params">el, state</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (el.parent) &#123;<br>el.pre = el.pre || el.parent.pre;<br>&#125;<br><br><span class="hljs-keyword">if</span> (el.staticRoot &amp;&amp; !el.staticProcessed) &#123;<br><span class="hljs-keyword">return</span> genStatic(el, state)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.once &amp;&amp; !el.onceProcessed) &#123;<br><span class="hljs-keyword">return</span> genOnce(el, state)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.for &amp;&amp; !el.forProcessed) &#123;<br><span class="hljs-keyword">return</span> genFor(el, state)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.if &amp;&amp; !el.ifProcessed) &#123;<br><span class="hljs-keyword">return</span> genIf(el, state)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">'template'</span> &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123;<br><span class="hljs-keyword">return</span> genChildren(el, state) || <span class="hljs-string">'void 0'</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">'slot'</span>) &#123;<br><span class="hljs-keyword">return</span> genSlot(el, state)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// component or element</span><br><span class="hljs-keyword">var</span> code;<br><span class="hljs-keyword">if</span> (el.component) &#123;<br>code = genComponent(el.component, el, state);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">var</span> data;<br><span class="hljs-keyword">if</span> (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123;<br>data = genData(el, state);<br>&#125;<br><br><span class="hljs-keyword">var</span> children = el.inlineTemplate ? <span class="hljs-literal">null</span> : genChildren(el, state, <span class="hljs-literal">true</span>);<br>code = <span class="hljs-string">"_c('"</span> + (el.tag) + <span class="hljs-string">"'"</span> + (data ? (<span class="hljs-string">","</span> + data) : <span class="hljs-string">''</span>) + (children ? (<span class="hljs-string">","</span> + children) : <span class="hljs-string">''</span>) + <span class="hljs-string">")"</span>;<br>&#125;<br><span class="hljs-comment">// module transforms</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; state.transforms.length; i++) &#123;<br>code = state.transforms[i](el, code);<br>&#125;<br><span class="hljs-keyword">return</span> code<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>genElement 执行的步骤如下：</p><ul><li>遇到 staticRoot、v-once、v-for、v-if、template 标签、slot 标签，先走对应逻辑</li><li>如果是 component，则生成 component 的 render 字符串</li><li>否则，分两步生成最终的 render 字符串<ul><li>调用 genData，处理 element 的各种属性：key、ref、pre、component、attrs、props、events、nativeEvents、slots、model，staticClass、staticStyle，返回属性字符串，形如：”{attrs:{“id”:”demo”}}”</li><li>调用 genChildren 生成 children 的 render 字符串</li><li>code = “_c(‘“ + (el.tag) + “‘“ + (data ? (“,” + data) : ‘’) + (children ? (“,” + children) : ‘’) + “)”; 将 data 与 children 进行拼装</li></ul></li><li>module transform</li></ul><p>涉及到的主要方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genNode</span> (<span class="hljs-params">node, state</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> genElement(node, state)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.type === <span class="hljs-number">3</span> &amp;&amp; node.isComment) &#123;<br><span class="hljs-keyword">return</span> genComment(node)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> genText(node)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genChildren</span> (<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">var</span> gen = altGenNode || genNode;<br><span class="hljs-keyword">return</span> (<span class="hljs-string">"["</span> + (children.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) </span>&#123; <span class="hljs-keyword">return</span> gen(c, state); &#125;).join(<span class="hljs-string">','</span>)) + <span class="hljs-string">"]"</span> + (normalizationType$<span class="hljs-number">1</span> ? (<span class="hljs-string">","</span> + normalizationType$<span class="hljs-number">1</span>) : <span class="hljs-string">''</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>也就是说，在生成 render 字符串时，children 需要用中括号包裹起来，在内部进行遍历，使用 genNode 处理每一项，也就是对不同类型采用不同的处理方法，其中文本和注释的处理很简单，而标签类型依然会重新走 genElement 方法。通过这种递归方式，从上到下调用，从下至上将所有的 AST 对象采取不同的处理，最终会生成如下 render 字符串：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">"with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('p',[_v(_s(currentBranch))]),_v(\" \"),_m(0),_v(\" \"),_l((commits),function(record)&#123;return (commits.length &gt; 0)?_c('div',[_c('span',[_v(_s(record.commit.message))])]):_e()&#125;),_v(\" \"),_c('h1',[_v(\"Latest Vue.js Commits\")]),_v(\" \"),_l((branches),function(branch)&#123;return [_c('input',&#123;directives:[&#123;name:\"model\",rawName:\"v-model\",value:(currentBranch),expression:\"currentBranch\"&#125;],attrs:&#123;\"type\":\"radio\",\"id\":branch,\"name\":\"branch\"&#125;,domProps:&#123;\"value\":branch,\"checked\":_q(currentBranch,branch)&#125;,on:&#123;\"change\":function($event)&#123;currentBranch=branch&#125;&#125;&#125;),_v(\" \"),_c('label',&#123;attrs:&#123;\"for\":branch&#125;&#125;,[_v(_s(branch))])]&#125;),_v(\" \"),_c('p',[_v(\"vuejs/vue@\"+_s(currentBranch))]),_v(\" \"),_c('ul',_l((commits),function(record)&#123;return _c('li',[_c('a',&#123;staticClass:\"commit\",attrs:&#123;\"href\":record.html_url,\"target\":\"_blank\"&#125;&#125;,[_v(_s(record.sha.slice(0, 7)))]),_v(\"\\n        - \"),_c('span',&#123;staticClass:\"message\"&#125;,[_v(_s(_f(\"truncate\")(record.commit.message)))]),_c('br'),_v(\"\\n        by \"),_c('span',&#123;staticClass:\"author\"&#125;,[_c('a',&#123;attrs:&#123;\"href\":record.author.html_url,\"target\":\"_blank\"&#125;&#125;,[_v(_s(record.commit.author.name))])]),_v(\"\\n        at \"),_c('span',&#123;staticClass:\"date\"&#125;,[_v(_s(_f(\"formatDate\")(record.commit.author.date)))])])&#125;),0)],2)&#125;"</span><br></code></pre></td></tr></table></figure><p>字符串中存在的 _c、_v、_s、_f，是创建不同 vnode 的方法，可以在源码中找到，在 renderMixin 中调用了 installRenderHelpers(Vue.prototype)，所以这些方法挂载在了 Vue 上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._c = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d</span>) </span>&#123; <span class="hljs-keyword">return</span> createElement(vm, a, b, c, d, <span class="hljs-literal">false</span>); &#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">installRenderHelpers</span> (<span class="hljs-params">target</span>) </span>&#123;<br>target._o = markOnce;<br>target._n = toNumber;<br>target._s = toString;<br>target._l = renderList;<br>target._t = renderSlot;<br>target._q = looseEqual;<br>target._i = looseIndexOf;<br>target._m = renderStatic;<br>target._f = resolveFilter;<br>target._k = checkKeyCodes;<br>target._b = bindObjectProps;<br>target._v = createTextVNode;<br>target._e = createEmptyVNode;<br>target._u = resolveScopedSlots;<br>target._g = bindObjectListeners;<br>target._d = bindDynamicKeys;<br>target._p = prependModifier;<br>&#125;<br></code></pre></td></tr></table></figure><p>待所有 AST 处理完成后，render 字符串就生成了, 使用 createFunction(compiled.render, fnGenErrors)，也就是执行 new Function(compiled.render) 将字符串转换成匿名函数，然后将 render 函数赋值给 Vue.$options.render, 这样就完成了 render 函数的创建及挂载工作。</p><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><p>上一步我们拿到了 render 函数，那这一步就是了解如何使用这个函数。前言罗列的最后一步是调用 mount 方法，最终指向 mountComponent 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mountComponent</span>(<span class="hljs-params">vm, el, hydrating</span>) </span>&#123;<br>updateComponent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>vm._update(vm._render(), hydrating);<br>&#125;;<br><br><span class="hljs-keyword">new</span> Watcher(vm, updateComponent, noop, &#123;<br>before: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">before</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123;<br>callHook(vm, <span class="hljs-string">'beforeUpdate'</span>);<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* isRenderWatcher */</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>将 updateComponent 设定为订阅者的 getter，而 vm 在前置操作时已经绑定了响应式属性，每次 vm 发生改变就会执行 updateComponent 获取最新的值。并且在初始时就调用 updateCompoennt，触发页面第一次渲染更新。这里需要注意的是，订阅者的 cb 是 noop，因为只执行 updateComponent 就能实现页面的更新（后面会讲到），因此不需要额外的回调函数。</p><p>vm._update 方法接受的第一个参是 vnode，也就是说 vm._render() 返回的是一个 vnode，找到 _render 方法，关键的就是三行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ref = vm.$options;<br><span class="hljs-keyword">var</span> render = ref.render;<br>vnode = render.call(vm._renderProxy, vm.$createElement);<br></code></pre></td></tr></table></figure><p>这里的 render 方法就是上面说到的匿名函数，美化后如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">anonymous</span>(<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">with</span>(<span class="hljs-keyword">this</span>) &#123;<br><span class="hljs-keyword">return</span> _c(<span class="hljs-string">'div'</span>, &#123;<br>attrs: &#123;<br><span class="hljs-string">"id"</span>: <span class="hljs-string">"demo"</span><br>&#125;<br>&#125;, [_c(<span class="hljs-string">'p'</span>, [_v(_s(currentBranch))]), _v(<span class="hljs-string">" "</span>), _m(<span class="hljs-number">0</span>), _v(<span class="hljs-string">" "</span>), _l((commits), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">record</span>) </span>&#123;<br><span class="hljs-keyword">return</span> (commits.length &gt; <span class="hljs-number">0</span>) ? _c(<span class="hljs-string">'div'</span>, [_c(<span class="hljs-string">'span'</span>, [_v(_s(record.commit.message))])]) : _e()<br>&#125;), _v(<span class="hljs-string">" "</span>), _c(<span class="hljs-string">'h1'</span>, [_v(<span class="hljs-string">"Latest Vue.js Commits"</span>)]), _v(<span class="hljs-string">" "</span>), _l((branches), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">branch</span>) </span>&#123;<br><span class="hljs-keyword">return</span> [_c(<span class="hljs-string">'input'</span>, &#123;<br>directives: [&#123;<br>name: <span class="hljs-string">"model"</span>,<br>rawName: <span class="hljs-string">"v-model"</span>,<br>value: (currentBranch),<br>expression: <span class="hljs-string">"currentBranch"</span><br>&#125;],<br>attrs: &#123;<br><span class="hljs-string">"type"</span>: <span class="hljs-string">"radio"</span>,<br><span class="hljs-string">"id"</span>: branch,<br><span class="hljs-string">"name"</span>: <span class="hljs-string">"branch"</span><br>&#125;,<br>domProps: &#123;<br><span class="hljs-string">"value"</span>: branch,<br><span class="hljs-string">"checked"</span>: _q(currentBranch, branch)<br>&#125;,<br>on: &#123;<br><span class="hljs-string">"change"</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">$event</span>) </span>&#123;<br>currentBranch = branch<br>&#125;<br>&#125;<br>&#125;), _v(<span class="hljs-string">" "</span>), _c(<span class="hljs-string">'label'</span>, &#123;<br>attrs: &#123;<br><span class="hljs-string">"for"</span>: branch<br>&#125;<br>&#125;, [_v(_s(branch))])]<br>&#125;), _v(<span class="hljs-string">" "</span>), _c(<span class="hljs-string">'p'</span>, [_v(<span class="hljs-string">"vuejs/vue@"</span> + _s(currentBranch))]), _v(<span class="hljs-string">" "</span>), _c(<span class="hljs-string">'ul'</span>, _l((commits), <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">record</span>) </span>&#123;<br><span class="hljs-keyword">return</span> _c(<span class="hljs-string">'li'</span>, [_c(<span class="hljs-string">'a'</span>, &#123;<br>staticClass: <span class="hljs-string">"commit"</span>,<br>attrs: &#123;<br><span class="hljs-string">"href"</span>: record.html_url,<br><span class="hljs-string">"target"</span>: <span class="hljs-string">"_blank"</span><br>&#125;<br>&#125;, [_v(_s(record.sha.slice(<span class="hljs-number">0</span>, <span class="hljs-number">7</span>)))]), _v(<span class="hljs-string">"\n        - "</span>), _c(<span class="hljs-string">'span'</span>, &#123;<br>staticClass: <span class="hljs-string">"message"</span><br>&#125;, [_v(_s(_f(<span class="hljs-string">"truncate"</span>)(record.commit.message)))]), _c(<span class="hljs-string">'br'</span>), _v(<span class="hljs-string">"\n        by "</span>), _c(<span class="hljs-string">'span'</span>, &#123;<br>staticClass: <span class="hljs-string">"author"</span><br>&#125;, [_c(<span class="hljs-string">'a'</span>, &#123;<br>attrs: &#123;<br><span class="hljs-string">"href"</span>: record.author.html_url,<br><span class="hljs-string">"target"</span>: <span class="hljs-string">"_blank"</span><br>&#125;<br>&#125;, [_v(_s(record.commit.author.name))])]), _v(<span class="hljs-string">"\n        at "</span>), _c(<span class="hljs-string">'span'</span>, &#123;<br>staticClass: <span class="hljs-string">"date"</span><br>&#125;, [_v(_s(_f(<span class="hljs-string">"formatDate"</span>)(record.commit.author.date)))])])<br>&#125;), <span class="hljs-number">0</span>)], <span class="hljs-number">2</span>)<br>&#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>render 方法执行的方式是从下至上，下层执行的结果就是上一层的 children</p><p>目前涉及到的几种处置场景如下：</p><ul><li>标签，调用 _c，传入标签名、属性、子元素</li><li>文本，调用 _v，对涉及到使用变量的部分则需要在内部额外调用 _s 进行处理</li><li>v-for，调用 _l，传入需遍历的数组、遍历时执行的方法</li><li>v-once，调用 _m</li><li>v-if 相反情况，调用 _e</li><li>过滤标识 |，调用 _f</li></ul><p>执行完毕最终会生成这样一个嵌套的对象：</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/vnode.png" srcset="/img/loading.gif" lazyload alt="vnode"></p><p>但是有一点需要注意的是，初始时如果不满足条件的不会创建成 vnode，比如，v-if=”commits.length &gt; 0” 才会显示的 div，则没有生成对应的 vnode 存入 父元素的 children 中。</p><h3 id="patch"><a href="#patch" class="headerlink" title="patch"></a>patch</h3><p>vnode 创建完成后，就可以执行 _update 方法了，实际上就是执行 patch 操作，只是初始渲染时不需比较操作，因此初始渲染和后续更新传入的参不一样。在浏览器端就是调用 createPatchFunction({ nodeOps: nodeOps, modules: modules }) 创建的，接下来看看 patch 的魔力吧。注意一点，我们这里只是探究 vnode 是如何变成 dom，不是探究 patch 过程，这两个目的的重心不一样 :)。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype._update = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">vnode, hydrating</span>) </span>&#123;<br><span class="hljs-comment">// initial render</span><br>vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="hljs-literal">false</span> <span class="hljs-comment">/* removeOnly */</span>);<br>&#125;<br><span class="hljs-comment">// patch</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">patch</span> (<span class="hljs-params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;<br><span class="hljs-comment">// 省略</span><br><span class="hljs-keyword">var</span> isRealElement = isDef(oldVnode.nodeType);<br><span class="hljs-keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123;<br><span class="hljs-comment">// patch existing root node</span><br>patchVnode(oldVnode, vnode, insertedVnodeQueue, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, removeOnly);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// initrender</span><br><span class="hljs-keyword">if</span> (isRealElement) &#123;<br><span class="hljs-comment">// 省略</span><br>oldVnode = emptyNodeAt(oldVnode);<br>&#125;<br><br><span class="hljs-comment">// replacing existing element</span><br><span class="hljs-keyword">var</span> oldElm = oldVnode.elm;<br><span class="hljs-keyword">var</span> parentElm = nodeOps.parentNode(oldElm);<br><br><span class="hljs-comment">// create new node</span><br>createElm(<br>vnode,<br>insertedVnodeQueue,<br><span class="hljs-comment">// extremely rare edge case: do not insert if old element is in a</span><br><span class="hljs-comment">// leaving transition. Only happens when combining transition +</span><br><span class="hljs-comment">// keep-alive + HOCs. (#4590)</span><br>oldElm._leaveCb ? <span class="hljs-literal">null</span> : parentElm,<br>nodeOps.nextSibling(oldElm)<br>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>很清晰的逻辑，我们传入的是 vm.$el，所以走第二个分支，依据 $el 创建一个空 vnode。紧接着是声明 oldElm 和 parentElm，分别是 #demo 和 body，用作后面方法的入参部分。最后就开始执行创建 elment 步骤了。</p><p>createElm 方法里主要是分成三类进行创建，对于标签，使用 createElement，另外还会使用 createChildren 创建子元素对应的 dom，注释使用 createComment，其他的使用 createTextNode。创建结束后执行 insert(parentElm, vnode.elm, refElm), 将创建的 dom 插入到指定的位置。</p><p>createElement 其实就是调用 document.createElement(tagName)，createComment 是 document.createComment(text)，同样的，createTextNode 是调用 document.createTextNode(text)。那子元素是怎么创建的呢？我们主要来看看 createChildren 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createChildren</span> (<span class="hljs-params">vnode, children, insertedVnodeQueue</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(children)) &#123;<br>&#123;<br>checkDuplicateKeys(children);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; children.length; ++i) &#123;<br>createElm(children[i], insertedVnodeQueue, vnode.elm, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, children, i);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (isPrimitive(vnode.text)) &#123;<br>nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(<span class="hljs-built_in">String</span>(vnode.text)));<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果包含多个 child，在检查 children 是否存在重复 key 之后，就会遍历 children，调用 createElm 处理每一个子元素；如果 text 是原生属性，则创建完 textNode 之后，直接 append 到当前位置。</p><p>有没有发现，上面说到的只是调用原生创建 dom 的方法，而通过标签生成的 dom 没有我们所赋予的各种属性、指令信息，这样的 dom 是没有灵魂的。所以必须还有一个添加灵魂的步骤。在插入之前有这样的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (isDef(data)) &#123;<br>invokeCreateHooks(vnode, insertedVnodeQueue);<br>&#125;<br></code></pre></td></tr></table></figure><p>vnode 的所有 props、directives、events 等都存储在 data 中，那么这个 invokeCreateHooks 就是给我们的 dom 润色。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeCreateHooks</span> (<span class="hljs-params">vnode, insertedVnodeQueue</span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cbs.create.length; ++i) &#123;<br>cbs.create[i](emptyNode, vnode);<br>&#125;<br>i = vnode.data.hook; <span class="hljs-comment">// Reuse variable</span><br><span class="hljs-keyword">if</span> (isDef(i)) &#123;<br><span class="hljs-keyword">if</span> (isDef(i.create)) &#123; i.create(emptyNode, vnode); &#125;<br><span class="hljs-keyword">if</span> (isDef(i.insert)) &#123; insertedVnodeQueue.push(vnode); &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>咋一看是不是觉得摸不着头脑，完全不知道在干什么。关键点是需要弄清楚 cbs.create 是个什么东西。上面说过，我们调用的 patch 方法是通过 createPatchFunction(backend) 方法创建的，这个方法除了返回 patch 和 其他一些方法外，还有对 cbs 做了处理，我将 backend.modules 相关属性整理如下，方便查看：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这里只是注明每一个属性它所拥有的方法，方便下面 modules 数组查看</span><br><span class="hljs-keyword">var</span> modules = &#123;<br>attrs: &#123;<br>create: updateAttrs,<br>update: updateAttrs<br>&#125;,<br>klass: &#123;<br>create: updateClass,<br>update: updateClass<br>&#125;,<br>events: &#123;<br>create: updateDOMListeners,<br>update: updateDOMListeners<br>&#125;,<br>domProps: &#123;<br>create: updateDOMProps,<br>update: updateDOMProps<br>&#125;,<br>style: &#123;<br>create: updateStyle,<br>update: updateStyle<br>&#125;,<br>transition: inBrowser ? &#123;<br>create: _enter,<br>activate: _enter,<br>remove: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove$$1</span> (<span class="hljs-params">vnode, rm</span>) </span>&#123;<br><span class="hljs-comment">/* istanbul ignore else */</span><br><span class="hljs-keyword">if</span> (vnode.data.show !== <span class="hljs-literal">true</span>) &#123;<br>leave(vnode, rm);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>rm();<br>&#125;<br>&#125;<br>&#125; : &#123;&#125;,<br><br>ref: &#123;<br>create: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span> (<span class="hljs-params">_, vnode</span>) </span>&#123;<br>registerRef(vnode);<br>&#125;,<br>update: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span> (<span class="hljs-params">oldVnode, vnode</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (oldVnode.data.ref !== vnode.data.ref) &#123;<br>registerRef(oldVnode, <span class="hljs-literal">true</span>);<br>registerRef(vnode);<br>&#125;<br>&#125;,<br>destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destroy</span> (<span class="hljs-params">vnode</span>) </span>&#123;<br>registerRef(vnode, <span class="hljs-literal">true</span>);<br>&#125;<br>&#125;,<br>directives: &#123;<br>create: updateDirectives,<br>update: updateDirectives,<br>destroy: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unbindDirectives</span> (<span class="hljs-params">vnode</span>) </span>&#123;<br>updateDirectives(vnode, emptyNode);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> backend = <br>modules: [<br>attrs,<br>klass,<br>events,<br>domProps,<br>style,<br>transition,<br>ref,<br>directives<br>]<br>&#125;<br><br><span class="hljs-keyword">var</span> hooks = [<span class="hljs-string">'create'</span>, <span class="hljs-string">'activate'</span>, <span class="hljs-string">'update'</span>, <span class="hljs-string">'remove'</span>, <span class="hljs-string">'destroy'</span>];<br><br><span class="hljs-keyword">let</span> i, j<br><span class="hljs-keyword">const</span> cbs = &#123;&#125;<br><br><span class="hljs-keyword">const</span> &#123; modules, nodeOps &#125; = backend<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; hooks.length; ++i) &#123;<br>cbs[hooks[i]] = []<br><span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; modules.length; ++j) &#123;<br><span class="hljs-keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;<br>cbs[hooks[i]].push(modules[j][hooks[i]])<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>依据上面的执行逻辑，cbs 就变成下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">cbs = &#123;<br>create: [updateAttrs, updateClass, updateDOMListeners, updateDOMProps, updateStyle, _enter, ref.create, updateDirectives],<br>activate: [_enter],<br>update: [updateAttrs, updateClass, updateDOMListeners, updateDOMProps, updateStyle, ref.update, updateDirectives],<br>remove: [transition.remove],<br>destroy: [ref.destroy, directives.destroy],<br>&#125;<br></code></pre></td></tr></table></figure><p>综合以上整理的情况我可以总结如下：</p><ol><li>不同的属性拥有针对不同情况的处理方法</li><li>attrs、class、domListeners、domProps、style、directives 等属性创建和更新采用的是同一个方法</li><li>transition 没有更新方法，但是有进入和销毁方法</li><li>指令也有销毁方法</li></ol><p>回到上面的 invokeCreateHooks，因为我们这一步是创建初始 dom，所以只需执行 cbs.create 里的方法。那么接下来，我们来看看 cbs.create 里的方法，这里只挑选几个我觉得有意思的做解析（省略不重要代码）。原来的 demo 会做一下改变，以便适应不同的调试场景</p><h4 id="updateAttrs"><a href="#updateAttrs" class="headerlink" title="updateAttrs"></a>updateAttrs</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> key, cur, old;<br><span class="hljs-keyword">var</span> elm = vnode.elm;<br><span class="hljs-keyword">var</span> oldAttrs = oldVnode.data.attrs || &#123;&#125;;<br><span class="hljs-keyword">var</span> attrs = vnode.data.attrs || &#123;&#125;;<br><br><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> attrs) &#123;<br>cur = attrs[key];<br>old = oldAttrs[key];<br><span class="hljs-keyword">if</span> (old !== cur) &#123;<br>setAttr(elm, key, cur, vnode.data.pre);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> oldAttrs) &#123;<br><span class="hljs-keyword">if</span> (isUndef(attrs[key])) &#123;<br><span class="hljs-keyword">if</span> (isXlink(key)) &#123;<br>elm.removeAttributeNS(xlinkNS, getXlinkProp(key));<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isEnumeratedAttr(key)) &#123;<br>elm.removeAttribute(key);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一步，attr 的旧值与新值如果不同，则将值设置成最新的；<br>第二步，一个是 xlink 属性，另一个是无法枚举属性，也就是除了 contenteditable, draggable, spellcheck 之外的属性，这些属性需要被移除</p><h4 id="updateClass"><a href="#updateClass" class="headerlink" title="updateClass"></a>updateClass</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"demo"</span>&gt;<br>&lt;p <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"currentBranchClass"</span> :<span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">"currentBranch"</span>&gt;&#123;&#123; currentBranch &#125;&#125;&lt;<span class="hljs-regexp">/p&gt;</span><br><span class="hljs-regexp">&lt;/</span>div&gt;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = vnode.data<br><span class="hljs-keyword">var</span> cls = genClassForVnode(vnode);<br><br><span class="hljs-keyword">var</span> transitionClass = el._transitionClasses;<br><span class="hljs-keyword">if</span> (isDef(transitionClass)) &#123;<br>cls = concat(cls, stringifyClass(transitionClass));<br>&#125;<br><br><span class="hljs-keyword">if</span> (cls !== el._prevClass) &#123;<br>el.setAttribute(<span class="hljs-string">'class'</span>, cls);<br>el._prevClass = cls;<br>&#125;<br></code></pre></td></tr></table></figure><p>依据 demo，currentBranch 当前的值是 master，因此 vnode.data = {class: ‘master’, staticClass: “currentBranchClass”}, 最后生成的 cls = ‘currentBranchClass master’。如果存在 transitionClass，则将它合并到 cls 中。最后就是调用原生方法添加 class 属性，并且把 cls 赋值给元素的 _preClass，相当于旧 class，用作下次判断如果新旧 class 相等，则不需要执行添加 class 操作。</p><h4 id="updateDOMListeners"><a href="#updateDOMListeners" class="headerlink" title="updateDOMListeners"></a>updateDOMListeners</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"demo"</span>&gt;<br>&lt;input type=<span class="hljs-string">"text"</span> @click=<span class="hljs-string">"testClick"</span> v-model=<span class="hljs-string">"currentBranch"</span>&gt;<br>&lt;<span class="hljs-regexp">/div&gt;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">methods: &#123;</span><br><span class="hljs-regexp">testClick() &#123;</span><br><span class="hljs-regexp">console.log('yeah, you click it!')</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp">&#125;</span><br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> on = vnode.data.on || &#123;&#125;;<br><span class="hljs-keyword">var</span> oldOn = oldVnode.data.on || &#123;&#125;;<br>target = vnode.elm;<br>normalizeEvents(on);<br>updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);<br>target = <span class="hljs-literal">undefined</span>;<br></code></pre></td></tr></table></figure><p>因为 v-model 包含有 input 事件，所以这里的 on = {click: testClick, input: f}, 然后是使用 normalizeEvents 处理 type=”range” 这种情况，最后就是更新事件到 dom 上。先来看下这个特殊情况的处理，假如我们把 input 的 type 设置成 range，那么 on = {click: testClick, _r: f}，可以看到 v-model 中的 input 事件被 range 事件覆盖了。所以 normalizeEvents 就是来解决这个问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (isDef(on[RANGE_TOKEN])) &#123;<br><span class="hljs-keyword">var</span> event = isIE ? <span class="hljs-string">'change'</span> : <span class="hljs-string">'input'</span>;<br>on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);<br><span class="hljs-keyword">delete</span> on[RANGE_TOKEN];<br>&#125;<br></code></pre></td></tr></table></figure><p>RANGE_TOKEN 即 _r，意思就是，如果是 IE，就使用 range 的 change 事件，否则使用 v-model 的 input 事件。</p><p>updateListeners 的入参分别是 当前事件集合、旧事件集合、添加事件方法、移除事件方法、创建一次事件方法、上下文对象。知道了这些，我们继续进入内部探寻，大体上就是分成两个步骤，分别是循环处理新事件和处理旧事件。处理新事件分成三个分支，第一个是处理边界，第二个是不存在旧事件就添加新事件，第三分支是替换新事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (name <span class="hljs-keyword">in</span> on) &#123;<br><span class="hljs-comment">// 省略</span><br>event = normalizeEvent(name);<br><span class="hljs-keyword">if</span> (isUndef(cur.fns)) &#123;<br>cur = on[name] = createFnInvoker(cur, vm);<br>&#125;<br>add(event.name, cur, event.capture, event.passive, event.params);<br><span class="hljs-comment">// 省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>normalizeEvent(name) 处理事件修饰符，包括 capture、passive 等。接着来看 createFnInvoker(cur, vm)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoker</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> <span class="hljs-built_in">arguments</span> = <span class="hljs-built_in">arguments</span>;<br><br><span class="hljs-keyword">var</span> fns = invoker.fns;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(fns)) &#123;<br><span class="hljs-keyword">var</span> cloned = fns.slice();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; cloned.length; i++) &#123;<br>invokeWithErrorHandling(cloned[i], <span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>, vm, <span class="hljs-string">"v-on handler"</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// return handler return value for single handlers</span><br><span class="hljs-keyword">return</span> invokeWithErrorHandling(fns, <span class="hljs-literal">null</span>, <span class="hljs-built_in">arguments</span>, vm, <span class="hljs-string">"v-on handler"</span>)<br>&#125;<br>&#125;<br>invoker.fns = fns;<br><span class="hljs-keyword">return</span> invoker<br></code></pre></td></tr></table></figure><p>将 invoker 方法返回，替换了原来绑定的事件方法。fns 是原来的事件方法，它有可能是数组，也可能是单个方法，这决定了走不同的处理分支。但最终都会是执行 invokeWithErrorHandling 方法，传入原事件方法及当前接受到的参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeWithErrorHandling</span> (<span class="hljs-params">handler, context, args, vm, info</span>) </span>&#123;<br><span class="hljs-keyword">var</span> res;<br><span class="hljs-keyword">try</span> &#123;<br>res = args ? handler.apply(context, args) : handler.call(context);<br><span class="hljs-keyword">if</span> (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123;<br>res.catch(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123; <span class="hljs-keyword">return</span> handleError(e, vm, info + <span class="hljs-string">" (Promise/async)"</span>); &#125;);<br><span class="hljs-comment">// issue #9511</span><br><span class="hljs-comment">// avoid catch triggering multiple times when nested calls</span><br>res._handled = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>handleError(e, vm, info);<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面除了执行原事件方法以外，还添加了 promise 错误结果处理机制，以及在嵌套调用时可能会引发的多次调用问题，这也是将原事件进行封装的原因之一。</p><p>最后就是调用 add 方法添加事件了，内部使用原生 addEventListener, 但是在这之前，会对使用微任务的环境进行一个处理，就是给事件的多次触发添加一个时间，因为异步事件会造成事件重复触发。</p><h4 id="updateDirectives"><a href="#updateDirectives" class="headerlink" title="updateDirectives"></a>updateDirectives</h4><p>常用指令有 v-text, v-html, v-if, v-for, v-else-if, v-else, v-show 等，但是这些都是内置指令，在由 AST 转换成 render 函数的时候就已经被处理，因此 updateDirectives 是专门用来处理自定义指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;div id=<span class="hljs-string">"demo"</span>&gt;<br>&lt;input v-focus&gt;<br>&lt;<span class="hljs-regexp">/div&gt;</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">directives: &#123;</span><br><span class="hljs-regexp">focus: &#123;</span><br><span class="hljs-regexp">inserted: function (el) &#123;</span><br><span class="hljs-regexp">el.focus()</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp">&#125;</span><br><span class="hljs-regexp">&#125;,</span><br></code></pre></td></tr></table></figure><p>updateDirectives 实际上是调用 _update 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> isCreate = oldVnode === emptyNode;<br><span class="hljs-keyword">var</span> isDestroy = vnode === emptyNode;<br><span class="hljs-keyword">var</span> oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);<br><span class="hljs-keyword">var</span> newDirs = normalizeDirectives(vnode.data.directives, vnode.context);<br></code></pre></td></tr></table></figure><p>isCreate 是给 dom 初次绑定指令的标识，isDestroy 则是销毁指令标识。经过 normalizeDirectives 处理之后，newDirs 就变成如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">newDirs = &#123;<br><span class="hljs-string">'v-focus'</span>: &#123;<br>def: fn,<br>modifiers: &#123;&#125;,<br>name: <span class="hljs-string">'focus'</span>,<br>rawName: <span class="hljs-string">'v-focus'</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是对 newDirs 的处理，如果旧指令集中不存在该指令，将 newDirs 存入 dirsWithInsert，否则存入 dirsWithPostpatch。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> dirsWithInsert = [];<br><span class="hljs-keyword">var</span> dirsWithPostpatch = [];<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (dirsWithInsert.length) &#123;<br><span class="hljs-keyword">var</span> callInsert = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; dirsWithInsert.length; i++) &#123;<br>callHook(dirsWithInsert[i], <span class="hljs-string">'inserted'</span>, vnode, oldVnode);<br>&#125;<br>&#125;;<br><span class="hljs-keyword">if</span> (isCreate) &#123;<br>mergeVNodeHook(vnode, <span class="hljs-string">'insert'</span>, callInsert);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>callInsert();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果是初次给 dom 绑定指令，使用 mergeVNodeHook 进行 insert 操作。最后一个入参方法是使用 callHook 对每一个新指令进行处理。  </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeVNodeHook</span> (<span class="hljs-params">def, hookKey, hook</span>) </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrappedHook</span> (<span class="hljs-params"></span>) </span>&#123;<br>hook.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);<br><span class="hljs-comment">// important: remove merged hook to ensure it's called only once</span><br><span class="hljs-comment">// and prevent memory leak</span><br>remove(invoker.fns, wrappedHook);<br>&#125;<br><br><span class="hljs-keyword">if</span> (isUndef(oldHook)) &#123;<br><span class="hljs-comment">// no existing hook</span><br>invoker = createFnInvoker([wrappedHook]);<br>&#125;<br><br>invoker.merged = <span class="hljs-literal">true</span>;<br>def[hookKey] = invoker;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里实际上是对 callInsert 进行了两层封装，第一层是 wrappedHook, 里面执行 callInsert 之外，还做了一个容错处理，这里就不做解析了。第二层就是通用的包装成 invoker。有一点需要注意，那就是封装完成的方法并不是赋值给 vnode[‘insert’]，而是 vnode.data.hook[‘insert’]。为什么呢？在 mergeVNodeHook 中有这样一段代码：def = def.data.hook || (def.data.hook = {}); 讲原因之前需要额外插一个知识点，那就是 JavaScript 中函数传值都是值传递。拿这段代码为例，在执行之前，def 指向的是 vnode，def 只是一个指针，指向 vnode；执行之后，相当于把指针指向了 {}, 那么此时的 def 就是 {}，而 vnode 并不会变成 {}，最后的结果也就变成这样 def = vnode.data.hook = {}。此时 def 和 vnode.data.hook 这两个指针指向了 {}，当为 def 添加属性时，vnode.data.hook 会同步改变，因此 def[‘insert’] = vnode.data.hook[‘insert’] = invoker, 即 vnode.data.hook[‘insert’] = invoker。</p><p>到这里，updateDirectives 大概就讲完了，它的主线任务就是给 vnode.data.hook 添加自定义指令对象，包括指令名和指令执行的方法。</p><p>dir.def[hook] 即上面包装两层的 invoker。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>invokeCreateHooks 执行完成后，就会调用 insert(parentElm, vnode.elm, refElm) 挂载 dom。 本文把模板到真实 DOM 的转变分成 parse、transform、generate、patch 四个步骤，前三步骤所做的事跟传统编译步骤不太一样，但也有相同点，这样划分是为了更好的在宏观层面有一个流程记忆，方便理解。每一个步骤都会涉及巨量内容及复杂情况的处理，不可能都涉及到，因此本篇的宗旨是从宏观上理解这些过程。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>响应式系统是如何运作的</title>
    <link href="/2021/04/16/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/"/>
    <url>/2021/04/16/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>作为 Vue 的特色之一，响应式系统原理一直被大家所讨论和学习，网上关于原理解析的文章也是多如牛毛。但别人的始终是别人的，想要变成自己的还得自己动手，真正去理解。</p><h2 id="什么是响应式系统"><a href="#什么是响应式系统" class="headerlink" title="什么是响应式系统"></a>什么是响应式系统</h2><p>官网这样说：</p><blockquote><p>数据模型只是普通的 JavaScript 对象，而当你修改它时，视图也会改变</p></blockquote><p>其实除了视图会改变之后，那些订阅过该对象的对象也会改变</p><p>到这里，就可以祭出响应式系统的三驾马车了：Observer、Watcher、Dep</p><p>其实响应式系统可以理解为 Observer  + ‘发布订阅模式’</p><h3 id="Observe"><a href="#Observe" class="headerlink" title="Observe"></a>Observe</h3><p>Observer 就是赋予一个对象一些能力，为对象添加 getter/setter 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Observer = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Observer</span> (<span class="hljs-params">value</span>) </span>&#123;<br><span class="hljs-keyword">this</span>.value = value;<br><span class="hljs-keyword">this</span>.dep = <span class="hljs-keyword">new</span> Dep();<br><span class="hljs-keyword">this</span>.vmCount = <span class="hljs-number">0</span>;<br>def(value, <span class="hljs-string">'__ob__'</span>, <span class="hljs-keyword">this</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br><span class="hljs-keyword">if</span> (hasProto) &#123;<br>protoAugment(value, arrayMethods);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>copyAugment(value, arrayMethods, arrayKeys);<br>&#125;<br><span class="hljs-keyword">this</span>.observeArray(value);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.walk(value);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对数组和对象做不一样的处理，对象走 walk 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Observer.prototype.walk = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span> (<span class="hljs-params">obj</span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><p>而数组则重新走 Observer，因为里面的属性有可能是对象，需要走 walk 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Observer.prototype.observeArray = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observeArray</span> (<span class="hljs-params">items</span>) </span>&#123;&#125;;<br></code></pre></td></tr></table></figure><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><p>拥有响应式属性的每个对象在被 Watcher 系统处理之后都是一个 Watcher，因此也会拥有 Watcher 构造函数的属性及方法。最重要的是，在这个过程中，Watcher 会完成依赖收集，也就是订阅工作。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// expOrFn 是订阅的对象表达式</span><br><span class="hljs-comment">// cb 是订阅对象发生改变时执行的操作</span><br><span class="hljs-keyword">var</span> Watcher = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Watcher</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">vm,</span></span><br><span class="hljs-function"><span class="hljs-params">expOrFn,</span></span><br><span class="hljs-function"><span class="hljs-params">cb,</span></span><br><span class="hljs-function"><span class="hljs-params">options,</span></span><br><span class="hljs-function"><span class="hljs-params">isRenderWatcher</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">this</span>.cb = cb;<br><span class="hljs-keyword">this</span>.id = ++uid$<span class="hljs-number">2</span>; <span class="hljs-comment">// uid for batching</span><br><span class="hljs-keyword">this</span>.active = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">this</span>.dirty = <span class="hljs-keyword">this</span>.lazy; <span class="hljs-comment">// for lazy watchers</span><br><span class="hljs-keyword">this</span>.deps = [];<br><span class="hljs-keyword">this</span>.newDeps = [];<br><span class="hljs-keyword">this</span>.depIds = <span class="hljs-keyword">new</span> _Set();<br><span class="hljs-keyword">this</span>.newDepIds = <span class="hljs-keyword">new</span> _Set();<br><span class="hljs-keyword">this</span>.expression = expOrFn.toString();<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">this</span>.value = <span class="hljs-keyword">this</span>.lazy<br>? <span class="hljs-literal">undefined</span><br>: <span class="hljs-keyword">this</span>.get();<br>&#125;;<br></code></pre></td></tr></table></figure><p>构造函数本身会初始化一些必要属性， 如 this.cb 是当订阅对象发生改变时所需要调用的方法，而 deps、newDeps 则与发布系统相关。<br>下面简单罗列一个 watcher 所拥有的方法，其中重要的方法的作用后面再说</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 触发 getter，重新获取依赖</span><br>Watcher.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// 将自身存入 Dep 系统中</span><br>Watcher.prototype.addDep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addDep</span> (<span class="hljs-params">dep</span>) </span>&#123;&#125;<br><span class="hljs-comment">// 将自身从 Dep 系统中移除</span><br>Watcher.prototype.cleanupDeps = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cleanupDeps</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// Dep 重新发布后，自身开始更新依赖</span><br>Watcher.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// 执行 cb，真正的更新操作，</span><br>Watcher.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// 调用 get 方法，只会为惰性 watcher 执行</span><br>Watcher.prototype.evaluate = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">evaluate</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// 将自身添加到所有的 Dep 系统中</span><br>Watcher.prototype.depend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depend</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// 将自己从订阅表中移除</span><br>Watcher.prototype.teardown = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">teardown</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p>每一个 Dep 就是收集订阅者信息的容器，当订阅对象发生改变时，Dep 就会通知订阅者去更新</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Dep = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Dep</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">this</span>.id = uid++;<br><span class="hljs-comment">// 收集订阅者</span><br><span class="hljs-keyword">this</span>.subs = [];<br>&#125;;<br><span class="hljs-comment">// 添加订阅者</span><br>Dep.prototype.addSub = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addSub</span> (<span class="hljs-params">sub</span>) </span>&#123;&#125;<br><span class="hljs-comment">// 移除订阅者</span><br>Dep.prototype.removeSub = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">removeSub</span> (<span class="hljs-params">sub</span>) </span>&#123;&#125;<br><span class="hljs-comment">// watcher 收集 dep </span><br>Dep.prototype.depend = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">depend</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-comment">// 通知订阅者</span><br>Dep.prototype.notify = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notify</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>上面对三驾马车做了一个简单的解释，下面将会全面解析响应式系统是如何由这三个系统整合的。</p><h2 id="响应式系统的运作"><a href="#响应式系统的运作" class="headerlink" title="响应式系统的运作"></a>响应式系统的运作</h2><h3 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h3><p>我们知道，对于 data 中的属性，不论是采用显示的 watch，还是通过在 element 中绑定的方式，都能实现响应式的效果，下面将首先解析 watch 的方式<br>还是拿官方 demo（路径是：/examples/commits） 来举例，精简之后如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>data: &#123;<br>currentBranch: <span class="hljs-string">'master'</span>,<br>&#125;,<br>watch: &#123;<br>currentBranch: <span class="hljs-string">'fetchData'</span><br>&#125;,<br>methods: &#123;<br>fetchData: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>声明了一个属性 currentBranch, 并且作为 watch 对象一个属性的 key，它的值是一个方法。</p><p>下面将结合源码及断点调试的方式，一步步解析。</p><p>依据 “总体结构” 章节的准备工作，我们可以清楚的知道 data 对象的处理位于 initData 方法中，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initData</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> data = vm.$options.data<br>  data = vm._data = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">'function'</span><br>    ? getData(data, vm)<br>    : data || &#123;&#125;<br>  <span class="hljs-keyword">if</span> (!isPlainObject(data)) &#123;<br>    data = &#123;&#125;<br>    process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; warn(<br>      <span class="hljs-string">'data functions should return an object:\n'</span> +<br>      <span class="hljs-string">'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function'</span>,<br>      vm<br>    )<br>  &#125;<br>  <span class="hljs-comment">// proxy data on instance</span><br>  <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(data)<br>  <span class="hljs-keyword">const</span> props = vm.$options.props<br>  <span class="hljs-keyword">const</span> methods = vm.$options.methods<br>  <span class="hljs-keyword">let</span> i = keys.length<br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">const</span> key = keys[i]<br>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span>) &#123;<br>      <span class="hljs-keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;<br>        warn(<br>          <span class="hljs-string">`Method "<span class="hljs-subst">$&#123;key&#125;</span>" has already been defined as a data property.`</span>,<br>          vm<br>        )<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;<br>      process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp; warn(<br>        <span class="hljs-string">`The data property "<span class="hljs-subst">$&#123;key&#125;</span>" is already declared as a prop. `</span> +<br>        <span class="hljs-string">`Use prop default value instead.`</span>,<br>        vm<br>      )<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved(key)) &#123;<br>      proxy(vm, <span class="hljs-string">`_data`</span>, key)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// observe data</span><br>  observe(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>initData 方法主要做了三件事：</p><ul><li>获取真正的 data 对象，因为 options 中的 data 有可能是函数</li><li>对于在 methods 和 props 中已经存在的属性，做警告提示</li><li>observe data</li></ul><p>这里我们只讲解 observe data</p><p>通过查看 observe 方法，我们可以知道，重点就是这段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ob = <span class="hljs-keyword">new</span> Observer(value)<br></code></pre></td></tr></table></figure><p>就这样顺藤摸瓜找到了 Observer 构造函数，该构造函数及与自身相关的属性已经在上面列出</p><p>walk 是这样的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Observer.prototype.walk = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">walk</span> (<span class="hljs-params">obj</span>) </span>&#123;<br><span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(obj);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>defineReactive(obj, keys[i]);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>对对象的每一个属性都调用 defineReactive（打包的源码中这里是 defineReactive$$1） 处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">obj,</span></span><br><span class="hljs-function"><span class="hljs-params">key,</span></span><br><span class="hljs-function"><span class="hljs-params">val,</span></span><br><span class="hljs-function"><span class="hljs-params">customSetter,</span></span><br><span class="hljs-function"><span class="hljs-params">shallow</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> dep = <span class="hljs-keyword">new</span> Dep();<br><br><span class="hljs-keyword">var</span> property = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, key);<br><span class="hljs-keyword">if</span> (property &amp;&amp; property.configurable === <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-comment">// cater for pre-defined getter/setters</span><br><span class="hljs-keyword">var</span> getter = property &amp;&amp; property.get;<br><span class="hljs-keyword">var</span> setter = property &amp;&amp; property.set;<br><span class="hljs-keyword">if</span> ((!getter || setter) &amp;&amp; <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;<br>val = obj[key];<br>&#125;<br><br><span class="hljs-keyword">var</span> childOb = !shallow &amp;&amp; observe(val);<br><span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>enumerable: <span class="hljs-literal">true</span>,<br>configurable: <span class="hljs-literal">true</span>,<br><span class="hljs-keyword">get</span>: function reactiveGetter () &#123;<br><span class="hljs-keyword">var</span> value = getter ? getter.call(obj) : val;<br><span class="hljs-keyword">if</span> (Dep.target) &#123;<br>dep.depend();<br><span class="hljs-keyword">if</span> (childOb) &#123;<br>childOb.dep.depend();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;<br>dependArray(value);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> value<br>&#125;,<br><span class="hljs-keyword">set</span>: function reactiveSetter (newVal) &#123;<br><span class="hljs-keyword">var</span> value = getter ? getter.call(obj) : val;<br><span class="hljs-comment">/* eslint-disable no-self-compare */</span><br><span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">/* eslint-enable no-self-compare */</span><br><span class="hljs-keyword">if</span> (customSetter) &#123;<br>customSetter();<br>&#125;<br><span class="hljs-comment">// #7981: for accessor properties without setter</span><br><span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="hljs-keyword">return</span> &#125;<br><span class="hljs-keyword">if</span> (setter) &#123;<br>setter.call(obj, newVal);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>val = newVal;<br>&#125;<br>childOb = !shallow &amp;&amp; observe(newVal);<br>dep.notify();<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>defineReactive 方法做了如下处理：</p><ul><li>声明一个 Dep 实例</li><li>对传参属性值进行继续进行 observe 处理</li><li>使用 Object.defineProperty 为传参属性 key 添加 getter/setter</li></ul><p>响应式系统的联动装置就存在于 get 和 set 中，get 属性中有这样一段代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (Dep.target) &#123;<br>dep.depend();<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 Dep.target 存在，就调用 dep.depend 方法，那么现在有两个问题：</p><ol><li>get 的触发时机是什么</li><li>Dep.target 是什么</li></ol><p>带着这两个问题，我们开始调试一下 demo</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initState</span> (<span class="hljs-params">vm</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (opts.data) &#123;<br>initData(vm);<br>&#125;<br><span class="hljs-keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;<br>initWatch(vm, opts.watch);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 initData 处理完之后，接着会调用 initWatch，以下会简略罗列 initWatch 所包含的一些处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initWatch</span> (<span class="hljs-params">vm, watch</span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> watch) &#123;<br><span class="hljs-comment">// 省略一些代码</span><br>createWatcher(vm, key, handler);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createWatcher</span> (<span class="hljs-params">vm,expOrFn,handler,options</span>) </span>&#123;<br><span class="hljs-comment">// 省略一些代码</span><br><span class="hljs-keyword">return</span> vm.$watch(expOrFn, handler, options)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$watch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">expOrFn,cb,options</span>) </span>&#123;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">if</span> (isPlainObject(cb)) &#123;<br><span class="hljs-keyword">return</span> createWatcher(vm, expOrFn, cb, options)<br>&#125;<br>options = options || &#123;&#125;;<br>options.user = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">var</span> watcher = <span class="hljs-keyword">new</span> Watcher(vm, expOrFn, cb, options);<br><span class="hljs-keyword">if</span> (options.immediate) &#123;<br><span class="hljs-keyword">var</span> info = <span class="hljs-string">"callback for immediate watcher \""</span> + (watcher.expression) + <span class="hljs-string">"\""</span>;<br>pushTarget();<br>invokeWithErrorHandling(cb, vm, [watcher.value], vm, info);<br>popTarget();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unwatchFn</span> (<span class="hljs-params"></span>) </span>&#123;<br>watcher.teardown();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>$watch 方法就是我们需要重点关注的。</p><p>首先是对 cb 的判断，如果是对象，则重新走 createWatcher, 找到它内部的函数<br>接着是创建一个 Watcher 实例</p><p>继续查看 Watcher 之前，我们先要了解一个重要的机制，那就是每当 Dep 收集时，只能存在一个订阅者，因此下面的一对处理方法的作用就是添加和删除订阅者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushTarget</span> (<span class="hljs-params">target</span>) </span>&#123;<br>targetStack.push(target);<br>Dep.target = target;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">popTarget</span> (<span class="hljs-params"></span>) </span>&#123;<br>targetStack.pop();<br>Dep.target = targetStack[targetStack.length - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Watcher 构造函数最后会调用自身的 get 方法，内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js">Watcher.prototype.get = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">get</span> (<span class="hljs-params"></span>) </span>&#123;<br>    pushTarget(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">var</span> value;<br>    <span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">this</span>.vm;<br>    <span class="hljs-keyword">try</span> &#123;<br>        value = <span class="hljs-keyword">this</span>.getter.call(vm, vm);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.user) &#123;<br>            handleError(e, vm, (<span class="hljs-string">"getter for watcher \""</span> + (<span class="hljs-keyword">this</span>.expression) + <span class="hljs-string">"\""</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> e<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.deep) &#123;<br>            traverse(value);<br>        &#125;<br>        popTarget();<br>        <span class="hljs-keyword">this</span>.cleanupDeps();<br>    &#125;<br>    <span class="hljs-keyword">return</span> value<br>&#125;;<br></code></pre></td></tr></table></figure><p>大致的执行步骤如下：</p><ol><li>将自身作为当前订阅者存入 targetStack 中，</li><li>然后调用自身的 getter 方法</li><li>将自身从 targetStack 中弹出，并将当前订阅者设为 null</li></ol><p>步骤1和3很清晰，但是步骤2中的 getter 方法是什么呢？</p><p>getter 的定义存在于 Watcher 构造函数中，上面贴代码时省略掉了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">this</span>.getter = parsePath(expOrFn);<br></code></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bailRE = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>((<span class="hljs-string">"[^"</span> + (unicodeRegExp.source) + <span class="hljs-string">".$_\\d]"</span>));<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parsePath</span> (<span class="hljs-params">path</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (bailRE.test(path)) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">var</span> segments = path.split(<span class="hljs-string">'.'</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; segments.length; i++) &#123;<br><span class="hljs-keyword">if</span> (!obj) &#123; <span class="hljs-keyword">return</span> &#125;<br>obj = obj[segments[i]];<br>&#125;<br><span class="hljs-keyword">return</span> obj<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>expOrFn 就是 ‘currentBranch’, 符合格式验证，因此 sements 即 [‘currentBranch’], getter 就是 parsePath 返回的这个方法，当执行 getter 并传入 vm 时，就会执行 obj = obj[segments[i]]，转换之后就是 obj = vm[‘currentBranch’]。</p><p>vm[‘currentBranch’] 就是获取 currentBranch 的值，那么就会触发它的 get 方法，所以我们再回到前面定义的 get 方法中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">get</span>: function reactiveGetter () &#123;<br><span class="hljs-keyword">var</span> value = getter ? getter.call(obj) : val;<br><span class="hljs-keyword">if</span> (Dep.target) &#123;<br>dep.depend();<br><span class="hljs-comment">// 省略一些代码</span><br>&#125;<br><span class="hljs-keyword">return</span> value<br>&#125;,<br></code></pre></td></tr></table></figure><blockquote><p>var value = getter ? getter.call(obj) : val;</p></blockquote><p>因为前面没有为 currentBranch 定义过 getter 方法, 因此 value 就是 val 即 ‘master’</p><p>Dep.target 在 pushTarget(this) 时已经存在， 即 watcher 自身</p><p><img src="F:%5Clearning%5Cblog%5Csource_posts%5C%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81%5Cvue2%5C%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84.assets%5CwatcherIns.png" srcset="/img/loading.gif" lazyload alt="watcherIns"></p><p>然后执行 dep.depend() 通知 dep 将 watcher 收集起来<br>最后返回 value</p><p>继续回到 Watcher.prototype.get 中<br>在 finally 代码块中执行 popTarget() 清空 targetStack，将当前订阅者设为 null</p><p>到这里我们几乎完整走了一遍依赖收集过程，这个过程涉及到了响应式系统的三驾马车。简单梳理一下：</p><ul><li>首先 data 中的属性经过 Observer 处理，会获得一对 getter/setter，这是响应式的根基</li><li>这个属性在 watch 中也有声明，因此最终的 $watch 方法也会处理到它。这里分为两个步骤，第一是将自身置为当前的 Dep.target, 第二是在获取这个属性的值时触发 getter，进而完成 dep 对 watcher 的收集</li></ul><h3 id="依赖触发"><a href="#依赖触发" class="headerlink" title="依赖触发"></a>依赖触发</h3><p>前面说过，这个响应式系统可以理解为发布订阅模式，上面已经了解了订阅过程，接下来就要去探寻发布过程了。</p><p>这个 demo 的功能很简单，一对单选框，选中会展现不同的内容。现在我从默认的 master 切换到 dev. 由于单选框做了双向绑定，所以这时会改变 currentBranch 的值，也就会触发 setter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">set</span>: function reactiveSetter (newVal) &#123;<br><span class="hljs-keyword">var</span> value = getter ? getter.call(obj) : val;<br><span class="hljs-comment">/* eslint-disable no-self-compare */</span><br><span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">/* eslint-enable no-self-compare */</span><br><span class="hljs-keyword">if</span> (customSetter) &#123;<br>customSetter();<br>&#125;<br><span class="hljs-comment">// #7981: for accessor properties without setter</span><br><span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) &#123; <span class="hljs-keyword">return</span> &#125;<br><span class="hljs-keyword">if</span> (setter) &#123;<br>setter.call(obj, newVal);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>val = newVal;<br>&#125;<br>childOb = !shallow &amp;&amp; observe(newVal);<br>dep.notify();<br>&#125;<br></code></pre></td></tr></table></figure><p>首先做一个原值没有改变的处理，然后将新的值也要做 observe 处理，最后就是通知订阅者这个值发生了改变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">Dep.prototype.notify = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">notify</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">// stabilize the subscriber list first</span><br><span class="hljs-keyword">var</span> subs = <span class="hljs-keyword">this</span>.subs.slice();<br><span class="hljs-keyword">if</span> (!config.async) &#123;<br><span class="hljs-comment">// subs aren't sorted in scheduler if not running async</span><br><span class="hljs-comment">// we need to sort them now to make sure they fire in correct</span><br><span class="hljs-comment">// order</span><br>subs.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123; <span class="hljs-keyword">return</span> a.id - b.id; &#125;);<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = subs.length; i &lt; l; i++) &#123;<br>subs[i].update();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>subs 里存放的就有之前收集起来的 watcher，因此 subs[i].update 就相当于 watcher.update</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">Watcher.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">update</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">/* istanbul ignore else */</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.lazy) &#123;<br><span class="hljs-keyword">this</span>.dirty = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.sync) &#123;<br><span class="hljs-keyword">this</span>.run();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>queueWatcher(<span class="hljs-keyword">this</span>);<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>因为默认 lazy 和 sync 都为 false，因此这里会走 queueWatcher(this)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">queueWatcher</span> (<span class="hljs-params">watcher</span>) </span>&#123;<br><span class="hljs-keyword">var</span> id = watcher.id;<br><span class="hljs-keyword">if</span> (has[id] == <span class="hljs-literal">null</span>) &#123;<br>has[id] = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">if</span> (!flushing) &#123;<br>queue.push(watcher);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// if already flushing, splice the watcher based on its id</span><br><span class="hljs-comment">// if already past its id, it will be run next immediately.</span><br><span class="hljs-keyword">var</span> i = queue.length - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;<br>i--;<br>&#125;<br>queue.splice(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, watcher);<br>&#125;<br><span class="hljs-comment">// queue the flush</span><br><span class="hljs-keyword">if</span> (!waiting) &#123;<br>waiting = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">if</span> (!config.async) &#123;<br>flushSchedulerQueue();<br><span class="hljs-keyword">return</span><br>&#125;<br>nextTick(flushSchedulerQueue);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认状态下，将新 watcher 存入 queue 中之后，在下一次更新时执行 flushSchedulerQueue 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flushSchedulerQueue</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-comment">// 省略代码</span><br><span class="hljs-keyword">for</span> (index = <span class="hljs-number">0</span>; index &lt; queue.length; index++) &#123;<br>watcher = queue[index];<br><span class="hljs-keyword">if</span> (watcher.before) &#123;<br>watcher.before();<br>&#125;<br>id = watcher.id;<br>has[id] = <span class="hljs-literal">null</span>;<br>watcher.run();<br><span class="hljs-comment">// 省略代码</span><br>&#125;<br><span class="hljs-comment">// 省略代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>遍历 queque，执行 watcher.run()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">Watcher.prototype.run = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.active) &#123;<br><span class="hljs-keyword">var</span> value = <span class="hljs-keyword">this</span>.get();<br><span class="hljs-keyword">if</span> (<br>value !== <span class="hljs-keyword">this</span>.value ||<br>isObject(value) ||<br><span class="hljs-keyword">this</span>.deep<br>) &#123;<br><span class="hljs-comment">// set new value</span><br><span class="hljs-keyword">var</span> oldValue = <span class="hljs-keyword">this</span>.value;<br><span class="hljs-keyword">this</span>.value = value;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.user) &#123;<br><span class="hljs-keyword">var</span> info = <span class="hljs-string">"callback for watcher \""</span> + (<span class="hljs-keyword">this</span>.expression) + <span class="hljs-string">"\""</span>;<br>invokeWithErrorHandling(<span class="hljs-keyword">this</span>.cb, <span class="hljs-keyword">this</span>.vm, [value, oldValue], <span class="hljs-keyword">this</span>.vm, info);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.cb.call(<span class="hljs-keyword">this</span>.vm, value, oldValue);<br>&#125;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>$watch 方法中设置 options.user = true，因此会执行 invokeWithErrorHandling();</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeWithErrorHandling</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">handler,</span></span><br><span class="hljs-function"><span class="hljs-params">context,</span></span><br><span class="hljs-function"><span class="hljs-params">args,</span></span><br><span class="hljs-function"><span class="hljs-params">vm,</span></span><br><span class="hljs-function"><span class="hljs-params">info</span></span><br><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> res;<br><span class="hljs-keyword">try</span> &#123;<br>res = args ? handler.apply(context, args) : handler.call(context);<br><span class="hljs-comment">// 省略代码</span><br>&#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>handleError(e, vm, info);<br>&#125;<br><span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 handler 就是属性值改变时调用的处理方法，即 fetchData。<br>至此，就完成了属性更改、dep 通知、watcher 执行回调这一连串动作</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上，我们简单梳理了 Vue 响应式系统三驾马车系统的一个过程。需要注意的是，这个例子中的依赖收集和触发过程利用了 watch 属性，模板中的属性则是利用了 Dom 赋值或事件，原理与这大致一样，这个后续会说。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个简单的网络请求过程</title>
    <link href="/2021/04/10/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/04/10/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>TCP</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue2-总体结构(一)</title>
    <link href="/2021/04/08/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%B8%80)/"/>
    <url>/2021/04/08/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%B8%80)/</url>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="为什么要读-Vue"><a href="#为什么要读-Vue" class="headerlink" title="为什么要读 Vue"></a>为什么要读 Vue</h3><p>Vue 是目前项目正在使用的框架，阅读学习源码能让我更好的使用框架所提供的功能，也可以解答使用过程中所产生的困惑。有人可能会问，Vue2 相关的源码解析文章在网上一大堆，何必要自己去写呢？我只想说，纸上得来终觉浅，绝知此事要躬行。</p><h3 id="Vue3-已经出来了，为什么依然读-Vue2"><a href="#Vue3-已经出来了，为什么依然读-Vue2" class="headerlink" title="Vue3 已经出来了，为什么依然读 Vue2"></a>Vue3 已经出来了，为什么依然读 Vue2</h3><p>原因一是很久以前就读过 Vue2 的源码，理解了基本的原理，但是后来没有坚持去深入，也就荒废了，心里多少还是有点不甘。因此这次相当于从新来过，也是准备出一个系列，既是读源码的记录整理，也是日后问题查询之处。原因二是虽然新版本的语法形式与旧版不同，但最核心的思想是没变的，吃透旧版之后，有机会也会去读读 Vue3，而这也是必须的。活到老，学到老。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>源码基于 version 2.6.14 of Vue</p><p>本系列暂分为8章，当前章节主要是对后续章节做辅助准备。<br>初次阅读源码时，我就时常陷入各种属性方法名之中，我不知道这个属性是在哪儿声明的，它的作用是什么。虽然说读源码最忌讳深入细枝末节，但无穷的属性让我很恐惧，所以本章会理清楚整体的一个逻辑走向，而第一部分主要是罗列跟 Vue 相关的属性和方法。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h3><p>Vue 这种框架核心文件都是在 src 文件里，但是入口在 package.json 中可以找到。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-string">"dev"</span>: <span class="hljs-string">"rollup -w -c scripts/config.js --environment TARGET:web-full-dev"</span><br></code></pre></td></tr></table></figure><p>通过上述指令，打开 scripts/config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> aliases = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./alias'</span>)<br><span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">p</span> =&gt;</span> &#123;<br><span class="hljs-keyword">const</span> base = p.split(<span class="hljs-string">'/'</span>)[<span class="hljs-number">0</span>]<br><span class="hljs-keyword">if</span> (aliases[base]) &#123;<br><span class="hljs-keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="hljs-number">1</span>))<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> path.resolve(__dirname, <span class="hljs-string">'../'</span>, p)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> builds = &#123;<br><span class="hljs-comment">// Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify</span><br><span class="hljs-string">'web-runtime-cjs-dev'</span>: &#123;<br>entry: resolve(<span class="hljs-string">'web/entry-runtime.js'</span>),<br>dest: resolve(<span class="hljs-string">'dist/vue.runtime.common.dev.js'</span>),<br>format: <span class="hljs-string">'cjs'</span>,<br>env: <span class="hljs-string">'development'</span>,<br>banner<br>&#125;,<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>aliases 对象即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>vue: resolve(<span class="hljs-string">'src/platforms/web/entry-runtime-with-compiler'</span>),<br>compiler: resolve(<span class="hljs-string">'src/compiler'</span>),<br>core: resolve(<span class="hljs-string">'src/core'</span>),<br>shared: resolve(<span class="hljs-string">'src/shared'</span>),<br>web: resolve(<span class="hljs-string">'src/platforms/web'</span>),<br>weex: resolve(<span class="hljs-string">'src/platforms/weex'</span>),<br>server: resolve(<span class="hljs-string">'src/server'</span>),<br>sfc: resolve(<span class="hljs-string">'src/sfc'</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>结合上面两部分代码可以知道，入口在 ‘src/platforms/web/entry-runtime.js’ 中, 即</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'./runtime/index'</span><br></code></pre></td></tr></table></figure><p>继续打开 src/platforms/web/runtime/index</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 这里指明了 Vue 的来源</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'core/index'</span><br><br><span class="hljs-comment">// 如下为 Vue 添加了相关属性，</span><br>Vue.config.mustUseProp = mustUseProp<br>Vue.config.isReservedTag = isReservedTag<br>Vue.config.isReservedAttr = isReservedAttr<br>Vue.config.getTagNamespace = getTagNamespace<br>Vue.config.isUnknownElement = isUnknownElement<br><br>Vue.prototype.__patch__ = inBrowser ? patch : noop<br><br><span class="hljs-comment">// public mount method</span><br>Vue.prototype.$mount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span></span><br><span class="hljs-function"><span class="hljs-params">el?: string | Element,</span></span><br><span class="hljs-function"><span class="hljs-params">hydrating?: boolean</span></span><br><span class="hljs-function"><span class="hljs-params"></span>): <span class="hljs-title">Component</span> </span>&#123;<br>el = el &amp;&amp; inBrowser ? query(el) : <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">return</span> mountComponent(<span class="hljs-keyword">this</span>, el, hydrating)<br>&#125;<br></code></pre></td></tr></table></figure><p>从上可知， Vue 其实来源于我们之前说的 src 文件中，并且为 Vue 原型上添加了 $mount 和 <strong>patch</strong> 方法。</p><h3 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h3><p>从这里开始将会沿着寻找 Vue 构造函数的源头，走马观花式的记录与 Vue 相关的属性及方法。</p><ol><li><p>/src/core/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$isServer = isServerRendering;<br>Vue.prototype.$isServer = <span class="hljs-keyword">this</span>.$vnode &amp;&amp; <span class="hljs-keyword">this</span>.$vnode.ssrContext;<br>Vue.FunctionalRenderContext = &#123;<br>value: FunctionalRenderContext<br>&#125;;<br>Vue.version = <span class="hljs-string">'__VERSION__'</span>;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/index.js  =&gt;  initGlobalAPI(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.config = configDef;<br>Vue.util = &#123;<br>warn,<br>extend,<br>mergeOptions,<br>defineReactive<br>&#125;;<br>Vue.set = <span class="hljs-keyword">set</span>;<br>Vue.delete = del;<br>Vue.nextTick = nextTick;<br>Vue.observable = obj =&gt; &#123;<br>observe(obj)<br><span class="hljs-keyword">return</span> obj<br>&#125;<br><br>Vue.options = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>Vue.options.components = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br>Vue.options.directives = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>Vue.options.filters = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br><br>Vue.options._base = Vue<br><br><span class="hljs-comment">// extend(Vue.options.components, builtInComponents) builtInComponents 即 KeepAlive </span><br>Vue.options.components.KeepAlive = KeepAlive<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/use.js  =&gt;  initUse(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.use = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/mixin.js  =&gt;  initMixin(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.mixin = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/extend.js  =&gt;  initExtend(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.cid = <span class="hljs-number">0</span><br>Vue.extend = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api/assets.js  =&gt;  initAssetRegisters(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.components = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.directives = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.filters = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!-- Vue 构造函数 --&gt;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Vue</span> (<span class="hljs-params">options</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">'production'</span> &amp;&amp;<br>!(<span class="hljs-keyword">this</span> <span class="hljs-keyword">instanceof</span> Vue)<br>) &#123;<br>warn(<span class="hljs-string">'Vue is a constructor and should be called with the `new` keyword'</span>)<br>&#125;<br><span class="hljs-keyword">this</span>._init(options)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/init.js   =&gt; initMixin(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>vm._uid = uid++<br>vm._isVue = <span class="hljs-literal">true</span><br>vm.$options = mergeOptions(<br>resolveConstructorOptions(vm.constructor),<br>options || &#123;&#125;,<br>vm<br>)<br>vm._renderProxy = vm<br>vm._self = vm<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/lifecycle.js   =&gt; initLifecycle(Vue)</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js">vm.$parent = parent<br>vm.$root = parent ? parent.$root : vm<br><br>vm.$children = []<br>vm.$refs = &#123;&#125;<br><br>vm._watcher = <span class="hljs-literal">null</span><br>vm._inactive = <span class="hljs-literal">null</span><br>vm._directInactive = <span class="hljs-literal">false</span><br>vm._isMounted = <span class="hljs-literal">false</span><br>vm._isDestroyed = <span class="hljs-literal">false</span><br>vm._isBeingDestroyed = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/events.js   =&gt; initEvents(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._events = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>)<br>vm._hasHookEvent = <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/render.js   =&gt; initRender(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._vnode = <span class="hljs-literal">null</span> <span class="hljs-comment">// the root of the child tree</span><br>vm._staticTrees = <span class="hljs-literal">null</span> <span class="hljs-comment">// v-once cached trees</span><br>vm.$vnode = vm.$options._parentVnode<br>vm.$slots = resolveSlots(options._renderChildren, renderContext)<br>vm.$scopedSlots = emptyObject<br>vm._c = <span class="hljs-function">(<span class="hljs-params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="hljs-literal">false</span>)<br>vm.$createElement = <span class="hljs-function">(<span class="hljs-params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="hljs-literal">true</span>)<br>vm.$attrs = vm.$vnode.data.attrs || emptyObject<br>vm.$listeners = vm.$options._parentListeners || emptyObject<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; initState(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._watchers = []<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; initProps()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._props = &#123;&#125;<br>vm.$options._propKeys = []<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; initData()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._data = vm.$options.data.call(vm) || vm.$options.data<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/inject.js   =&gt; initProvide()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">vm._provided = vm.$options.provide.call(vm) || vm.$options.provide<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/state.js   =&gt; stateMixin()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$data = &#123;<br><span class="hljs-keyword">get</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._data<br>&#125;<br>&#125;<br>Vue.prototype.$props = &#123;<br><span class="hljs-keyword">get</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._props<br>&#125;<br>&#125;<br>Vue.prototype.$<span class="hljs-keyword">set</span> = <span class="hljs-keyword">set</span><br>Vue.prototype.$delete = del<br>Vue.prototype.$watch = function ()&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/events.js   =&gt; eventsMixin(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$on = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$once = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$off = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$emit = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/lifecycle.js   =&gt; lifecycleMixin(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype._update = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$forceUpdate = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Vue.prototype.$destroy = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/instance/render.js   =&gt; renderMixin(Vue)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.prototype.$nextTick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn: Function</span>) </span>&#123;<br><span class="hljs-keyword">return</span> nextTick(fn, <span class="hljs-keyword">this</span>)<br>&#125;<br>Vue.prototype._render = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里，我们就大致整理出了在初始化 Vue 时会声明的相关属性，在后面的源码阅读过程中会起到一个字典的作用。</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2-总体结构(二)</title>
    <link href="/2021/04/08/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%BA%8C)/"/>
    <url>/2021/04/08/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前一小节，我们整理了 Vue 相关的属性，这一小节则通过框架自带的 demo 来梳理一下 Vue 整体的一个运行流程。</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>首先我们找到本节 demo 目录，路径为 ‘/examples/commits’。将 index.html 中 vue 的引用路径改成 ‘<script src="../../dist/vue.js"></script>‘, 方便调试。</p><p>app.js 里调用了 Vue 构造函数，所以从这里开始吧。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>el: <span class="hljs-string">'#demo'</span>,<br>data: &#123;<br>branches: [<span class="hljs-string">'master'</span>, <span class="hljs-string">'dev'</span>],<br>currentBranch: <span class="hljs-string">'master'</span>,<br>commits: <span class="hljs-literal">null</span><br>&#125;,<br>created: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">this</span>.fetchData()<br>&#125;,<br>watch: &#123;<br>currentBranch: <span class="hljs-string">'fetchData'</span><br>&#125;,<br></code></pre></td></tr></table></figure><h3 id="new-Vue-之前做了什么"><a href="#new-Vue-之前做了什么" class="headerlink" title="new Vue() 之前做了什么"></a>new Vue() 之前做了什么</h3><p>Vue 本身会进行一系列的初始化工作</p><ol><li><p>/src/core/instance/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">initMixin(Vue);<br>stateMixin(Vue);<br>eventsMixin(Vue);<br>lifecycleMixin(Vue);<br>renderMixin(Vue);<br></code></pre></td></tr></table></figure></li><li><p>/src/core/index.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">initGlobalAPI(Vue);<br><span class="hljs-built_in">Object</span>.defineProperty(Vue.prototype, <span class="hljs-string">"$isServer"</span>, &#123;<br><span class="hljs-keyword">get</span>: isServerRendering,<br>&#125;);<br><br>Object.defineProperty(Vue.prototype, "$ssrContext", &#123;<br><span class="hljs-keyword">get</span>() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$vnode &amp;&amp; <span class="hljs-keyword">this</span>.$vnode.ssrContext;<br>&#125;,<br>&#125;);<br><br><span class="hljs-built_in">Object</span>.defineProperty(Vue, <span class="hljs-string">"FunctionalRenderContext"</span>, &#123;<br>value: FunctionalRenderContext,<br>&#125;);<br><br>Vue.version = <span class="hljs-string">"__VERSION__"</span>;<br></code></pre></td></tr></table></figure></li><li><p>/src/core/global-api.js</p> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">initUse(Vue);<br>initMixin(Vue);<br>initExtend(Vue);<br>initAssetRegisters(Vue);<br></code></pre></td></tr></table></figure></li></ol><h3 id="new-Vue-做了什么"><a href="#new-Vue-做了什么" class="headerlink" title="new Vue() 做了什么"></a>new Vue() 做了什么</h3><p>new Vue() 实际上调用了自身的 _init 方法，从字典可知，_init 方法 在 ‘/src/core/instance/init.js’ 中的 initMixin 方法里。<br>忽略部分代码后是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span>;<br>Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options?: Object</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> vm: Component = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-comment">// a uid</span><br>  vm._uid = uid++;<br><br>  <span class="hljs-comment">// 这个标识可以避免 vm 被观察系统观察</span><br>  vm._isVue = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 将通过自定义策略合并配置项后的值赋值给 $options</span><br>  vm.$options = mergeOptions(<br>    resolveConstructorOptions(vm.constructor),<br>    options || &#123;&#125;,<br>    vm<br>  );<br><br>  <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">"production"</span>) &#123;<br>    <span class="hljs-comment">// 如果不是生产环境就初始化代理相关操作</span><br>    initProxy(vm);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    vm._renderProxy = vm;<br>  &#125;<br><br>  vm._self = vm;<br>  <span class="hljs-comment">// 初始化声明周期</span><br>  initLifecycle(vm);<br>  <span class="hljs-comment">// 初始化事件机制</span><br>  initEvents(vm);<br>  <span class="hljs-comment">// 初始化渲染相关</span><br>  initRender(vm);<br>  <span class="hljs-comment">// 调用 beforeCreate 钩子</span><br>  callHook(vm, <span class="hljs-string">"beforeCreate"</span>);<br>  <span class="hljs-comment">// 在 data 或 props 被处理前初始化注入</span><br>  initInjections(vm); <span class="hljs-comment">// resolve injections before data/props</span><br>  <span class="hljs-comment">// 初始化对 data 和 props 相关操作</span><br>  initState(vm);<br>  <span class="hljs-comment">// 在 data 或 props 被处理后初始化注入</span><br>  initProvide(vm); <span class="hljs-comment">// resolve provide after data/props</span><br>  <span class="hljs-comment">// 调用 created 钩子</span><br>  callHook(vm, <span class="hljs-string">"created"</span>);<br><br>  <span class="hljs-comment">// 如果存在 el 属性，则进行挂载操作</span><br>  <span class="hljs-keyword">if</span> (vm.$options.el) &#123;<br>    vm.$mount(vm.$options.el);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从上可知，_init 方法主要做了如下几件事：</p><ol><li>为 Vue 实例添加 $options 属性</li><li>初始化相关属性。</li><li>在渲染操作相关初始化完成之后和属性注入相关初始化之前调用 beforeCreate 钩子</li><li>在依赖相关初始化完成之后和 Dom 挂载之前调用 created 钩子</li><li>挂载 Dom</li></ol><h3 id="options-合并策略"><a href="#options-合并策略" class="headerlink" title="options 合并策略"></a>options 合并策略</h3><p>我们使用 Vue 构造函数时传入的 options 会经过一系列的合并，合并之后的 options 会被赋值给实例的 $options 属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// merge options</span><br><span class="hljs-keyword">if</span> (options &amp;&amp; options._isComponent) &#123;<br>  initInternalComponent(vm, options);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  vm.$options = mergeOptions(<br>    resolveConstructorOptions(vm.constructor),<br>    options || &#123;&#125;,<br>    vm<br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>因为动态 options 的合并耗时较长，因此只对外部组件采取动态合并的方式。</p><p>先看看 resolveConstructorOptions 方法，vm 是 Vue 实例，vm.constructor 指的是 Vue，代码简化后如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> options = Ctor.options;<br><span class="hljs-keyword">if</span> (Ctor.super) &#123;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br><span class="hljs-keyword">return</span> options;<br></code></pre></td></tr></table></figure><p>依据字典，我们可以知道，Vue.options 的值可以表示成这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">Vue.options = &#123;<br>  components: &#123;&#125;,<br>  directives: &#123;&#125;,<br>  filters: &#123;&#125;,<br>  _base: Vue,<br>&#125;;<br></code></pre></td></tr></table></figure><p>示例中 options 并没有指定 super 属性，因此该方法直接 return options</p><p>回到 mergeOptions, 一个参 parent 即 Vue.options, 第二个参 child 是构造函数的入参，第三个是 Vue 实例。</p><p>首先是调用 checkComponents(child)，对 components 中声明的名称做格式上的校验，必须符合 html5 标准，并且不能使用内置的 html 标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkComponents</span>(<span class="hljs-params">options</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> options.components) &#123;<br>    validateComponentName(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接着是对 props、inject、directives 这些参数进行格式化，最后都形成对象的形式。</p><p>下面开始真正的合并。</p><p>第一步，将尚未合并过的 child 中的 extend 和 mixins 属性合并到 parent 中。<br>第二步，按顺序将 parent 和 child 的属性存入到声明的空对象 options 中。</p><p>需要注意的是在对 child 处理时，只对 parent 中不存在的属性做合并，可以避免对 Vue.options 属性的覆盖</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (key <span class="hljs-keyword">in</span> child) &#123;<br>  <span class="hljs-keyword">if</span> (!hasOwn(parent, key)) &#123;<br>    mergeField(key);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来重点看下 mergeField 方法，这个是整个合并策略的核心</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeField</span>(<span class="hljs-params">key</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> strat = strats[key] || defaultStrat;<br>  options[key] = strat(parent[key], child[key], vm, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>总的来说，strats 就是一个对象，它的属性是一个个用来处理不同类型属性的策略方法。</p><p>除了 strats，还有一个默认策略方法 defaultStrat</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> defaultStrat = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> childVal === <span class="hljs-literal">undefined</span> ? parentVal : childVal;<br>&#125;;<br></code></pre></td></tr></table></figure><p>逻辑很简单：如果 childVal 存在，返回 childVal，否则返回 parentVal。</p><p>以下是 strats 的策略方法：</p><h4 id="1、el，propsData"><a href="#1、el，propsData" class="headerlink" title="1、el，propsData"></a>1、el，propsData</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.el = strats.propsData = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parent, child, vm, key</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-comment">// 使用默认策略</span><br>  <span class="hljs-keyword">return</span> defaultStrat(parent, child);<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2、data"><a href="#2、data" class="headerlink" title="2、data"></a>2、data</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.data = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal, vm</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (!vm) &#123;<br>    <span class="hljs-keyword">if</span> (childVal &amp;&amp; <span class="hljs-keyword">typeof</span> childVal !== <span class="hljs-string">"function"</span>) &#123;<br>      warn(<br>        <span class="hljs-string">'The "data" option should be a function '</span> +<br>          <span class="hljs-string">"that returns a per-instance value in component "</span> +<br>          <span class="hljs-string">"definitions."</span>,<br>        vm<br>      );<br><br>      <span class="hljs-keyword">return</span> parentVal;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mergeDataOrFn(parentVal, childVal);<br>  &#125;<br>  <span class="hljs-keyword">return</span> mergeDataOrFn(parentVal, childVal, vm);<br>&#125;;<br></code></pre></td></tr></table></figure><p>mergeDataOrFn 返回的方法里会调用 mergeData 方法，我们跳过直接看 mergeData</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeData</span>(<span class="hljs-params">to, from</span>) </span>&#123;<br>  <span class="hljs-comment">// 如果不存在子项，直接返回父项</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">from</span>) &#123;<br>    <span class="hljs-keyword">return</span> to;<br>  &#125;<br>  <span class="hljs-keyword">var</span> key, toVal, fromVal;<br><br>  <span class="hljs-keyword">var</span> keys = hasSymbol ? <span class="hljs-built_in">Reflect</span>.ownKeys(<span class="hljs-keyword">from</span>) : <span class="hljs-built_in">Object</span>.keys(<span class="hljs-keyword">from</span>);<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>    key = keys[i];<br>    <span class="hljs-comment">// 如果属性已经被 oberved， 则直接跳过</span><br>    <span class="hljs-keyword">if</span> (key === <span class="hljs-string">"__ob__"</span>) &#123;<br>      <span class="hljs-keyword">continue</span>;<br>    &#125;<br>    toVal = to[key];<br>    fromVal = <span class="hljs-keyword">from</span>[key];<br>    <span class="hljs-comment">// 如果父项没有当前属性，则开启合并(覆盖)</span><br>    <span class="hljs-keyword">if</span> (!hasOwn(to, key)) &#123;<br>      <span class="hljs-keyword">set</span>(to, key, fromVal);<br>    &#125; else if (<br>      // 如果当前父属性和子属性都为对象且不相等，则递归合并(覆盖)<br>      toVal !== fromVal &amp;&amp;<br>      isPlainObject(toVal) &amp;&amp;<br>      isPlainObject(fromVal)<br>    ) &#123;<br>      mergeData(toVal, fromVal);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> to;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、声明周期钩子"><a href="#3、声明周期钩子" class="headerlink" title="3、声明周期钩子"></a>3、声明周期钩子</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js">LIFECYCLE_HOOKS.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">hook</span>) </span>&#123;<br>  strats[hook] = mergeHook;<br>&#125;);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeHook</span>(<span class="hljs-params">parentVal, childVal</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = childVal<br>    ? parentVal<br>      ? parentVal.concat(childVal)<br>      : <span class="hljs-built_in">Array</span>.isArray(childVal)<br>      ? childVal<br>      : [childVal]<br>    : parentVal;<br>  <span class="hljs-keyword">return</span> res ? dedupeHooks(res) : res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dedupeHooks</span>(<span class="hljs-params">hooks</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = [];<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; hooks.length; i++) &#123;<br>    <span class="hljs-keyword">if</span> (res.indexOf(hooks[i]) === <span class="hljs-number">-1</span>) &#123;<br>      res.push(hooks[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure><p>mergeHook 中 parentVal 和 childVal 处理后 res 情况如下：</p><ul><li>childVal 存在<ul><li>parentVal 存在，将 childVal 合并进 parentVal 中</li><li>parentVal 不存在，保证 childVal 为数组或处于数组中</li></ul></li><li>childVal 不存在，则返回 parentVal</li></ul><p>res 可能存在重复的 hook，所以 dedupeHooks 坐了一个去重<br>mergeHook 最后返回的值就是一个包含合并后生命周期钩子的数组</p><h4 id="4、components-directives-filters"><a href="#4、components-directives-filters" class="headerlink" title="4、components, directives, filters"></a>4、components, directives, filters</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">ASSET_TYPES.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) </span>&#123;<br>  strats[type + <span class="hljs-string">"s"</span>] = mergeAssets;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这三类都采用 mergeAssets 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeAssets</span>(<span class="hljs-params">parentVal, childVal, vm, key</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> res = <span class="hljs-built_in">Object</span>.create(parentVal || <span class="hljs-literal">null</span>);<br>  <span class="hljs-keyword">if</span> (childVal) &#123;<br>    assertObjectType(key, childVal, vm);<br>    <span class="hljs-keyword">return</span> extend(res, childVal);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> res;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>只有 childVal 存在时，才会执行合并(覆盖)操作，否则只返回 parentVal 原型链下级对象</p><h4 id="5、watch"><a href="#5、watch" class="headerlink" title="5、watch"></a>5、watch</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.watch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal, vm, key</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (!childVal) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.create(parentVal || <span class="hljs-literal">null</span>);<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-keyword">if</span> (!parentVal) &#123;<br>    <span class="hljs-keyword">return</span> childVal;<br>  &#125;<br>  <span class="hljs-keyword">var</span> ret = &#123;&#125;;<br>  extend(ret, parentVal);<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key$<span class="hljs-number">1</span> <span class="hljs-keyword">in</span> childVal) &#123;<br>    <span class="hljs-keyword">var</span> parent = ret[key$<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">var</span> child = childVal[key$<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (parent &amp;&amp; !<span class="hljs-built_in">Array</span>.isArray(parent)) &#123;<br>      parent = [parent];<br>    &#125;<br>    ret[key$<span class="hljs-number">1</span>] = parent<br>      ? parent.concat(child)<br>      : <span class="hljs-built_in">Array</span>.isArray(child)<br>      ? child<br>      : [child];<br>  &#125;<br>  <span class="hljs-keyword">return</span> ret;<br>&#125;;<br></code></pre></td></tr></table></figure><p>watch 合并后的对象 ret 的值是数组，保证每一个 key 可以包含多个 watcher，而且 watcher 不能被覆盖，因此这里不会有去重操作</p><h4 id="6、props，methods，inject"><a href="#6、props，methods，inject" class="headerlink" title="6、props，methods，inject"></a>6、props，methods，inject</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js">strats.props =<br>strats.methods =<br>strats.inject =<br>strats.computed =<br><span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">parentVal, childVal, vm, key</span>) </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-comment">// 如果 parentVal 不存在，直接返回 childVal</span><br><span class="hljs-keyword">if</span> (!parentVal) &#123;<br><span class="hljs-keyword">return</span> childVal;<br>&#125;<br><span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">// 将 parentVal 的属性存入 ret 中</span><br>extend(ret, parentVal);<br><span class="hljs-comment">// 如果 childVal 存在，将 childVal 的属性存入 ret 中</span><br><span class="hljs-keyword">if</span> (childVal) &#123;<br>extend(ret, childVal);<br>&#125;<br><span class="hljs-comment">// 返回 ret</span><br><span class="hljs-keyword">return</span> ret;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="7、provide-采用-mergeDataOrFn"><a href="#7、provide-采用-mergeDataOrFn" class="headerlink" title="7、provide 采用 mergeDataOrFn"></a>7、provide 采用 mergeDataOrFn</h4><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>以上，我们梳理了在使用 Vue 时，它自身都做了哪些工作。并且着重解析了 options 中属性合并策略，简单总结一下：</p><p>1、el、propsData</p><ul><li>如果 child 不存在，返回 parent，否则返回 child</li></ul><p>2、data、provide</p><ul><li>如果 child 不存在，返回 parent</li><li>如果 parent 存在，遍历 child 的属性，<ul><li>如果 parent 不存在该属性，则将属性赋予 parent</li><li>如果 parent 存在该属性，并且 parentVal 与 childVal 同为对象且不相等，则递归合并 parentVal 与 childVal</li></ul></li></ul><p>3、components, directives, filters<br>如果 child 存在，合并 child 属性至新对象中，否则返回空对象</p><p>4、props，methods，inject，computed</p><ul><li>如果 parent 不存在，返回 child</li><li>如果 parent 存在或 child 存在，将各自的属性赋予返回的新对象中</li></ul><p>5、watch 和 LIFECYCLE_HOOKS<br>相同点：如果 parent 和 child 存在，保证它们都是数组形式，将 child 并入 到 parent 中<br>不同点：LIFECYCLE_HOOKS 最后的结果需要去重，而 watch 不用</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>axios-总体结构</title>
    <link href="/2021/04/06/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <url>/2021/04/06/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><strong>本文基于 axios 版本 0.21.1</strong></p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p>在根目录下找到 index.js，里面只有一句代码，将 axios 进行导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./lib/axios'</span>);<br></code></pre></td></tr></table></figure><p>找到 lib 下的 axios.js 文件</p><ul><li><p>首先引入了相关文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 工具函数库</span><br><span class="hljs-keyword">var</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils'</span>);<br><span class="hljs-comment">// bind 方法，返回 function wrap</span><br><span class="hljs-keyword">var</span> bind = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers/bind'</span>);<br><span class="hljs-comment">// Axios 构造函数</span><br><span class="hljs-keyword">var</span> Axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/Axios'</span>);<br><span class="hljs-comment">// 合并参数</span><br><span class="hljs-keyword">var</span> mergeConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/mergeConfig'</span>);<br><span class="hljs-comment">// 默认设置和属性</span><br><span class="hljs-keyword">var</span> defaults = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./defaults'</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建 axios 实例的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createInstance</span> (<span class="hljs-params">defaultConfig</span>) </span>&#123;<br><span class="hljs-comment">// 创建 Axios 实例</span><br><span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> Axios(defaultConfig);<br><br><span class="hljs-keyword">var</span> instance = bind(Axios.prototype.request, context);<br>utils.extend(instance, Axios.prototype, context);<br>utils.extend(instance, context);<br><br><span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><p>​bind 方法代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span> (<span class="hljs-params">fn, thisArg</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> args = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-built_in">arguments</span>.length);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; args.length; i++) &#123;<br>args[i] = <span class="hljs-built_in">arguments</span>[i];<br>&#125;<br><span class="hljs-keyword">return</span> fn.apply(thisArg, args);<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>  bind 方法的逻辑很简单，就是返回 一个wrap 函数，函数内部会使用 context 调用 Axios.prototype.request。bind执行完后就将 Axios.prototype 和 context 的属性赋值给 wrap 函数。<br>  在该文件后续部分我们可以看到以下两行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">var</span> axios = createInstance(defaults);<br><span class="hljs-built_in">module</span>.exports = axios;<br></code></pre></td></tr></table></figure><p>执行 createInstance 方法返回的 instance 赋值给了 axios，那么 axios 的值就是 wrap 函数，这也就是为什么我们使用 axios 时，既可以调用它的方法，也可以直接执行它的原因。</p></li></ul><p>到这里，我们明白了 axios 是什么以及如何创建它的实例。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>前面的处理将 Axios 相关属性赋予给了 wrap 函数，那到底是哪些属性呢？该小节将会详细了解下构造函数 Axios。</p><p><strong>文件位于  axios/core/Axios</strong></p><p>首先引入所需依赖，大概知道是干什么的就行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 对请求路径进行一些格式化</span><br><span class="hljs-keyword">var</span> buildURL = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers/buildURL'</span>);<br><span class="hljs-comment">// 拦截器构造函数</span><br><span class="hljs-keyword">var</span> InterceptorManager = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./InterceptorManager'</span>);<br><span class="hljs-comment">// 发起 request 请求</span><br><span class="hljs-keyword">var</span> dispatchRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dispatchRequest'</span>);<br></code></pre></td></tr></table></figure><p>接着往下看</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Axios</span> (<span class="hljs-params">instanceConfig</span>) </span>&#123;<br><span class="hljs-keyword">this</span>.defaults = instanceConfig;<br><span class="hljs-comment">// 拦截器对象</span><br><span class="hljs-keyword">this</span>.interceptors = &#123;<br>request: <span class="hljs-keyword">new</span> InterceptorManager(),<br>response: <span class="hljs-keyword">new</span> InterceptorManager()<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在创建实例时可接收一个配置参数</li><li>将接收的配置赋值给自身的 defaults 属性</li><li>拥有一个 拦截器对象，该对象包括请求拦截器和相应拦截器</li><li>拦截器实例是在创建 Axios 实例时才会创建</li></ul><h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在日常使用中，拦截器的配置是最重要的一部分。我们通过上方路径找到拦截器构造函数文件。</p><p>​        构造函数拥有一个 handlers 数组，用来存储拦截器。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InterceptorManager</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">this</span>.handlers = [];<br>&#125;<br></code></pre></td></tr></table></figure><p>​然后给构造函数原型添加方法函数</p><ol><li><p>使用 use 方法添加一个新的拦截器，</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js">InterceptorManager.prototype.use = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">use</span> (<span class="hljs-params">fulfilled, rejected, options</span>) </span>&#123;<br><span class="hljs-keyword">this</span>.handlers.push(&#123;<br>fulfilled: fulfilled,<br>rejected: rejected,<br>synchronous: options ? options.synchronous : <span class="hljs-literal">false</span>,<br>runWhen: options ? options.runWhen : <span class="hljs-literal">null</span><br>&#125;);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handlers.length - <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>每个拦截器包括四个属性：<ol><li>fulfilled：一个方法，在请求或相应被 then 处理前执行</li><li>rejected：一个方法，在请求或相应被 reject 处理前执行</li><li>synchronous：请求拦截器是否采用同步执行机制</li><li>runwhen：表明请求拦截器什么情况下执行。默认为 null，也可以是一个函数。</li></ol></li><li>use 方法返回当前拦截器在拦截器数组中的位置下标</li></ol></li><li><p>使用 eject 方法清除一个拦截器。参数 id 就是拦截器在数组中的下标。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">InterceptorManager.prototype.eject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eject</span> (<span class="hljs-params">id</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlers[id]) &#123;<br><span class="hljs-comment">// 将下标为 id 处的拦截器置为 null</span><br><span class="hljs-keyword">this</span>.handlers[id] = <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 forEach 方法执行符合条件的拦截器</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">InterceptorManager.prototype.forEach = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span> (<span class="hljs-params">fn</span>) </span>&#123;<br><span class="hljs-comment">// 遍历拦截器存储数组，执行 fn 时会过滤掉数组中被置为 null 的值。</span><br>utils.forEach(<span class="hljs-keyword">this</span>.handlers, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachHandler</span> (<span class="hljs-params">h</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (h !== <span class="hljs-literal">null</span>) &#123;<br>fn(h);<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="挂载方法"><a href="#挂载方法" class="headerlink" title="挂载方法"></a>挂载方法</h3><p>构造函数内部添加完属性后，紧接着就是在构造函数原型上添加相应方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 为 Axios 原型挂载 request 和 getUri 方法</span><br>Axios.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;<br>Axios.prototype.getUri = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUri</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;<br><br><span class="hljs-comment">// 为 Axios 原型挂载支持的 method</span><br>utils.forEach([<span class="hljs-string">'delete'</span>, <span class="hljs-string">'get'</span>, <span class="hljs-string">'head'</span>, <span class="hljs-string">'options'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodNoData</span> (<span class="hljs-params">method</span>) </span>&#123;<br>Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, config</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<br>method: method,<br>url: url,<br><span class="hljs-comment">// 使用这些 method时，有可能不会传 data 属性，所以使用默认的 data</span><br>data: (config || &#123;&#125;).data <br>&#125;));<br>&#125;;<br>&#125;);<br>utils.forEach([<span class="hljs-string">'post'</span>, <span class="hljs-string">'put'</span>, <span class="hljs-string">'patch'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodWithData</span> (<span class="hljs-params">method</span>) </span>&#123;<br>Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, data, config</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<br>method: method,<br>url: url,<br>data: data<br>&#125;));<br>&#125;;<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中包括 HTTP 请求同名的方法 。这些方法会被代理给原型的 request 方法，Axios 将支持的请求的 methods 按照是否需要默认 data 属性分为两类，现在来看看 request 方法的实现。</p><h3 id="request"><a href="#request" class="headerlink" title="request"></a>request</h3><ul><li><p>首先是基本参数的一个默认设置以及合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 兼容 axios('example/url'[, config]) 这种传参方式</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> config === <span class="hljs-string">'string'</span>) &#123;<br>    config = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>] || &#123;&#125;;<br>    config.url = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>];<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    config = config || &#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 合并 config</span><br>config = mergeConfig(<span class="hljs-keyword">this</span>.defaults, config);<br><br><span class="hljs-comment">// 设置 config.method， 默认小写，默认 get 方法</span><br><span class="hljs-keyword">if</span> (config.method) &#123;<br>    config.method = config.method.toLowerCase();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.defaults.method) &#123;<br>    config.method = <span class="hljs-keyword">this</span>.defaults.method.toLowerCase();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    config.method = <span class="hljs-string">'get'</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对拦截器队列的处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 请求拦截器队列</span><br><span class="hljs-keyword">var</span> requestInterceptorChain = [];<br><span class="hljs-comment">// 请求拦截器是否同步执行</span><br><span class="hljs-keyword">var</span> synchronousRequestInterceptors = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">this</span>.interceptors.request.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unshiftRequestInterceptors</span> (<span class="hljs-params">interceptor</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> interceptor.runWhen === <span class="hljs-string">'function'</span> &amp;&amp; interceptor.runWhen(config) === <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为 interceptor.synchronous 默认为 false，所以 synchronousRequestInterceptors 默认为 false，</span><br>    synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous;<br><br>    <span class="hljs-comment">// 每个拦截器由执行成功和执行失败处理方法组成</span><br>    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);<br>&#125;);<br><br><span class="hljs-comment">// 响应拦截器链</span><br><span class="hljs-keyword">var</span> responseInterceptorChain = [];<br><br><span class="hljs-keyword">this</span>.interceptors.response.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushResponseInterceptors</span> (<span class="hljs-params">interceptor</span>) </span>&#123;<br>    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>请求拦截器 执行机制的处理</p><p>​        请求拦截器 执行机制由上面的 synchronousRequestInterceptors 决定，分为 异步和同步两种。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> promise;<br><br><span class="hljs-comment">// 异步执行</span><br><span class="hljs-keyword">if</span> (!synchronousRequestInterceptors) &#123;<br><span class="hljs-comment">// 调用处理方法队列</span><br>    <span class="hljs-keyword">var</span> chain = [dispatchRequest, <span class="hljs-literal">undefined</span>];<br><span class="hljs-comment">// 将请求拦截器处理方法和响应拦截器处理方法分别放入队列前后</span><br>    <span class="hljs-built_in">Array</span>.prototype.unshift.apply(chain, requestInterceptorChain);<br>    chain.concat(responseInterceptorChain);<br><br>    promise = <span class="hljs-built_in">Promise</span>.resolve(config);<br>    <span class="hljs-comment">// 将包含了请求拦截器的 chain 交给 promise 来处理  </span><br>    <span class="hljs-keyword">while</span> (chain.length) &#123;<br>        promise = promise.then(chain.shift(), chain.shift());<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br><br><span class="hljs-comment">// 同步执行</span><br><span class="hljs-keyword">var</span> newConfig = config;<br><br><span class="hljs-comment">// 先一次性执行完请求拦截器</span><br><span class="hljs-keyword">while</span> (requestInterceptorChain.length) &#123;<br>    <span class="hljs-keyword">var</span> onFulfilled = requestInterceptorChain.shift();<br>    <span class="hljs-keyword">var</span> onRejected = requestInterceptorChain.shift();<br>    <span class="hljs-keyword">try</span> &#123;<br>        newConfig = onFulfilled(newConfig);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        onRejected(error);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 再异步执行 dispatchRequest（如 XHR），</span><br>    promise = dispatchRequest(newConfig);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(error);<br>&#125;<br><span class="hljs-comment">// 最后异步执行响应拦截器</span><br><span class="hljs-keyword">while</span> (responseInterceptorChain.length) &#123;<br>    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());<br>&#125;<br><br><span class="hljs-keyword">return</span> promise;<br></code></pre></td></tr></table></figure><p>对拦截器处理的总结：</p><ul><li>存在三个 chain：请求拦截器 requestInterceptorChain 、响应拦截器 responseInterceptorChain、真正的 request 调用 originChain</li><li>拦截器以成对的形式存在，放入对应的拦截器 chain 中</li><li>请求拦截器对依次插入到 chain 头；相应拦截器对依次插入到 chain 尾</li><li>请求拦截器可以同步执行也可以异步执行：<ul><li>如果是异步执行，则会将requestInterceptorChain 插入到 originChain 队头，将 responseInterceptorChain 插入到 originChain 队尾；然后对 originChain 内的元素放入 promise.then 中执行</li><li>如果是同步执行，则会将 requestInterceptorChain 内的元素以迭代的方式执行完毕，然后执行 originChain 内的 request，最后将 responseInterceptorChain 内的元素放入 promise.then 中执行</li></ul></li></ul><p>最后通过一张图来理解请求拦截器处理不同的机制</p></li></ul><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/axios_%E6%89%A7%E8%A1%8C%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt="axios 执行图"></p>]]></content>
    
    
    <categories>
      
      <category>Axios</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析 generator 与 async 原理</title>
    <link href="/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h2 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h2><p>geneartor 和 async 都是 js 处理异步操作发展历程的产物，它们让异步编程越来越像同步编程。但是由于采用新的语法、关键字，它们是如何做到“类同步”操作的，我们不得而知，因此这篇文章将会窥探内部的秘密。</p><p>下面将借助 babel 本地编译示例代码来进行分析。</p><h2 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h2><p> 一、全局安装 regenerator</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i regenerator -g<br></code></pre></td></tr></table></figure><p> 二、编译 generator</p><p>​    命令加上 –include-runtime，可以得到完整的编译代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">regenerator --include-runtime test.js &gt; test-fill.js<br></code></pre></td></tr></table></figure><p>test-fill.js 就是编译后的代码文件。</p><h2 id="解析-generator"><a href="#解析-generator" class="headerlink" title="解析 generator"></a>解析 generator</h2><p>现在有如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">let</span> gen = genFn();<br>gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>调用 genFn 并不会直接执行，而是会返回一个 generator 对象，每次调用它的 next 方法会执行一个 yield 语句，并返回当前的值及状态。</p><p>这是编译后的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> _marked = <span class="hljs-comment">/*#__PURE__*/</span>regeneratorRuntime.mark(genFn);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>_context.next = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>_context.next = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>_context.next = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<br><span class="hljs-keyword">return</span> _context.stop();<br>&#125;<br>&#125;<br>&#125;, _marked);<br>&#125;<br><br><span class="hljs-keyword">var</span> g = genFn();<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br></code></pre></td></tr></table></figure><p>可以看到 genFn 被改写了，调用 regeneratorRuntime.wrap 方法创建，其中传给 wrap 方法的 genFn$ 函数，里面的逻辑很简单，是一个永远都会执行的迭代，里面 switch 中的 case 是原代码中 yield 关键字所在的行数，genFn$ 的参数 _context 记录了原代码的执行上下文内容，每次调用 next 方法，实际上就会调用 genFn$，然后执行对应的逻辑。</p><p>大致的流程弄清楚之后，再来看看 regeneratorRuntime。</p><p>wrap 方法第二个参是 mark(genFn) 的值， mark 方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> $<span class="hljs-built_in">Symbol</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"function"</span> ? <span class="hljs-built_in">Symbol</span> : &#123;&#125;;<br><span class="hljs-keyword">var</span> iteratorSymbol = $<span class="hljs-built_in">Symbol</span>.iterator || <span class="hljs-string">"@@iterator"</span>;<br><br><span class="hljs-keyword">var</span> toStringTagSymbol = $<span class="hljs-built_in">Symbol</span>.toStringTag || <span class="hljs-string">"@@toStringTag"</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GeneratorFunctionPrototype</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-keyword">var</span> IteratorPrototype = &#123;&#125;;<br>IteratorPrototype[iteratorSymbol] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;;<br>GeneratorFunctionPrototype.prototype = <span class="hljs-built_in">Object</span>.create(IteratorPrototype);<br><br>exports.mark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">genFun</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.setPrototypeOf) &#123;<br><span class="hljs-built_in">Object</span>.setPrototypeOf(genFun, GeneratorFunctionPrototype);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>genFun.__proto__ = GeneratorFunctionPrototype;<br>define(genFun, toStringTagSymbol, <span class="hljs-string">"GeneratorFunction"</span>);<br>&#125;<br>genFun.prototype = <span class="hljs-built_in">Object</span>.create(Gp);<br><span class="hljs-keyword">return</span> genFun;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>IteratorPrototype 对象添加 Symbol.iterator属性，使得 IteratorPrototype 拥有 Iterator 接口</li><li>GeneratorFunctionPrototype 函数的原型指向 IteratorPrototype ，所以 GeneratorFunctionPrototype 也拥有 Iterator 接口</li><li>genFun 的   <strong>proto</strong>  指向 GeneratorFunctionPrototype ，同理 genFun  拥有 Iterator 接口</li><li>mark 返回 genFun</li></ol><p>也就是说 mark 方法返回一个拥有 Iterator 接口 genFun。现在看下 wrap 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span> (<span class="hljs-params">innerFn, outerFn, self, tryLocsList</span>) </span>&#123;<br><span class="hljs-comment">// 确保 protoGenerator 拥有 Itrator 接口</span><br><span class="hljs-keyword">var</span> protoGenerator = outerFn &amp;&amp; outerFn.prototype <span class="hljs-keyword">instanceof</span> Generator ? outerFn : Generator;<br><span class="hljs-keyword">var</span> generator = <span class="hljs-built_in">Object</span>.create(protoGenerator.prototype);<br><span class="hljs-comment">// context 即 genFn$ 的参数 _context </span><br><span class="hljs-keyword">var</span> context = <span class="hljs-keyword">new</span> Context(tryLocsList || []);<br><br><span class="hljs-comment">// ._invoke 方法整合了 next、throw 和 return 方法</span><br>generator._invoke = makeInvokeMethod(innerFn, self, context);<br><br><span class="hljs-keyword">return</span> generator;<br>&#125;<br><br><span class="hljs-comment">// _invoke 即内部的 invoke</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeInvokeMethod</span> (<span class="hljs-params">innerFn, self, context</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg</span>) </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看看 _invoke 在哪儿调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> Gp = GeneratorFunctionPrototype.prototype = Generator.prototype<br><br>defineIteratorMethods(Gp);<br><span class="hljs-comment">// 为 Generator 添加 prototype 添加 next、throw、return 方法</span><br><span class="hljs-comment">// 并且这些方法都会调用 _invoke 方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineIteratorMethods</span> (<span class="hljs-params">prototype</span>) </span>&#123;<br>[<span class="hljs-string">"next"</span>, <span class="hljs-string">"throw"</span>, <span class="hljs-string">"return"</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method</span>) </span>&#123;<br>define(prototype, method, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arg</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._invoke(method, arg);<br>&#125;);<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些弄明白之后，可以简单理一下编译后代码的执行步骤：</p><ol><li>var g = genFn();<ol><li>genFn() 返回 generator 对象，拥有 _invoke 方法</li><li>g 拥有 _invoke</li></ol></li><li>g.next();<ol><li>g 的 next 方法会调用 _invoke 方法</li><li>g.next()  ==&gt;  g._invoke();</li></ol></li></ol><p>到这里就可以去看看 invoke 是如何实现的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs js"><br><span class="hljs-comment">// 四种状态：开始、执行中、暂停执行、结束</span><br><span class="hljs-keyword">var</span> GenStateSuspendedStart = <span class="hljs-string">"suspendedStart"</span>;<br><span class="hljs-keyword">var</span> GenStateExecuting = <span class="hljs-string">"executing"</span>;<br><span class="hljs-keyword">var</span> GenStateSuspendedYield = <span class="hljs-string">"suspendedYield"</span>;<br><span class="hljs-keyword">var</span> GenStateCompleted = <span class="hljs-string">"completed"</span>;<br><br><span class="hljs-comment">// generator 方法执行的状态</span><br><span class="hljs-keyword">var</span> state = GenStateSuspendedStart;<br><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg</span>) </span>&#123;<br><span class="hljs-comment">// 方法体内的语句执行过程中不允许继续执行</span><br>    <span class="hljs-keyword">if</span> (state === GenStateExecuting) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">"Generator is already running"</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (state === GenStateCompleted) &#123;<br>        <span class="hljs-keyword">if</span> (method === <span class="hljs-string">"throw"</span>) &#123;<br>            <span class="hljs-keyword">throw</span> arg;<br>        &#125;<br>    &#125;<br><br>    context.method = method;<br>    context.arg = arg;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 省略容错逻辑</span><br>        <br>        state = GenStateExecuting;<br><br><span class="hljs-comment">// fn.call(obj, arg)</span><br><span class="hljs-comment">// fn 即 genFn$，arg 即为 context</span><br><span class="hljs-comment">//function tryCatch (fn, obj, arg) &#123;</span><br>        <span class="hljs-comment">//    try &#123;</span><br>        <span class="hljs-comment">//        return &#123; type: "normal", arg: fn.call(obj, arg) &#125;;</span><br>        <span class="hljs-comment">//    &#125; catch (err) &#123;</span><br>        <span class="hljs-comment">//        return &#123; type: "throw", arg: err &#125;;</span><br>        <span class="hljs-comment">//    &#125;</span><br>        <span class="hljs-comment">//&#125;</span><br>       <br>       <span class="hljs-comment">// 在这里调用 genFn$ 方法</span><br>        <span class="hljs-keyword">var</span> record = tryCatch(innerFn, self, context);<br>        <br>        <span class="hljs-keyword">if</span> (record.type === <span class="hljs-string">"normal"</span>) &#123; <span class="hljs-comment">// 执行 genFn$ 成功会走如下逻辑</span><br>        <span class="hljs-comment">// 如果语句执行完毕则结束执行，否则暂停执行</span><br>        state = context.done<br>                    ? GenStateCompleted<br>                    : GenStateSuspendedYield;<br>            <span class="hljs-comment">// 返回执行 yield 的结果</span><br>            <span class="hljs-keyword">return</span> &#123;<br>                value: record.arg,<br>                done: context.done<br>            &#125;;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (record.type === <span class="hljs-string">"throw"</span>) &#123; <span class="hljs-comment">// 遇到错误则将方法改为 throw，进入下一个循环执行容错逻辑</span><br>            state = GenStateCompleted;<br>            context.method = <span class="hljs-string">"throw"</span>;<br>            context.arg = record.arg;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>invoke 通过调用的方法进行不同的操作。遇到  throw 直接 throw 错误；遇到 return 会去 complete generator；遇到 next，就会调用 genFn$ 方法，最终返回一个 value 和 done 属性的对象。</p><h2 id="解析-async"><a href="#解析-async" class="headerlink" title="解析 async"></a>解析 async</h2><p>对于 async 函数，依然使用上面的方法进行编译处理。async 编译后的代码与 generator 编译后的 regeneratorRuntime 对象是一样的，因此我们只需要关注不同点就可以了。</p><p>编译前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-number">2</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> p();<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>asyncFn();<br><span class="hljs-comment">// 2 1 1</span><br></code></pre></td></tr></table></figure><p>编译后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>resolve(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> a, b, c;<br><span class="hljs-keyword">return</span> regeneratorRuntime.async(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>_context.next = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(p());<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>a = _context.sent;<br>_context.next = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>b = _context.sent;<br>_context.next = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>c = _context.sent;<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br><span class="hljs-built_in">console</span>.log(c);<br><span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<br><span class="hljs-keyword">return</span> _context.stop();<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-built_in">Promise</span>);<br>&#125;<br><br>asyncFn();<br></code></pre></td></tr></table></figure><p>与 generator 编译之后的代码基本相同，不同的是</p><ol><li>调用的是 regeneratorRuntime.async 方法，接收4个参，其中最后一个是 Promise</li><li>内部方法 return  regeneratorRuntime.awrap, 即将 await xx 改为 regeneratorRuntime.awrap(xx)</li></ol><p>按照顺序，先来看看 async 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js">exports.async = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">innerFn, outerFn, self, tryLocsList, PromiseImpl</span>) </span>&#123;<br><span class="hljs-comment">// 确保 PromiseImpl 是 Promise</span><br>    <span class="hljs-keyword">if</span> (PromiseImpl === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) PromiseImpl = <span class="hljs-built_in">Promise</span>;<br>    <br>    <span class="hljs-keyword">var</span> iter = <span class="hljs-keyword">new</span> AsyncIterator(<br>    <span class="hljs-comment">// wrap 方法返回一个 generator 对象</span><br>        wrap(innerFn, outerFn, self, tryLocsList),<br>        PromiseImpl<br>    );<br><span class="hljs-comment">// iter.next() 是一个 promise 对象</span><br>    <span class="hljs-keyword">return</span> exports.isGeneratorFunction(outerFn)<br>        ? iter<br>        : iter.next().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;   <br>            <span class="hljs-keyword">return</span> result.done ? result.value : iter.next();<br>        &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>new AsyncIterator 内部做了些什么工作呢？简化之后就很明了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AsyncIterator</span> (<span class="hljs-params">generator, PromiseImpl</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg, resolve, reject</span>) </span>&#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueue</span> (<span class="hljs-params">method, arg</span>) </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callInvokeWithMethodAndArg</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// 返回 promise 实例</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PromiseImpl(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>                invoke(method, arg, resolve, reject);<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">var</span> previousPromise;<br>        <span class="hljs-keyword">return</span> previousPromise = callInvokeWithMethodAndArg();<br>    &#125;<br>    <span class="hljs-keyword">this</span>._invoke = enqueue;<br>&#125;<br></code></pre></td></tr></table></figure><p>defineIteratorMethods 方法将 next(还有 throw、return) 方法代理给了 _invoke，所以 iter.next() 会调用_invoke，即 enqueue，而 enqueue 返回一个 promise 实例，因此可以调用 then 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">iter.next().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;   <br>    <span class="hljs-keyword">return</span> result.done ? result.value : iter.next();<br>&#125;)<br></code></pre></td></tr></table></figure><p>这段是控制 await 顺序执行的开始和结束</p><p>首先执行 iter.next()，相当于执行  enqueue，进而执行 invoke。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> (<span class="hljs-params">method, arg, resolve, reject</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> record = tryCatch(generator[method], generator, arg);<br>    <span class="hljs-keyword">if</span> (record.type === <span class="hljs-string">"throw"</span>) &#123;<br>        reject(record.arg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">var</span> result = record.arg;<br>        <span class="hljs-keyword">var</span> value = result.value;<br>        <span class="hljs-keyword">if</span> (value &amp;&amp;<br>            <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">"object"</span> &amp;&amp;<br>            hasOwn.call(value, <span class="hljs-string">"__await"</span>)) &#123;<br>            <span class="hljs-keyword">return</span> PromiseImpl.resolve(value.__await).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>                invoke(<span class="hljs-string">"next"</span>, value, resolve, reject);<br>            &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>                invoke(<span class="hljs-string">"throw"</span>, err, resolve, reject);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> PromiseImpl.resolve(value).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">unwrapped</span>) </span>&#123;<br>            result.value = unwrapped;<br>            resolve(result);<br>        &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;<br>            <span class="hljs-keyword">return</span> invoke(<span class="hljs-string">"throw"</span>, error, resolve, reject);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行步骤如下：</p><ol><li>var record = tryCatch(generator[method], generator, arg);<ol><li>因为 generator[method] 代理给了 _invoke。因此会执行 return { type: “normal”, arg: <em>fn</em>.call(<em>obj</em>, <em>arg</em>) };所以这里的_invoke 是 generator 的 _invoke，而不是 iter 的_invoke。</li><li>接下来执行 _invoke 的步骤与 generator 函数一样，执行被包裹的函数，最终会返回 {value: xx, done: xx} 对象，但不一样的是，如果函数体没有执行完毕之前，value 是一个对象，有一个 __await 属性。</li></ol></li><li>如果 tryCatch 执行失败，则直接 reject。</li><li>如果执行成功：<ol><li>如果函数体内的 await 还未执行结束，则会将 record.value.__await 值当作参数，递归调用 invoke 方法</li><li>如果函数体执行完毕，此时的 value 是 undefined，将 record 用异步的方式返回，就会执行 iter.next() 的 then 方法内的回调，这里就是直接执行 return result.value。 因此 async 默认返回 undefined。</li></ol></li></ol><p>到这里，我们就简单理解了 generator 和 async 函数内部的工作原理。其中，async 是在 generator 的基础上工作的，它使用递归方式取代多个 next 方法调用。</p><p>奉上一张编译后代码中方法调用的简图以作参考。</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/babel_%E7%BC%96%E8%AF%91_async_generator.png" srcset="/img/loading.gif" lazyload alt="babel 编译 async&amp;generator"></p><h2 id="实现一个简版-async"><a href="#实现一个简版-async" class="headerlink" title="实现一个简版 async"></a>实现一个简版 async</h2><p>通过上面的分析，我们可以知道，async 就是一个不需要手动执行 next 方法的 generator，明白了这点就好动手了。</p><p>先上一个示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span> (<span class="hljs-params">filename, duration</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(filename)<br>            resolve(filename)<br>        &#125;, duration)<br>    &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">let</span> g = genFn();<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><br><span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 4, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 5, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br><span class="hljs-comment">// b.txt   3秒后输出</span><br><span class="hljs-comment">// a.txt   5秒后输出</span><br></code></pre></td></tr></table></figure><p>如上例所示，在实现 async 有2个问题需要解决：</p><ol><li>如何保证异步代码按调用顺序去执行（异步代码默认使用 promise 包裹）</li><li>如何自动调用 next</li></ol><p>先来实现自动调用，首先想到的是声明一个方法，在里面去执行 next 方法，然后递归调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params">genFn</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeNext</span> (<span class="hljs-params">generator</span>) </span>&#123;<br>        <span class="hljs-comment">// 在这里执行 next 方法</span><br>        <span class="hljs-keyword">let</span> result = generator.next();<br>        <span class="hljs-comment">// 如果调用结束就不再继续调用</span><br>        <span class="hljs-keyword">if</span> (result.done === <span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        invokeNext(generator)<br>    &#125;<br><span class="hljs-comment">// 获取遍历器对象</span><br>    <span class="hljs-keyword">let</span> g = genFn.call(<span class="hljs-literal">null</span>);<br>    invokeNext(g)<br>&#125;<br><br><span class="hljs-comment">// 测试一下</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn_</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-comment">// 无异步代码可以按顺序执行</span><br><span class="hljs-comment">// &#123; value: 1, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 2, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 4, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 5, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br><br><span class="hljs-comment">// 对于前面异步代码的执行就会出先问题</span><br></code></pre></td></tr></table></figure><p>js 处理异步操作有多种方式，除了 generator 和 async，我们还有 promise，所以考虑用 promise 来管理每个 next 的调用顺序，事情就变得简单了，完整代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params">genFn</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeNext</span> (<span class="hljs-params">generator</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> value = generator.next();<br>            resolve(value)<br>        &#125;).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(result);<br>            <span class="hljs-keyword">if</span> (result.done === <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果是 promise 对象，则需要在 then 方法回调里去调用下一个 next</span><br>            <span class="hljs-keyword">if</span> (result.value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>                result.value.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    invokeNext(generator)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                invokeNext(generator)<br>            &#125;<br>        &#125;, err =&gt; &#123;<br>            reject(err);<br>        &#125;)<br>    &#125;<br>    <br>    <span class="hljs-keyword">const</span> g = genFn.call(<span class="hljs-literal">null</span>);<br>    invokeNext(g)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Generator</tag>
      
      <tag>Async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弄懂 event loop</title>
    <link href="/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/"/>
    <url>/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-event-loop"><a href="#什么是-event-loop" class="headerlink" title="什么是 event loop"></a>什么是 event loop</h2><p>简单来说，event loop 就是 JavaScript 宿主处理事件执行的一种机制。</p><p>js 以前是专门用来处理浏览器交互的，比如说 DOM 点击事件等，因此被设计成单线程，所谓单线程，就是同一时间只能处理一件事情，这也就保证了页面中一次只能处理一个事件，避免造成交互混乱的问题。</p><p><strong>开始之前，需要明确的是 JavaScript引擎是单线程的，但是 js 运行环境是多线程。因为浏览器是多线程的，除了 js 引擎线程，还包括 GUI 渲染线程、定时器触发线程、HTTP 请求线程以及 DOM 事件触发线程；node也可以使用 child_process 创建多个子线程。</strong></p><p>现在有事件 A 和 B，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> A = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> B = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);<br>&#125;<br><br>A();<br>B();<br></code></pre></td></tr></table></figure><p>按照单线程的要求，需要等到 A 执行完毕，才会执行 B，那么打印顺序会是如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);<br></code></pre></td></tr></table></figure><p>但实际上的顺序是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);<br></code></pre></td></tr></table></figure><p>这就是 event loop 机制在起作用，因为 console.log(‘i am B’) 是同步任务，而 setTimeout 是异步任务，同步任务执行完才会去执行异步任务</p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><ul><li>什么是宏任务和微任务？</li></ul><p>这里有几个概念容易混淆，那就是同步任务和异步任务，宏任务和微任务。js 的代码执行遵循在代码块内从上往下执行的规则，同步任务会依次执行；而异步任务则会分为宏任务和微任务，比如 setTimeout 的第一个参数是宏任务，promise.then 中注册的方法是微任务，会按照宏任务和微任务的执行规则进行执行。</p><ul><li>宏任务和微任务有哪些？</li></ul><p>js 执行的宿主环境有浏览器和 Node,  所以我们通过宿主环境的不同来整理这些异步任务：</p><table><thead><tr><th>宏任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>setTimeout</td><td>√</td><td>√</td></tr><tr><td>setInterval</td><td>√</td><td>√</td></tr><tr><td>setImmediate</td><td>x</td><td>√</td></tr><tr><td>I/O</td><td>√</td><td>√</td></tr><tr><td>requestAnimationFrame</td><td>√</td><td>x</td></tr></tbody></table><table><thead><tr><th>微任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>mutationObserver</td><td>√</td><td>x</td></tr><tr><td>promise</td><td>√</td><td>√</td></tr><tr><td>process.nextTick</td><td>x</td><td>√</td></tr></tbody></table><ul><li>宏任务和微任务的执行顺序</li></ul><p>要点一：一个宏任务里可能会包含多个微任务</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 promise 里的 同步任务'</span>)<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务1'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务2'</span>)<br>&#125;)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 setTimeout 里的 宏任务'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们来分析下这段代码里的宏任务和微任务有哪些：<br>宏任务：setTimeout 的回调<br>微任务：两个 then 方法的回调</p><p>要点二：宏任务是一个一个执行的，而微任务是批量执行的，当前批次微任务没有完成之前，下一个宏任务不会执行</p><p>因此执行顺序是:</p><ol><li>遇到 promise，参数里面的代码是同步的，所有会先执行 console.log(‘我是 promise 里的 同步任务’)</li><li>执行两个 then 方法的回调</li><li>执行 setTimeout 的回调</li></ol><p>即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// console.log('我是 promise 里的 同步任务')</span><br><span class="hljs-comment">// console.log('我是微任务1')</span><br><span class="hljs-comment">// console.log('我是微任务2')</span><br><span class="hljs-comment">// console.log('我是 setTimeout 里的 宏任务')</span><br></code></pre></td></tr></table></figure><h2 id="浏览器下的-event-loop"><a href="#浏览器下的-event-loop" class="headerlink" title="浏览器下的 event loop"></a>浏览器下的 event loop</h2><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/%E6%B5%8F%E8%A7%88%E5%99%A8_event_loop.png" srcset="/img/loading.gif" lazyload alt="浏览器 event loop"></p><p>如图所示，代码执行步骤如下：</p><ol><li>js 在执行代码时，会将代码放入执行栈中，遇到同步任务，会依次执行；遇到如 DOM 点击事件、ajax 以及 定时器等异步任务，浏览器会交给其他辅线程调用 WebApis  进行处理。</li><li>如果 WebApis 处理的异步任务有了结果，就会将该任务推入到回调队列（callback queue）中，回调队列分为宏任务队列和微任务队列。</li><li>一旦执行栈内（stack）的任务执行完成，就会将回调队列里的任务放入执行栈中执行，顺序如下：<ol><li>如果微任务队列中存在任务，则一次性执行所有微任务</li><li>将宏任务队列的第一个任务放入执行栈中执行</li></ol></li></ol><p>以上步骤的循环就是浏览器中的 event loop。</p><p>看一个简单例子感受下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;)<br><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'success'</span>)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback3</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'start'</span>)<br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ol><li>遇到 setTimeout，等待时间到达后将 callback1 放入宏任务队列</li><li>遇到 promise.then，等待时间到达后将 callback2 与 callback3  按顺序放入微任务队列</li><li>执行同步任务 console.log。</li><li>执行完同步任务，将微任务队列里的任务一次性执行</li><li>微任务执行完之后，执行宏任务队列的第一个任务</li></ol><h2 id="node-下的-event-loop"><a href="#node-下的-event-loop" class="headerlink" title="node 下的 event loop"></a>node 下的 event loop</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">   ┌───────────────────────────┐                             <br>┌─&gt;│           timers          │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐                                    <br>│  │     pending callbacks     │                             <br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │       idle, prepare       │<br>│  └─────────────┬─────────────┘      ┌───────────────┐<br>│  ┌─────────────┴─────────────┐      │   incoming:   │<br>│  │           poll            │&lt;─────┤ connections,  │<br>│  └─────────────┬─────────────┘      │   data, etc.  │<br>│  ┌─────────────┴─────────────┐      └───────────────┘<br>│  │           check           │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>└──┤      close callbacks      │<br>   └───────────────────────────┘<br></code></pre></td></tr></table></figure><p>如上图所示，node 中的 event loop 分为6个循环阶段，当 node.js 启动的时候，会初始化 event loop</p><ul><li>timers： 这个阶段执行 setTimeout 和 setInterval 的回调函数</li><li>pending callbacks：在下一个循环中执行 I/O 回调函数</li><li>idle, prepare：只在 node 内部触发</li><li>poll：获取新的 I/O 事件，在适当的时候阻塞在这里</li><li>check：执行 setImmediate 的回调函数</li><li>close callbacks：执行关闭事件的回调函数，如 socket.on(‘close’, … )</li></ul><p>下面主要对 timers、poll、check 三个阶段进行解析：</p><h3 id="一、timers"><a href="#一、timers" class="headerlink" title="一、timers"></a>一、timers</h3><p>timers 阶段的回调函数可能并不会按照设定的时间延迟去执行，因为 event loop 初始化或者其他阶段回调函数的长时间执行会延迟它们的执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAsyncOperation</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-comment">// 假设读取文件需耗时 95ms</span><br>    fs.readFile(<span class="hljs-string">'./a.txt'</span>, callback)<br>&#125;<br><br>cosnt timeoutScheduled = <span class="hljs-built_in">Date</span>.now();<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> delay = <span class="hljs-built_in">Date</span>.now() - timeoutScheduled;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);<br>&#125;, <span class="hljs-number">100</span>)<br><br>someAsyncOperation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> startCallbackTime = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - startCallbackTime &lt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上方示例在 node 里的大致执行步骤如下：</p><ol><li>timer 阶段：因为需要延迟 100ms，所以当前没有 callback 需要执行，进入 pending callback 阶段</li><li>pending callback阶段：没有 I/O 回调需要执行，进入 idle，</li><li>idle 忽略</li><li>poll 阶段：因为此时有 I/O 操作，因此会阻塞在这里，等待95ms至文件读取结束，然后将 callback 放入队列进行执行，耗时10ms。调用结束后，当前队列为空，检查 timers，发现设定时间为95ms，当前运行时间超时了，因此进入 timer 阶段执行回调，所以会打印出”105ms has passed since I was scheduled”</li></ol><h3 id="二、poll"><a href="#二、poll" class="headerlink" title="二、poll"></a>二、poll</h3><p>poll 阶段主要有两个功能：</p><p>1.计算它应该阻塞和轮询 I/O 多长时间</p><p>2.处理该阶段事件</p><p>当 event loop 进入 poll 阶段并且未设定定时器，会出现下面中的某个情况：</p><ul><li>如果 poll 的队列不为空，那么就会遍历队列，并异步执行完所有回调函数，或者执行耗时达到系统设定的最大时间</li><li>如果 poll 队列为空，那以下情况中的一个会出现：<ol><li>如果代码设定了 setImmediate 方法，event loop 会结束 poll 阶段，进入 check 阶段去执行 check 队列</li><li>如果没有设定 setImmediate 方法，就会阻塞在 poll 阶段，直到有 poll callback 添加到队列中，然后立刻执行。</li></ol></li></ul><p>如果 event loop 进入 poll 阶段并且设定了定时器：</p><ul><li>一旦 poll 队列处于空闲状态，event loop 会查看 timers 里的回调函数，如果至少有一个回调函数的时间到了，event loop 会按循环顺序进入 timers 阶段去执行这些回调函数。</li><li>按循环顺序说的是 event loop 不会直接进入 timers 阶段，而是要先进入 check、close callback 之后，再进入 timers 阶段。</li></ul><h3 id="三、check"><a href="#三、check" class="headerlink" title="三、check"></a>三、check</h3><ul><li>这个阶段用来存放 setImmediate 回调函数，如果代码中设定了，那么 event loop 不会阻塞等待在 poll 阶段，而是会进入 check 阶段。</li><li>当 poll 阶段结束，进入check 阶段后，会调用 libuv api 去执行回调函数</li></ul><h3 id="四、API-比较"><a href="#四、API-比较" class="headerlink" title="四、API 比较"></a>四、API 比较</h3><ul><li><p>setTimeout 和 setImmediate</p><ol><li>setTimeout 设定一个任务在等待指定时间后去执行</li><li>setImmediate 在 poll 阶段完成后立即去调用它设定的代码</li><li>它们回调函数执行的顺序依据它们执行的方式会有不同：如果它们的执行不在 I/O 操作里，那么顺序时不定的，如果在 I/O 中，永远都是 setImmediate 最先执行</li></ol></li><li><p>process.nextTick</p></li></ul><p>在技术上来说，nextTick 不属于 event loop 的一部分，凡是放进 nextTick 队列的回调函数会在下一次 event loop 循环开始前执行。需要注意的是，正是因为这个特性，如果递归调用 nextTick，会导致下一次 event loop 无法开始。</p><h3 id="node-中宏任务和微任务"><a href="#node-中宏任务和微任务" class="headerlink" title="node 中宏任务和微任务"></a>node 中宏任务和微任务</h3><p>因为 node 中的 宏任务分处于不同的阶段，并且微任务中的 process.nextTick 都是先于其它微任务执行，所以可以理解为 有4个宏任务队列以及2个微任务队列。</p><p>这里为了便于理解，借用一张图：</p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a8667e6b79cc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" lazyload alt="node-eventloop" style="zoom:80%;;margin-left:0" /><p>这里的宏任务和微任务流程模型与浏览器的相同，区别在于：</p><ol><li>node 中的宏任务队列执行顺序取决于 event loop 所处的阶段</li><li>微任务中，process.nextTick 独处一个队列，比其他微任务要早执行</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>event loop 相当于一个总指挥，负责 js 任务的协调与调度。</p><p>参考文献 <a href="https://juejin.cn/post/6844903670291628046#heading-5" target="_blank" rel="noopener">https://juejin.cn/post/6844903670291628046#heading-5</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Event Loop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟着规范实现一个功能完备的Promise</title>
    <link href="/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/"/>
    <url>/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/</url>
    
    <content type="html"><![CDATA[<p>一直以来，对于 promise，只知道如何使用，其内部的运作机制却不得而知。本着知其然，知其所以然（为了让自己用得安心）的理念，决定跟着规范去了解底层的原理，并手写一个功能完备的 MyPromise.</p><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><ul><li>promise 是一个对象或者函数，拥有 then 方法</li><li>thenable 可以理解为一个拥有 then 方法的对象或函数</li><li>value 是一个合法的 JavaScript值</li><li>reason 用来表示 promise 拒绝的原因</li></ul><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li>promise 初始状态为 pending，可以转变成 fulfilled 或者 rejected</li><li>如果状态是 fulfilled，则不能转变为 rejected 或者 pending。rejected 同理。</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>下面开始尝试第一版：</p><p>平时都是通过 new 来创建一个 promise 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>    resolve(<span class="hljs-string">'xxx'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>于是首先创建一个 promise 构造函数，接收一个方法 executor 作为参数, 在内部直接执行，并且传入两个方法以供使用者使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>    <br>    executor(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果调用 resolve 方法，会将 Promise实例 状态转变成 fulfilled，如果调用 reject 方法，则会将 Promise 实例状态转变成 rejected。所以接下来给 MyPromise 构造函数添加相应属性，并实现 resolve 和 reject。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'pending'</span>;<br>    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// 只有处于 pending 状态，才能发生状态改变</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;<br>            <span class="hljs-keyword">this</span>.reason = reason;<br>        &#125;<br>    &#125;<br>    <br>    executor(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数建造完毕，现在来处理最主要的部分 then 方法，这也是规范给出详细标准的一部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 可以接收两个方法作为参数, 在内部可以根据 MyPromise 实例的状态进行相应的操作</span><br>MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 then 执行的时候，如果 status 是 fulfilled 或者 rejected 状态，可以直接执行 onFulfilled 或者 onRejected 方法，但如果依然还是 pending，需要将这些执行操作放入等待区，也就是存入到回调队列中，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;)<br>        <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            onRejected(<span class="hljs-keyword">this</span>.reason)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>        onFulfilled(<span class="hljs-keyword">this</span>.value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>        onRejected(<span class="hljs-keyword">this</span>.reason)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在，待执行栈已经存在了状态改变的回调，需要在合适的时机去执行，所以需要完善 resolve 和 reject 方法。一旦状态改变，则将带执行栈中的回调全部执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> resolve = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;<br>    <span class="hljs-keyword">this</span>.value = value;<br>    <span class="hljs-comment">// 执行回调</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onFulfilledStack.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onFulfilledStack.shift()(<span class="hljs-keyword">this</span>.value);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> reject = <span class="hljs-function">(<span class="hljs-params">reason</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;<br>    <span class="hljs-keyword">this</span>.reason = reason;<br>    <span class="hljs-comment">// 执行回调</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onRejectedStack.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onRejectedStack.shift()(<span class="hljs-keyword">this</span>.reason);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道then 方法必须返回一个 promise，因此需要对 then 方法进一步改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就要思考一下，then 方法为什么要返回一个 promise？ 原因是每一个 promise 都会有一个 then 方法，而如果 then 方法也返回一个 promise，那么这个 then 也会有一个 then 方法，于是可以像下方代码一样链式调用 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).then().then()<br></code></pre></td></tr></table></figure><p>但还有个原因。我们不仅可以像上方一样 resolve 一个基本值，也可以 resolve 一个 promise，如下方例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">_resolve, _reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            _resolve(<span class="hljs-string">'success'</span>)<br>        &#125;, <span class="hljs-number">2000</span>)<br>    &#125;))<br>&#125;).then().then()<br></code></pre></td></tr></table></figure><p>因为被 resolve 的 promise 的状态是尚未改变的，因此可以将这个 promise 放进 then 返回的这个 promise 内去等待状态改变，所以这一步我们将 then 方法内原先的处理逻辑挪到这个返回的 promise 内部。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> _promise = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 因为 onFulfilled(this.value) 和 onRejected(this.reason) 可能返回一个 thenable，因此需要将下方代码移入新 promise内部去执行</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            &#125;)<br>            <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onRejected(<span class="hljs-keyword">this</span>.reason)<br>            &#125;)<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>            onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>            onRejected(<span class="hljs-keyword">this</span>.reason)<br>        &#125;<br>    &#125;)<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>有个问题，我们在内部直接调用 onFulfilled 和 onRejected，但却没有对这两个方法类型进行错误处理，也就是必须保证它们是 function。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// 设置默认的回调方法（需原样返回传进来的值或者抛出同样的值），可以保证 promise 结果能够透传</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个处理，如果 onFulfilled 和 onRejected 不是 function，那么就将它们赋值成方法，并且将接收到的值进行相应处理：如果是 onFulfilled，直接将值 return，如果是 onRejected, 主动抛出一个错误。这也就实现了 promise 值的透传</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).then().then(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value)  <span class="hljs-comment">// success</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>目前为止，MyPromise 已经具备了可实例化，可执行同步任务的功能。但还无法执行异步任务。</p><p>规范2.2.4： onFulfilled or onRejected must not be called until the execution context stack contains only platform code。</p><p>意思是：onFulfilled 和 onRejected 方法需要异步执行。</p><p>接下来对 then 方法进行进一步完善, 将它们的执行丢到异步环境中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">let</span> _promise = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    onFulfilled(<span class="hljs-keyword">this</span>.value);<br>                &#125;)<br>                <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    onRejected(<span class="hljs-keyword">this</span>.reason)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            &#125;)<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onRejected(<span class="hljs-keyword">this</span>.reason)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>规范2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x)</p><p>意思是： 对 onFulfilled 或者 onRejected 返回的值 x 进行 resolvePromise 操作，即需要将 x 当作一个 thenable 来对待，then 返回的 promise 的 状态需要 x 的状态来决定。</p><p>这里需要注意： resolvePromise 需要 promise2（即 then 返回的 promise） 和 x 这两个参，但是 promise2 的状态需要它自身 resolve 和 reject 去改变，因此将 resolve 和 reject 也带上。</p><p>改动如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>    <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            resolvePromise(_promise, x, resolve, reject)<br>        &#125;)<br>    &#125;)<br>    <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);<br>            resolvePromise(_promise, x, resolve, reject)<br>        &#125;) <br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> x = onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        resolvePromise(_promise, x, resolve, reject)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> x = onRejected(<span class="hljs-keyword">this</span>.reason);<br>        resolvePromise(_promise, x, resolve, reject)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是实现 resolvePromise 方法了。</p><p>按照规范 2.3 The Promise Resolution Procedure，一步步实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolvePromise</span>(<span class="hljs-params">_promise, x, resolve, reject</span>)</span>&#123;<br>    <span class="hljs-comment">// 2.3.1 如果 _promise 和 x 是同一个对象，reject TypeError</span><br>    <span class="hljs-keyword">if</span> (x === _promise) &#123;<br>        <span class="hljs-keyword">return</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">`<span class="hljs-subst">$&#123;x&#125;</span> should no refer to the same object with MyPromise`</span>))<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当 x 是对象或者函数时：</span><br>    <span class="hljs-comment">// 判断 x.then 方法中 onFulfilled 回调或者 onRejecetd 回调是否执行过</span><br>    <span class="hljs-comment">// 因为规范规定：其中每一个回调只能执行一次</span><br>    <span class="hljs-comment">// 当其中某项执行过，就将 hasCalled 置为 true</span><br>    <span class="hljs-keyword">let</span> hasCalled = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">if</span> (x <span class="hljs-keyword">instanceof</span> MyPromsie) &#123;<br>        <span class="hljs-comment">// 如果状态没有改变，则需要调用 then 方法，然后在内部还需要对以后的返回值进行 resolvePromise </span><br>        <span class="hljs-keyword">if</span> (x.status === <span class="hljs-string">'pending'</span>) &#123;<br>            x.then(<span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> &#123;<br>                resolvePromise(_promise, y, resolve, reject)<br>            &#125;, err =&gt; &#123;<br>                resolvePromise(_promise, err, resolve, reject)<br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果状态已经改变，那么 x 就会有一个正常值，假设为 z</span><br>            <span class="hljs-comment">// 执行 x.then(resolve, reject)，会直接调用 resolve(z) 或者 reject(z) ：</span><br>            <span class="hljs-comment">// 2.3.2.2 &amp;&amp; 2.3.2.3</span><br>            x.then(resolve, reject);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.prototype.toString.call(x) === <span class="hljs-string">'[object Object]'</span> || <span class="hljs-keyword">typeof</span> x === <span class="hljs-string">'function'</span>) &#123; <span class="hljs-comment">// x 是对象或者函数</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> then = x.then;<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">'function'</span>) &#123;<br>                then.call(x, y =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (hasCalled) &#123; <span class="hljs-keyword">return</span> &#125;<br>                    hasCalled = <span class="hljs-literal">true</span>;<br>                    resolvePromise(_promise, y, resolve, reject)<br>                &#125;, err =&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (hasCalled) &#123; <span class="hljs-keyword">return</span> &#125;<br>                    hasCalled = <span class="hljs-literal">true</span>;<br>                    reject(err);<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                resolve(x)<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span>(err) &#123;<br>            <span class="hljs-comment">// 2.3.3.3.4.1</span><br>            <span class="hljs-comment">// if resolvePromise or rejectPromise have been called, ignore it.</span><br>            <span class="hljs-keyword">if</span> (!hasCalled) &#123;<br>                reject(err)<br>            &#125;<br>        &#125;<br>        <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 2.3.4</span><br>        resolve(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果能通过 promiseA+ 测试，说明该版本的 Promise 符合规范，但是还缺少常用的功能，继续完善：</p><p><strong>MyPromise.resolve</strong></p><p>接收一个值，在内部创建一个新的实例，将状态交给新实例去处理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(value)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.catch</strong></p><p>接收一个方法，只会在 rejected 状态下执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.finally</strong></p><p>接收一个方法，不论 fulfilled 或者 rejected 都会执行</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(callback, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.all</strong></p><p>接收一个数组，只有所有项的状态为 fulfilled，最终结果才为 fulfilled，如果有一个 rejected，那么结果就是 rejected</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = [];<br>        <span class="hljs-keyword">let</span> resolveCount = <span class="hljs-number">0</span>;<br>        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                result[index] = value;<br>                resolveCount++;<br>                <span class="hljs-keyword">if</span> (resolveCount === promiseArr.length) &#123;<br>                    resolve(result);<br>                &#125;<br>            &#125;, err =&gt; &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.race</strong></p><p>接收一个数组，结果由第一个状态改变的 thenable 决定</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value);<br>            &#125;, err =&gt; &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.allSettled</strong></p><p>接收一个数组，只有等到所有项的状态都改变了，不论是 fulfilled 还是 rejected，都只会变成 fulfilled</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> resultArr = [];<br>        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resultArr.push(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">'fulfilled'</span>, <span class="hljs-attr">value</span>: value&#125;);<br>                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;<br>                    resolve(resultArr);<br>                &#125;<br>            &#125;, err =&gt; &#123;<br>                resultArr.push(&#123;<span class="hljs-attr">status</span>: <span class="hljs-string">'rejected'</span>, <span class="hljs-attr">reason</span>: err&#125;);<br>                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;<br>                    resolve(resultArr);<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.any</strong></p><p>接收一个数组，如果其中有一项的状态为 fulfilled， 那么结果就是 fulfilled，否则如果所有都是 rejected，那结果就是 rejected， 并且 reanson 是 ‘AggregateError: All promises were rejected’</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.prototype.any = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> rejectCount = <span class="hljs-number">0</span>;<br>        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value);<br>            &#125;, err =&gt; &#123;<br>                rejectCount ++;<br>                <span class="hljs-keyword">if</span> (rejectCount === promiseArr.length) &#123;<br>                    reject(<span class="hljs-string">'AggregateError: All promises were rejected'</span>);<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法：</p><p>#安装 promises-aplus-tests</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm i promises-aplus-tests -g<br></code></pre></td></tr></table></figure><p>#在代码里加上这段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js">MyPromise.deferred = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> defer = &#123;&#125;;<br>    defer.promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        defer.resolve = resolve;<br>        defer.reject = reject;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> defer;<br>&#125;<br></code></pre></td></tr></table></figure><p>#最后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">promises-aplus-tests promise.js<br></code></pre></td></tr></table></figure><p>有一点需要注意：我在实现 promise 内部异步执行时采用的是 setTimeout，而 promise 的 then 方法是一个微任务这与实际有出入。不过用于理解其中的异步理念已经足够了。追求完美的同学可自行实现不同的版本。</p><p>完整代码地址：<a href="https://github.com/yuwengCipher/MyPromise" target="_blank" rel="noopener">https://github.com/yuwengCipher/MyPromise</a></p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说 js 的异步处理机制</title>
    <link href="/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h2><p>在 JavaScript 中和生活中都会有异步任务的存在，而异步的产生是有前提条件的，那就是这个任务可以被拆解成两部分。</p><p>举个简单的例子。周末我想喝点排骨汤，把所有步骤都准备好后开火炖。正常来说，这锅汤需要3小时才能煲好，很显然我不会傻傻守在这儿等它3小时，因为我还有别的事要做，比如说看电视，嗑瓜子等等。而是3小时后汤煲好了，我才回去盛起来喝。</p><p>所以这个喝汤任务由两个步骤组成：煲汤 + 喝汤；这个喝汤步骤就是异步的</p><h2 id="设计成异步的原因"><a href="#设计成异步的原因" class="headerlink" title="设计成异步的原因"></a>设计成异步的原因</h2><p>从上面可以知道，如果我傻傻的在锅前等3个小时，那么我看电视、嗑瓜子等事情就得向后延3小时，到最后我这一天做不了什么，所以傻等3小时完全是浪费时间。</p><p>js 是单线程，同一时间只能做一件事，长时间的等待势必会造成资源的浪费</p><h2 id="异步实现方案"><a href="#异步实现方案" class="headerlink" title="异步实现方案"></a>异步实现方案</h2><ul><li>回调函数</li></ul><p>回调函数在 js 代码里随处可见，如给 DOM 添加点击事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> d = <span class="hljs-built_in">document</span>.getElementId(<span class="hljs-string">'test'</span>);<br>d.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br><span class="hljs-comment">// callback 就是回调函数</span><br></code></pre></td></tr></table></figure><p>node 里去读取一份文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>但是有时候的需求会比较复杂，加入多个任务存在依赖性，就会写出如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>    fs.readFile(<span class="hljs-string">'./test1.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>        fs.readFile(<span class="hljs-string">'./test2.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>深层嵌套让我们很是绝望！</p><ul><li>promise</li></ul><p>幸运的是后来有了 promise，带我们逃离了“回调地狱”，来到新世界：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>        resolve(data);<br>    &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params">err, data1</span>)</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        resolve(data1);<br>    &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text1'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params">err, data2</span>)</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        resolve(data2);<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样写之后是不是看起来清爽了，瞬间头也不晕了，promise 让流程执行的过程更清晰！</p><p>但是你一定见过这样的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>        resolve(data);<br>    &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>...<br></code></pre></td></tr></table></figure><p>真的是链式调用一时爽，一直链式调用… 就有点难受了。 promise 抑制了回调地狱的横向扩张，却发现自己的纵向扩张也很厉害。</p><ul><li>generator</li></ul><p>generator 函数与普通的函数不同，函数内的代码可以分段执行，也就是说可以暂停执行，凡是需要暂停的地方用 yield 关键字注明。具体用法参考阮老师文章的介绍 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/04/generator.html</a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">let</span> gen = genFn();<br>gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>于是对于上面依次读取文件的例子可以改写成如下形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 模拟文件请求</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration</span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(filename)<br>        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span><br>        gen.next(filename)<br>    &#125;, duration)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 顺序请求三个文件，期望的是顺序打印出结果</span><br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> gen = genFn();<br>gen.next();<br><br><span class="hljs-comment">// a.txt   5秒后打印</span><br><span class="hljs-comment">// b.txt   8秒后打印</span><br><span class="hljs-comment">// c.txt   9秒后打印</span><br></code></pre></td></tr></table></figure><p>虽然获取文件所需时长 a &gt; b &gt; c, 但是打印的结果却是 a，b，c，也就是说在 generator 函数内，yield 是按上到下执行的，使得代码执行顺序更清晰明了。</p><p>可以看到我需要在文件请求完成之后手动调用 next 方法，因此在实际工作中，我们通常需要将 generator 函数包裹在一个函数内：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callGen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>, gen);<br>        <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>, gen);<br>        <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>, gen);<br>    &#125;<br>    <span class="hljs-keyword">const</span> gen = genFn();<br>    gen.next();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(filename)<br>        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span><br>        g.next(filename)<br>    &#125;, duration)<br>&#125;<br><br>callGen();<br></code></pre></td></tr></table></figure><p>总的来说，generator 函数改善了 promise 的 then “链条”过长的缺点，但是需要额外创建一个函数来包装。</p><ul><li>async await</li></ul><p>作为 ES7 提出的 async 函数，在 generator 基础上进行优化，是目前 js 处理异步操作的最优解决方案，让异步处理代码可读性更强，流程控制更方便。</p><p>我们按照 async 方法的用法来继续优化上面的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    <span class="hljs-comment">// 因为 await 关键字后面需要接收一个 promise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            resolve(filename)<br>        &#125;, duration)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>asyncFn();<br><br><span class="hljs-comment">// 9秒后一次性打印</span><br><span class="hljs-comment">// a.txt </span><br><span class="hljs-comment">// b.txt </span><br><span class="hljs-comment">// c.txt</span><br></code></pre></td></tr></table></figure><p>需要注意的是如果 await 后面表达式里包含异步操作但返回的不是 promise，那么就就不会等待到结果返回，比如这样修改：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (filename === <span class="hljs-string">'a.txt'</span>) &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> filename<br>        &#125;, duration)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                resolve(filename)<br>            &#125;, duration)<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br>asyncFn();<br><br><span class="hljs-comment">// undefined 立刻输出</span><br><span class="hljs-comment">// b.txt     4秒之后输出</span><br><span class="hljs-comment">// c.txt     4秒之后输出</span><br></code></pre></td></tr></table></figure><p>也就是说第一个 await 没有阻塞 console.log(a) 的执行。因此 async 对 await 后面的表达式又两种处理方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-number">1.</span> promise<br>   <span class="hljs-keyword">async</span> 会执行表达式并等待有返回值才会继续往下执行代码<br><span class="hljs-number">2.</span> 非 promise<br>   <span class="hljs-keyword">async</span> 执行表达式并立刻获取返回值，如果没有则为 <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>js 处理异步的方法经历了 回调函数、promise、generator、async 这四个阶段，每一种新方法都是对前方法的改善，主要处理的点有两点：</p><ol><li>可读性更强</li><li>流程控制更清晰</li></ol>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>异步处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
