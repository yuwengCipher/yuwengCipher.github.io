<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>http 协议笔记/一个简单的网络请求过程</title>
    <link href="/2021/04/30/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/04/30/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>带着问题读源码/vue2/compiler</title>
    <link href="/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/compiler/"/>
    <url>/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/compiler/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>带着问题读源码/vue2/总体结构</title>
    <link href="/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <url>/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>带着问题读源码/axios/总体结构</title>
    <link href="/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <url>/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><strong>本文基于 axios 版本 0.21.1</strong></p><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><p>在根目录下找到 index.js，里面只有一句代码，将 axios 进行导出。</p><pre><code class="hljs ini"><span class="hljs-attr">module.exports</span> = require(<span class="hljs-string">'./lib/axios'</span>)<span class="hljs-comment">;</span></code></pre><p>找到 lib 下的 axios.js 文件</p><ul><li><p>首先引入了相关文件</p><pre><code class="hljs javascript"><span class="hljs-comment">// 工具函数库</span><span class="hljs-keyword">var</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils'</span>);<span class="hljs-comment">// bind 方法，返回 function wrap</span><span class="hljs-keyword">var</span> bind = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers/bind'</span>);<span class="hljs-comment">// Axios 构造函数</span><span class="hljs-keyword">var</span> Axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/Axios'</span>);<span class="hljs-comment">// 合并参数</span><span class="hljs-keyword">var</span> mergeConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/mergeConfig'</span>);<span class="hljs-comment">// 默认设置和属性</span><span class="hljs-keyword">var</span> defaults = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./defaults'</span>);</code></pre></li><li><p>创建 axios 实例的方法</p><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> createInstance (defaultConfig) &#123;<span class="hljs-comment">// 创建 Axios 实例</span><span class="hljs-keyword">var</span> <span class="hljs-keyword">context</span> = <span class="hljs-keyword">new</span> Axios(defaultConfig);<span class="hljs-keyword">var</span> <span class="hljs-keyword">instance</span> = <span class="hljs-keyword">bind</span>(Axios<span class="hljs-variable">.prototype</span><span class="hljs-variable">.request</span>, <span class="hljs-keyword">context</span>);utils<span class="hljs-variable">.extend</span>(<span class="hljs-keyword">instance</span>, Axios<span class="hljs-variable">.prototype</span>, <span class="hljs-keyword">context</span>);utils<span class="hljs-variable">.extend</span>(<span class="hljs-keyword">instance</span>, <span class="hljs-keyword">context</span>);<span class="hljs-keyword">return</span> <span class="hljs-keyword">instance</span>;&#125;</code></pre><p>​        bind 方法代码如下：</p><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span> <span class="hljs-params">(fn, thisArg)</span> &#123;</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span> <span class="hljs-params">()</span> &#123;</span>var args = new Array(arguments.<span class="hljs-built_in">length</span>);<span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; args.<span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) &#123;args[<span class="hljs-built_in">i</span>] = arguments[<span class="hljs-built_in">i</span>];&#125;<span class="hljs-keyword">return</span> fn.apply(thisArg, args);&#125;;&#125;</code></pre><p>​        其实就是返回 wrap 函数，函数内部会使用 context 调用 Axios.prototype.request。因此 instance 就是 wrap 函数。</p><p>​        之后就是将 Axios.prototype 和 context 的属性赋值给 wrap 函数。</p></li></ul><p>到这里，我们知道了 axios 实例是如何创建。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><strong>文件位于  axios/core/Axios</strong> </p><p>首先引入所需文件，知道是干什么的就行。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 对请求路径进行一些格式化</span><span class="hljs-keyword">var</span> buildURL = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers/buildURL'</span>);<span class="hljs-comment">// 拦截器构造函数</span><span class="hljs-keyword">var</span> InterceptorManager = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./InterceptorManager'</span>);<span class="hljs-comment">// 发起 request 请求</span><span class="hljs-keyword">var</span> dispatchRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dispatchRequest'</span>);</code></pre><p>接着往下看</p><pre><code class="hljs actionscript"><span class="hljs-comment">// Axios 构造函数</span><span class="hljs-comment">// 拥有 defaults 和 interceptors</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Axios</span> <span class="hljs-params">(instanceConfig)</span> </span>&#123;<span class="hljs-keyword">this</span>.defaults = instanceConfig;<span class="hljs-comment">// 拦截器对象</span><span class="hljs-keyword">this</span>.interceptors = &#123;request: <span class="hljs-keyword">new</span> InterceptorManager(),response: <span class="hljs-keyword">new</span> InterceptorManager()&#125;;&#125;</code></pre><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p>在构造函数内部声明了拦截器对象，分为请求和相应两个属性。通过上方路径找到拦截器构造函数文件。</p><p>​        内部默认拥有一个 handlers 数组，用来存储拦截器。</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InterceptorManager</span> <span class="hljs-params">()</span> </span>&#123;<span class="hljs-keyword">this</span>.handlers = [];&#125;</code></pre><p>​        然后给构造函数原型添加方法函数</p><ol><li><p>使用 use 方法添加一个新的拦截器，</p><ol><li>每个拦截器包括四个属性：<ol><li>fulfilled：一个方法，当作请求 resolve 回调</li><li>rejected：一个方法，当作请求 reject 回调</li><li>synchronous：设置请求是否为同步</li><li>runwhen：xxx</li></ol></li><li>use 方法返回当前拦截器在数组中的位置下标</li></ol><pre><code class="hljs gradle">InterceptorManager.prototype.use = function use (fulfilled, rejected, <span class="hljs-keyword">options</span>) &#123;<span class="hljs-keyword">this</span>.handlers.<span class="hljs-keyword">push</span>(&#123;fulfilled: fulfilled,rejected: rejected,synchronous: <span class="hljs-keyword">options</span> ? <span class="hljs-keyword">options</span>.synchronous : <span class="hljs-keyword">false</span>,runWhen: <span class="hljs-keyword">options</span> ? <span class="hljs-keyword">options</span>.runWhen : <span class="hljs-keyword">null</span>&#125;);<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handlers.length - <span class="hljs-number">1</span>;&#125;;</code></pre></li><li><p>使用 eject 方法清除一个拦截器。参数 id 就是拦截器在数组中的下标。</p><pre><code class="hljs actionscript">InterceptorManager.prototype.eject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eject</span> <span class="hljs-params">(id)</span> </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlers[id]) &#123;<span class="hljs-comment">// 将下标为 id 处的拦截器置为 null</span><span class="hljs-keyword">this</span>.handlers[id] = <span class="hljs-literal">null</span>;&#125;&#125;</code></pre></li><li><p>使用 forEach 方法过滤已经被清除的拦截器</p><pre><code class="hljs php">InterceptorManager.prototype.<span class="hljs-keyword">forEach</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span> <span class="hljs-params">(fn)</span> </span>&#123;<span class="hljs-comment">// 遍历拦截器存储数组，执行 fn 时会过滤掉数组中被置为 null 的值。</span>utils.<span class="hljs-keyword">forEach</span>(this.handlers, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachHandler</span> <span class="hljs-params">(h)</span> </span>&#123;<span class="hljs-keyword">if</span> (h !== <span class="hljs-keyword">null</span>) &#123;fn(h);&#125;&#125;);&#125;</code></pre></li></ol><h5 id="挂载方法"><a href="#挂载方法" class="headerlink" title="挂载方法"></a>挂载方法</h5><p>构造函数内部添加完属性后，紧接着就为构造函数原型添加相应方法：</p><pre><code class="hljs qml"><span class="hljs-comment">// 为 Axios 原型挂载 request 和 getUri 方法</span>Axios.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;Axios.prototype.getUri = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUri</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;<span class="hljs-comment">// 为 Axios 原型挂载支持的 method</span>utils.forEach([<span class="hljs-string">'delete'</span>, <span class="hljs-string">'get'</span>, <span class="hljs-string">'head'</span>, <span class="hljs-string">'options'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodNoData</span> (<span class="hljs-params">method</span>) </span>&#123;Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, config</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<span class="hljs-attribute">method</span>: method,<span class="hljs-attribute">url</span>: <span class="hljs-built_in">url</span>,<span class="hljs-comment">// 使用这些 method时，有可能不会传 data 属性，所以使用默认的 data</span><span class="hljs-attribute">data</span>: (config || &#123;&#125;).data &#125;));&#125;;&#125;);utils.forEach([<span class="hljs-string">'post'</span>, <span class="hljs-string">'put'</span>, <span class="hljs-string">'patch'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodWithData</span> (<span class="hljs-params">method</span>) </span>&#123;Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, data, config</span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<span class="hljs-attribute">method</span>: method,<span class="hljs-attribute">url</span>: <span class="hljs-built_in">url</span>,<span class="hljs-attribute">data</span>: data&#125;));&#125;;&#125;)</code></pre><p>其中还有请求方法 。调用这些方法，会调用原型的 request 方法，Axios 将支持的 methods 按照是否需要默认 data 属性分为两类，现在来解读 request 方法的实现。</p><h5 id="request"><a href="#request" class="headerlink" title="request"></a>request</h5><ul><li><p>首先是基本参数的一个默认设置</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 兼容 axios('example/url'[, config]) 这种传参方式</span><span class="hljs-keyword">if</span> (typeof config<span class="hljs-operator"> === </span>'<span class="hljs-built_in">string</span>') &#123;    config = arguments<span class="hljs-literal">[<span class="hljs-number">1</span>]</span><span class="hljs-operator"> || </span>&#123;&#125;;    config.url = arguments<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;&#125; <span class="hljs-keyword">else</span> &#123;    config = config<span class="hljs-operator"> || </span>&#123;&#125;;&#125;<span class="hljs-comment">// 合并 config</span>config = merge<span class="hljs-constructor">Config(<span class="hljs-params">this</span>.<span class="hljs-params">defaults</span>, <span class="hljs-params">config</span>)</span>;<span class="hljs-comment">// 设置 config.method， 默认小写，默认 get 方法</span><span class="hljs-keyword">if</span> (config.<span class="hljs-keyword">method</span>) &#123;    config.<span class="hljs-keyword">method</span> = config.<span class="hljs-keyword">method</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (this.defaults.<span class="hljs-keyword">method</span>) &#123;    config.<span class="hljs-keyword">method</span> = this.defaults.<span class="hljs-keyword">method</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;&#125; <span class="hljs-keyword">else</span> &#123;    config.<span class="hljs-keyword">method</span> = 'get';&#125;</code></pre></li><li><p>对拦截器队列的处理</p><pre><code class="hljs actionscript"><span class="hljs-comment">// 请求拦截器队列</span><span class="hljs-keyword">var</span> requestInterceptorChain = [];<span class="hljs-comment">// 请求拦截器是否同步执行</span><span class="hljs-keyword">var</span> synchronousRequestInterceptors = <span class="hljs-literal">true</span>;<span class="hljs-keyword">this</span>.interceptors.request.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unshiftRequestInterceptors</span> <span class="hljs-params">(interceptor)</span> </span>&#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> interceptor.runWhen === <span class="hljs-string">'function'</span> &amp;&amp; interceptor.runWhen(config) === <span class="hljs-literal">false</span>) &#123;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-comment">// 因为 interceptor.synchronous 默认为 false，所以 synchronousRequestInterceptors 默认为 false，</span>    synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous;    <span class="hljs-comment">// 每个拦截器由执行成功和执行失败处理方法组成</span>    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);&#125;);<span class="hljs-comment">// 响应拦截器链</span><span class="hljs-keyword">var</span> responseInterceptorChain = [];<span class="hljs-keyword">this</span>.interceptors.response.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushResponseInterceptors</span> <span class="hljs-params">(interceptor)</span> </span>&#123;    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);&#125;);</code></pre></li><li><p>请求拦截器 执行机制的处理</p><p>​        请求拦截器 执行机制由上面的 synchronousRequestInterceptors 决定，分为 异步和同步两种。</p><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> promise;<span class="hljs-comment">// 异步执行</span><span class="hljs-keyword">if</span> (!synchronousRequestInterceptors) &#123;<span class="hljs-comment">// 调用处理方法队列</span>    <span class="hljs-keyword">var</span> chain = [dispatchRequest, undefined];<span class="hljs-comment">// 将请求拦截器处理方法和响应拦截器处理方法分别放入队列前后</span>    <span class="hljs-keyword">Array</span>.prototype.unshift.apply(chain, requestInterceptorChain);    chain.concat(responseInterceptorChain);    promise = Promise.resolve(config);    <span class="hljs-comment">// 将包含了请求拦截器的 chain 交给 promise 来处理  </span>    <span class="hljs-keyword">while</span> (chain.length) &#123;        promise = promise.then(chain.shift(), chain.shift());    &#125;    <span class="hljs-keyword">return</span> promise;&#125;<span class="hljs-comment">// 同步执行</span><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Config</span> = config;<span class="hljs-comment">// 先一次性执行完请求拦截器</span><span class="hljs-keyword">while</span> (requestInterceptorChain.length) &#123;    <span class="hljs-keyword">var</span> onFulfilled = requestInterceptorChain.shift();    <span class="hljs-keyword">var</span> onRejected = requestInterceptorChain.shift();    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-keyword">new</span><span class="hljs-type">Config</span> = onFulfilled(<span class="hljs-keyword">new</span><span class="hljs-type">Config</span>);    &#125; <span class="hljs-keyword">catch</span> (error) &#123;        onRejected(error);        <span class="hljs-keyword">break</span>;    &#125;&#125;<span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// 再异步执行 dispatchRequest（如 XHR），</span>    promise = dispatchRequest(<span class="hljs-keyword">new</span><span class="hljs-type">Config</span>);&#125; <span class="hljs-keyword">catch</span> (error) &#123;    <span class="hljs-keyword">return</span> Promise.reject(error);&#125;<span class="hljs-comment">// 最后异步执行响应拦截器</span><span class="hljs-keyword">while</span> (responseInterceptorChain.length) &#123;    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());&#125;<span class="hljs-keyword">return</span> promise;</code></pre><p>最后通过一张图来理解 request</p></li></ul><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/axios_%E6%89%A7%E8%A1%8C%E5%9B%BE.jpg" srcset="/img/loading.gif" alt="axios 执行图"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析 generator 与 async 原理</title>
    <link href="/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>geneartor 和 async 都是 js 处理异步操作发展历程的产物，它们让异步编程越来越像同步编程。但是由于采用新的语法、关键字，它们是如何做到“类同步”操作的，我们不得而知，因此这篇文章将会窥探内部的秘密。</p><p>下面将借助 babel 本地编译示例代码来进行分析。</p><h4 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h4><p> 一、全局安装 regenerator</p><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i regenerator -g</code></pre><p> 二、编译 generator</p><p>​        命令加上 –include-runtime，可以得到完整的编译代码</p><pre><code class="hljs x86asm">regenerator --include-runtime <span class="hljs-keyword">test</span><span class="hljs-number">.</span><span class="hljs-keyword">js</span> &gt; <span class="hljs-keyword">test</span>-fill<span class="hljs-number">.</span><span class="hljs-keyword">js</span></code></pre><p>test-fill.js 就是编译后的代码文件。</p><h4 id="解析-generator"><a href="#解析-generator" class="headerlink" title="解析 generator"></a>解析 generator</h4><p>现在有如下代码：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> y;&#125;<span class="hljs-keyword">let</span> gen = genFn();gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span></code></pre><p>调用 genFn 并不会直接执行，而是会返回一个 g 对象，每次调用它的 next 方法会执行一个 yield 语句，并返回当前的值及状态。</p><p>这是编译后的代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _marked = <span class="hljs-comment">/*#__PURE__*/</span>regeneratorRuntime.mark(genFn);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:_context.next = <span class="hljs-number">2</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:_context.next = <span class="hljs-number">4</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:_context.next = <span class="hljs-number">6</span>;<span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<span class="hljs-keyword">return</span> _context.stop();&#125;&#125;&#125;, _marked);&#125;<span class="hljs-keyword">var</span> g = genFn();<span class="hljs-built_in">console</span>.log(g.next());<span class="hljs-built_in">console</span>.log(g.next());<span class="hljs-built_in">console</span>.log(g.next());<span class="hljs-built_in">console</span>.log(g.next());</code></pre><p>可以看到 genFn 被改写了，调用 regeneratorRuntime.wrap 方法创建，其中传给 wrap 方法的 genFn$ 函数，里面的逻辑很简单，是一个永远都会执行的迭代，里面 switch 中的 case 是原代码中 yield 关键字所在的行数，genFn$ 的参数 _context 记录了原代码的执行上下文内容，每次调用 next 方法，实际上就会调用 genFn$，然后执行对应的逻辑。</p><p>大致的流程弄清楚之后，再来看看 regeneratorRuntime。</p><p>wrap 方法第二个参是 mark(genFn) 的值， mark 方法如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> $<span class="hljs-built_in">Symbol</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"function"</span> ? <span class="hljs-built_in">Symbol</span> : &#123;&#125;;<span class="hljs-keyword">var</span> iteratorSymbol = $<span class="hljs-built_in">Symbol</span>.iterator || <span class="hljs-string">"@@iterator"</span>;<span class="hljs-keyword">var</span> toStringTagSymbol = $<span class="hljs-built_in">Symbol</span>.toStringTag || <span class="hljs-string">"@@toStringTag"</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GeneratorFunctionPrototype</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<span class="hljs-keyword">var</span> IteratorPrototype = &#123;&#125;;IteratorPrototype[iteratorSymbol] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;&#125;;GeneratorFunctionPrototype.prototype = <span class="hljs-built_in">Object</span>.create(IteratorPrototype);exports.mark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">genFun</span>) </span>&#123;<span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.setPrototypeOf) &#123;<span class="hljs-built_in">Object</span>.setPrototypeOf(genFun, GeneratorFunctionPrototype);&#125; <span class="hljs-keyword">else</span> &#123;genFun.__proto__ = GeneratorFunctionPrototype;define(genFun, toStringTagSymbol, <span class="hljs-string">"GeneratorFunction"</span>);&#125;genFun.prototype = <span class="hljs-built_in">Object</span>.create(Gp);<span class="hljs-keyword">return</span> genFun;&#125;;</code></pre><ol><li>IteratorPrototype 对象添加 Symbol.iterator属性，使得 IteratorPrototype 拥有 Iterator 接口</li><li>GeneratorFunctionPrototype 函数的原型指向 IteratorPrototype ，所以 GeneratorFunctionPrototype 也拥有 Iterator 接口</li><li>genFun 的   <strong>proto</strong>  指向 GeneratorFunctionPrototype ，同理 genFun  拥有 Iterator 接口</li><li>mark 返回 genFun</li></ol><p>也就是说 mark 方法返回一个拥有 Iterator 接口 genFun。现在看下 wrap 方法。</p><pre><code class="hljs smali">function wrap (innerFn, outerFn, self, tryLocsList) &#123;// 确保 protoGenerator 拥有 Itrator 接口var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn<span class="hljs-keyword"> :</span> Generator;var generator = Object.create(protoGenerator.prototype);// context 即 genFn$ 的参数 _context var context =<span class="hljs-built_in"> new </span>Context(try<span class="hljs-class">LocsList || []);</span>// ._invoke 方法整合了 next、throw 和<span class="hljs-built_in"> return </span>方法generator._invoke = makeInvokeMethod(innerFn, self, context);<span class="hljs-built_in">return </span>generator;&#125;// _invoke 即内部的 invokefunction makeInvokeMethod (innerFn, self, context) &#123;   <span class="hljs-built_in"> return </span>function<span class="hljs-built_in"> invoke </span>(method, arg) &#123;        // ...    &#125;;&#125;</code></pre><p>先看看 _invoke 在哪儿调用</p><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> Gp = GeneratorFunctionPrototype.prototype = Generator.prototypedefineIteratorMethods(Gp);<span class="hljs-comment">// 为 Generator 添加 prototype 添加 next、throw、return 方法</span><span class="hljs-comment">// 并且这些方法都会调用 _invoke 方法</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineIteratorMethods</span> <span class="hljs-params">(prototype)</span> </span>&#123;[<span class="hljs-string">"next"</span>, <span class="hljs-string">"throw"</span>, <span class="hljs-string">"return"</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method)</span> </span>&#123;define(prototype, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg)</span> </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._invoke(method, arg);&#125;);&#125;);&#125;</code></pre><p>这些弄明白之后，可以简单理一下编译后代码的执行步骤：</p><ol><li>var g = genFn();<ol><li>genFn() 返回 generator 对象，拥有 _invoke 方法</li><li>g 拥有 _invoke</li></ol></li><li>g.next();<ol><li>g 的 next 方法会调用 _invoke 方法</li><li>g.next()  ==&gt;  g._invoke();</li></ol></li></ol><p>到这里就可以去看看 invoke 是如何实现的</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 四种状态：开始、执行中、暂停执行、结束</span>var GenStateSuspendedStart = <span class="hljs-string">"suspendedStart"</span>;var GenStateExecuting = <span class="hljs-string">"executing"</span>;var GenStateSuspendedYield = <span class="hljs-string">"suspendedYield"</span>;var GenStateCompleted = <span class="hljs-string">"completed"</span>;<span class="hljs-comment">// generator 方法执行的状态</span>var state = GenStateSuspendedStart;return <span class="hljs-keyword">function</span> invoke (<span class="hljs-keyword">method</span>, arg) &#123;<span class="hljs-comment">// 方法体内的语句执行过程中不允许继续执行</span>    <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> === </span>GenStateExecuting) &#123;        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">"Generator is already running"</span>)</span>;    &#125;    <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> === </span>GenStateCompleted) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span><span class="hljs-operator"> === </span><span class="hljs-string">"throw"</span>) &#123;            throw arg;        &#125;    &#125;    context.<span class="hljs-keyword">method</span> = <span class="hljs-keyword">method</span>;    context.arg = arg;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;        <span class="hljs-comment">// 省略容错逻辑</span>                state = GenStateExecuting;<span class="hljs-comment">// fn.call(obj, arg)</span><span class="hljs-comment">// fn 即 genFn$，arg 即为 context</span><span class="hljs-comment">//function tryCatch (fn, obj, arg) &#123;</span>        <span class="hljs-comment">//    try &#123;</span>        <span class="hljs-comment">//        return &#123; type: "normal", arg: fn.call(obj, arg) &#125;;</span>        <span class="hljs-comment">//    &#125; catch (err) &#123;</span>        <span class="hljs-comment">//        return &#123; type: "throw", arg: err &#125;;</span>        <span class="hljs-comment">//    &#125;</span>        <span class="hljs-comment">//&#125;</span>              <span class="hljs-comment">// 在这里调用 genFn$ 方法</span>        var record = <span class="hljs-keyword">try</span><span class="hljs-constructor">Catch(<span class="hljs-params">innerFn</span>, <span class="hljs-params">self</span>, <span class="hljs-params">context</span>)</span>;                <span class="hljs-keyword">if</span> (record.<span class="hljs-keyword">type</span><span class="hljs-operator"> === </span><span class="hljs-string">"normal"</span>) &#123; <span class="hljs-comment">// 执行 genFn$ 成功会走如下逻辑</span>        <span class="hljs-comment">// 如果语句执行完毕则结束执行，否则暂停执行</span>        state = context.<span class="hljs-keyword">done</span>                    ? GenStateCompleted                    : GenStateSuspendedYield;            <span class="hljs-comment">// 返回执行 yield 的结果</span>            return &#123;                value: record.arg,                <span class="hljs-keyword">done</span>: context.<span class="hljs-keyword">done</span>            &#125;;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (record.<span class="hljs-keyword">type</span><span class="hljs-operator"> === </span><span class="hljs-string">"throw"</span>) &#123; <span class="hljs-comment">// 遇到错误则将方法改为 throw，进入下一个循环执行容错逻辑</span>            state = GenStateCompleted;            context.<span class="hljs-keyword">method</span> = <span class="hljs-string">"throw"</span>;            context.arg = record.arg;        &#125;    &#125;&#125;;</code></pre><p>invoke 通过调用的方法进行不同的操作。遇到  throw 直接 throw 错误；遇到 return 会去 complete generator；遇到 next，就会调用 genFn$ 方法，最终返回一个 value 和 done 属性的对象。</p><h4 id="解析-async"><a href="#解析-async" class="headerlink" title="解析 async"></a>解析 async</h4><p>对于 async 函数，依然使用上面的方法进行编译处理。async 编译后的代码与 generator 编译后的 regeneratorRuntime 对象是一样的，因此我们只需要关注不同点就可以了。</p><p>编译前</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        resolve(<span class="hljs-number">2</span>)    &#125;, <span class="hljs-number">1000</span>)&#125;)<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> p();    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;    <span class="hljs-built_in">console</span>.log(a)    <span class="hljs-built_in">console</span>.log(b)    <span class="hljs-built_in">console</span>.log(c)&#125;asyncFn();<span class="hljs-comment">// 2 1 1</span></code></pre><p>编译后</p><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;resolve(<span class="hljs-number">2</span>);&#125;, <span class="hljs-number">1000</span>);&#125;);&#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params"></span>) </span>&#123;<span class="hljs-keyword">var</span> a, b, c;<span class="hljs-keyword">return</span> regeneratorRuntime.async(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:_context.next = <span class="hljs-number">2</span>;<span class="hljs-keyword">return</span> regeneratorRuntime.awrap(p());<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:a = _context.sent;_context.next = <span class="hljs-number">5</span>;<span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:b = _context.sent;_context.next = <span class="hljs-number">8</span>;<span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:c = _context.sent;<span class="hljs-built_in">console</span>.log(a);<span class="hljs-built_in">console</span>.log(b);<span class="hljs-built_in">console</span>.log(c);<span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<span class="hljs-keyword">return</span> _context.stop();&#125;&#125;&#125;, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-built_in">Promise</span>);&#125;asyncFn();</code></pre><p>与 generator 编译之后的代码基本相同，不同的是</p><ol><li>调用的是 regeneratorRuntime.async 方法，接收4个参，其中最后一个是 Promise</li><li>内部方法 return  regeneratorRuntime.awrap, 即将 await xx 改为 regeneratorRuntime.awrap(xx)</li></ol><p>按照顺序，先来看看 async 方法。</p><pre><code class="hljs javascript">exports.async = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">innerFn, outerFn, self, tryLocsList, PromiseImpl</span>) </span>&#123;<span class="hljs-comment">// 确保 PromiseImpl 是 Promise</span>    <span class="hljs-keyword">if</span> (PromiseImpl === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) PromiseImpl = <span class="hljs-built_in">Promise</span>;        <span class="hljs-keyword">var</span> iter = <span class="hljs-keyword">new</span> AsyncIterator(    <span class="hljs-comment">// wrap 方法返回一个 generator 对象</span>        wrap(innerFn, outerFn, self, tryLocsList),        PromiseImpl    );<span class="hljs-comment">// iter.next() 是一个 promise 对象</span>    <span class="hljs-keyword">return</span> exports.isGeneratorFunction(outerFn)        ? iter        : iter.next().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;               <span class="hljs-keyword">return</span> result.done ? result.value : iter.next();        &#125;);&#125;;</code></pre><p>new AsyncIterator 内部做了些什么工作呢？简化之后就很明了。</p><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AsyncIterator</span> <span class="hljs-params">(generator, PromiseImpl)</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> <span class="hljs-params">(method, arg, resolve, reject)</span> </span>&#123;&#125;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueue</span> <span class="hljs-params">(method, arg)</span> </span>&#123;        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callInvokeWithMethodAndArg</span> <span class="hljs-params">()</span> </span>&#123;        <span class="hljs-comment">// 返回 promise 实例</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PromiseImpl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolve, reject)</span> </span>&#123;                invoke(method, arg, resolve, reject);            &#125;);        &#125;        <span class="hljs-keyword">var</span> previousPromise;        <span class="hljs-keyword">return</span> previousPromise = callInvokeWithMethodAndArg();    &#125;    <span class="hljs-keyword">this</span>._invoke = enqueue;&#125;</code></pre><p>defineIteratorMethods 方法将 next(还有 throw、return) 方法代理给了 _invoke，所以 iter.next() 会调用 _invoke，即 enqueue，而 enqueue 返回一个 promise 实例，因此可以调用 then 方法。</p><pre><code class="hljs ada">iter.next().<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(result) &#123;       <span class="hljs-keyword">return</span> <span class="hljs-type">result.done</span> ? result.value : <span class="hljs-type">iter.next</span>();&#125;)</code></pre><p>这段是控制 await 顺序执行的开始和结束</p><p>首先执行 iter.next()，相当于执行  enqueue，进而执行 invoke。</p><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> invoke (<span class="hljs-keyword">method</span>, arg, resolve, reject) &#123;    var <span class="hljs-type">record</span> = tryCatch(generator[<span class="hljs-keyword">method</span>], generator, arg);    <span class="hljs-keyword">if</span> (<span class="hljs-type">record</span>.<span class="hljs-keyword">type</span> === "throw") &#123;        reject(<span class="hljs-type">record</span>.arg);    &#125; <span class="hljs-keyword">else</span> &#123;        var result = <span class="hljs-type">record</span>.arg;        var <span class="hljs-keyword">value</span> = result.<span class="hljs-keyword">value</span>;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &amp;&amp;            typeof <span class="hljs-keyword">value</span> === "object" &amp;&amp;            hasOwn.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">value</span>, "__await")) &#123;            <span class="hljs-keyword">return</span> PromiseImpl.resolve(<span class="hljs-keyword">value</span>.__await).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-keyword">value</span>) &#123;                invoke("next", <span class="hljs-keyword">value</span>, resolve, reject);            &#125;, <span class="hljs-keyword">function</span> (err) &#123;                invoke("throw", err, resolve, reject);            &#125;);        &#125;        <span class="hljs-keyword">return</span> PromiseImpl.resolve(<span class="hljs-keyword">value</span>).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> (unwrapped) &#123;            result.<span class="hljs-keyword">value</span> = unwrapped;            resolve(result);        &#125;, <span class="hljs-keyword">function</span> (error) &#123;            <span class="hljs-keyword">return</span> invoke("throw", error, resolve, reject);        &#125;);    &#125;&#125;</code></pre><p>执行步骤如下：</p><ol><li>var record = tryCatch(generator[method], generator, arg);<ol><li>因为 generator[method] 代理给了 _invoke。因此会执行 return { type: “normal”, arg: <em>fn</em>.call(<em>obj</em>, <em>arg</em>) };所以这里的 _invoke 是 generator 的 _invoke，而不是 iter 的 _invoke。</li><li>接下来执行 _invoke 的步骤与 generator 函数一样，执行被包裹的函数，最终会返回 {value: xx, done: xx} 对象，但不一样的是，如果函数体没有执行完毕之前，value 是一个对象，有一个 __await 属性。</li></ol></li><li>如果 tryCatch 执行失败，则直接 reject。</li><li>如果执行成功：<ol><li>如果函数体内的 await 还未执行结束，则会将 record.value.__await 值当作参数，递归调用 invoke 方法</li><li>如果函数体执行完毕，此时的 value 是 undefined，将 record 用异步的方式返回，就会执行 iter.next() 的 then 方法内的回调，这里就是直接执行 return result.value。 因此 async 默认返回 undefined。</li></ol></li></ol><p>到这里，我们就简单理解了 generator 和 async 函数内部的工作原理。其中，async 是在 generator 的基础上工作的，它使用递归方式取代多个 next 方法调用。</p><p>奉上一张编译后代码中方法调用的简图以作参考。</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/babel_%E7%BC%96%E8%AF%91_async_generator.png" srcset="/img/loading.gif" alt="babel 编译 async&amp;generator"></p><h4 id="实现一个简版-async"><a href="#实现一个简版-async" class="headerlink" title="实现一个简版 async"></a>实现一个简版 async</h4><p>通过上面的分析，我们可以知道，async 就是一个不需要手动执行 next 方法的 generator，明白了这点就好动手了。</p><p>先上一个示例</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span> (<span class="hljs-params">filename, duration</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(filename)            resolve(filename)        &#125;, duration)    &#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;    <span class="hljs-keyword">yield</span> <span class="hljs-number">5</span>;&#125;<span class="hljs-keyword">let</span> g = genFn();<span class="hljs-built_in">console</span>.log(g.next())<span class="hljs-built_in">console</span>.log(g.next())<span class="hljs-built_in">console</span>.log(g.next())<span class="hljs-built_in">console</span>.log(g.next())<span class="hljs-built_in">console</span>.log(g.next())<span class="hljs-built_in">console</span>.log(g.next())<span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><span class="hljs-comment">// &#123; value: 4, done: false &#125;</span><span class="hljs-comment">// &#123; value: 5, done: false &#125;</span><span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><span class="hljs-comment">// b.txt   3秒后输出</span><span class="hljs-comment">// a.txt   5秒后输出</span></code></pre><p>如上例所示，在实现 async 有2个问题需要解决：</p><ol><li>如何保证异步代码按调用顺序去执行（异步代码默认使用 promise 包裹）</li><li>如何自动调用 next</li></ol><p>先来实现自动调用，首先想到的是声明一个方法，在里面去执行 next 方法，然后递归调用。</p><pre><code class="hljs yaml"><span class="hljs-string">function</span> <span class="hljs-string">asyncFn</span> <span class="hljs-string">(genFn)</span> <span class="hljs-string">&#123;</span>    <span class="hljs-string">function</span> <span class="hljs-string">invokeNext</span> <span class="hljs-string">(generator)</span> <span class="hljs-string">&#123;</span>        <span class="hljs-string">//</span> <span class="hljs-string">在这里执行</span> <span class="hljs-string">next</span> <span class="hljs-string">方法</span>        <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> <span class="hljs-string">generator.next();</span>        <span class="hljs-string">//</span> <span class="hljs-string">如果调用结束就不再继续调用</span>        <span class="hljs-string">if</span> <span class="hljs-string">(result.done</span> <span class="hljs-string">===</span> <span class="hljs-literal">true</span><span class="hljs-string">)</span> <span class="hljs-string">&#123;</span>            <span class="hljs-string">return;</span>        <span class="hljs-string">&#125;</span>        <span class="hljs-string">invokeNext(generator)</span>    <span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">获取遍历器对象</span>    <span class="hljs-string">let</span> <span class="hljs-string">g</span> <span class="hljs-string">=</span> <span class="hljs-string">genFn.call(null);</span>    <span class="hljs-string">invokeNext(g)</span><span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">测试一下</span><span class="hljs-string">function*</span> <span class="hljs-string">genFn_</span> <span class="hljs-string">()</span> <span class="hljs-string">&#123;</span>    <span class="hljs-string">yield</span> <span class="hljs-number">1</span><span class="hljs-string">;</span>    <span class="hljs-string">yield</span> <span class="hljs-number">2</span><span class="hljs-string">;</span>    <span class="hljs-string">yield</span> <span class="hljs-number">3</span><span class="hljs-string">;</span>    <span class="hljs-string">yield</span> <span class="hljs-number">4</span><span class="hljs-string">;</span>    <span class="hljs-string">yield</span> <span class="hljs-number">5</span><span class="hljs-string">;</span><span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">无异步代码可以按顺序执行</span><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-string">undefined,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">true</span> <span class="hljs-string">&#125;</span><span class="hljs-string">//</span> <span class="hljs-string">对于前面异步代码的执行就会出先问题</span></code></pre><p>js 处理异步操作有多种方式，除了 generator 和 async，我们还有 promise，所以考虑用 promise 来管理每个 next 的调用顺序，事情就变得简单了，完整代码如下：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params">genFn</span>) </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeNext</span> (<span class="hljs-params">generator</span>) </span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            <span class="hljs-keyword">let</span> value = generator.next();            resolve(value)        &#125;).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;            <span class="hljs-built_in">console</span>.log(result);            <span class="hljs-keyword">if</span> (result.done === <span class="hljs-literal">true</span>) &#123;                <span class="hljs-keyword">return</span>;            &#125;            <span class="hljs-comment">// 如果是 promise 对象，则需要在 then 方法回调里去调用下一个 next</span>            <span class="hljs-keyword">if</span> (result.value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;                result.value.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    invokeNext(generator)                &#125;)            &#125; <span class="hljs-keyword">else</span> &#123;                invokeNext(generator)            &#125;        &#125;, err =&gt; &#123;            reject(err);        &#125;)    &#125;        <span class="hljs-keyword">const</span> g = genFn.call(<span class="hljs-literal">null</span>);    invokeNext(g)&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Generator</tag>
      
      <tag>Async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弄懂 event loop</title>
    <link href="/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/"/>
    <url>/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是-event-loop"><a href="#什么是-event-loop" class="headerlink" title="什么是 event loop"></a>什么是 event loop</h4><p>简单来说，event loop 就是 js 处理事件执行的一种机制。</p><p>js 以前是专门用来处理浏览器交互的，比如说 DOM 点击事件等，因此被设计成单线程，所谓单线程，就是同一时间只能处理一件事情，这也就保证了页面中一次只能处理一个事件，避免造成交互混乱的问题。</p><p><strong>开始之前，需要明确的是 javascript 引擎是单线程的，但是 js 运行环境是多线程。因为浏览器是多线程的，除了 js 引擎线程，还包括 GUI 渲染线程、定时器触发线程、http请求线程以及 DOM 事件触发线程；node也可以使用 child_process 创建多个子线程。</strong></p><p>现在有事件 A 和 B，如下：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> A = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);    &#125;, <span class="hljs-number">2000</span>)&#125;<span class="hljs-keyword">const</span> B = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);&#125;A();B();</code></pre><p>按照单线程的要求，需要等到 A 执行完毕，才会执行 B，那么打印顺序会是如下所示：</p><pre><code class="hljs 1c">console.<span class="hljs-built_in">log</span>('i am A');console.<span class="hljs-built_in">log</span>('i am B');</code></pre><p>但实际上的顺序是：</p><pre><code class="hljs 1c">console.<span class="hljs-built_in">log</span>('i am B');console.<span class="hljs-built_in">log</span>('i am A');</code></pre><p>这就是 event loop 机制在起作用，因为 console.log(‘i am B’) 是同步任务，而 setTimeout 是异步任务。</p><h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><ul><li>什么是宏任务和微任务？</li></ul><p>这里有几个概念容易混淆，那就是同步任务和异步任务，宏任务和微任务。js 的代码执行 遵循在代码块内从上往下执行的规则，同步任务会依次执行；而异步任务则会分为宏任务和微任务，比如说 setTimeout 的第一个参数是宏任务，promise.then 中注册的方法是微任务，会按照宏任务和微任务的执行规则进行执行。</p><ul><li>宏任务和微任务有哪些？</li></ul><p>js 代码执行分为宏任务和微任务，那宏任务和微任务分别由哪些呢？看下表：</p><table><thead><tr><th>宏任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>setTimeout</td><td>√</td><td>√</td></tr><tr><td>setInterval</td><td>√</td><td>√</td></tr><tr><td>setImmediate</td><td>x</td><td>√</td></tr><tr><td>I/O</td><td>√</td><td>√</td></tr><tr><td>requestAnimationFrame</td><td>√</td><td>x</td></tr></tbody></table><table><thead><tr><th>微任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>mutationObserver</td><td>√</td><td>x</td></tr><tr><td>promise</td><td>√</td><td>√</td></tr><tr><td>process.nextTick</td><td>x</td><td>√</td></tr></tbody></table><ul><li>宏任务和微任务的执行顺序</li></ul><p>要点一：一个宏任务里可能会包含多个微任务</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 promise 里的 同步任务'</span>)    resolve(<span class="hljs-string">'success'</span>)&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务1'</span>)&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务2'</span>)&#125;)setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 setTimeout 里的 宏任务'</span>)&#125;)</code></pre><p>我们来分析下这段代码里的宏任务和微任务有哪些：<br>宏任务：整体代码，setTimeout 的回调<br>微任务：两个 then 方法的回调</p><p>要点二：宏任务是一个一个执行的，而微任务是批量执行的，当前批次微任务没有完成之前，下一个宏任务不会执行</p><p>因此执行顺序是:</p><ol><li>遇到 promise，参数里面的代码是同步的，所有会先执行 console.log(‘我是 promise 里的 同步任务’)</li><li>执行两个 then 方法的回调</li><li>执行 setTimeout 的回调</li></ol><p>即：</p><pre><code class="hljs autoit">// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是 promise 里的 同步任务'</span>)// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是微任务1'</span>)// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是微任务2'</span>)// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是 setTimeout 里的 宏任务'</span>)</code></pre><h4 id="浏览器下的-event-loop"><a href="#浏览器下的-event-loop" class="headerlink" title="浏览器下的 event loop"></a>浏览器下的 event loop</h4><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/%E6%B5%8F%E8%A7%88%E5%99%A8_event_loop.png" srcset="/img/loading.gif" alt="浏览器 event loop"></p><p>如图所示，代码执行步骤如下：</p><ol><li>js 在执行代码时，会将代码放入执行栈中，遇到同步任务，会依次执行；遇到如 DOM 点击事件、ajax 以及 定时器等异步任务，浏览器会交给其他辅线程进行处理。</li><li>如果 WebApis 处理的异步任务有了结果，就会将该任务推入到回调队列（callback queue）中，回调队列分为宏任务队列和微任务队列。</li><li>一旦执行栈内（stack）的任务执行完成，就会将回调队列里的任务放入执行栈中执行，顺序如下：<ol><li>将宏任务队列的第一个任务放入执行栈中执行</li><li>一个宏任务执行完之后，如果微任务队列中存在任务，则一次性执行所有微任务</li></ol></li></ol><p>以上步骤的循环就是浏览器中的 event loop。</p><p>看一个简单例子感受下：</p><pre><code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;)<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'success'</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback3</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>&#125;)<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'start'</span>)<span class="hljs-comment">// start</span><span class="hljs-comment">// 1</span><span class="hljs-comment">// 2</span><span class="hljs-comment">// 3</span></code></pre><ol><li>遇到 setTimeout，等待时间到达后将 callback1 放入宏任务队列</li><li>遇到 promise.then，等待时间到达后将 callback2 与 callback3  按顺序放入微任务队列</li><li>执行同步任务 console.log。</li><li>执行完同步任务，将微任务队列里的任务一次性执行</li><li>微任务执行完之后，执行宏任务队列的第一个任务</li></ol><h4 id="node-下的-event-loop"><a href="#node-下的-event-loop" class="headerlink" title="node 下的 event loop"></a>node 下的 event loop</h4><pre><code class="hljs smali">   ┌───────────────────────────┐                             ┌─&gt;│           timers          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐                                    │  │     pending callbacks     │                             │  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐│  │       idle, prepare       ││  └─────────────┬─────────────┘      ┌───────────────┐│  ┌─────────────┴─────────────┐      │   incoming:   ││  │           poll            │&lt;─────┤ connections,  ││  └─────────────┬─────────────┘      │   data, etc.  ││  ┌─────────────┴─────────────┐      └───────────────┘│  │          <span class="hljs-built_in"> check </span>          ││  └─────────────┬─────────────┘│  ┌─────────────┴─────────────┐└──┤      close callbacks      │   └───────────────────────────┘</code></pre><p>如上图所示，node 中的 event loop 分为6个循环阶段，当 node.js 启动的时候，会初始化 event loop</p><ul><li>timers： 这个阶段执行 setTimeout 和 setInterval 的回调函数</li><li>pending callbacks：在下一个循环中执行 I/O 回调函数</li><li>idle, prepare：只在 node 内部触发</li><li>poll：获取新的 I/O 事件，在适当的时候阻塞在这里</li><li>check：执行 setImmediate 的回调函数</li><li>close callbacks：执行关闭事件的回调函数，如 socket.on(‘close’, … )</li></ul><p>下面主要对 timers、poll、check 三个阶段进行解析：</p><h5 id="一、timers"><a href="#一、timers" class="headerlink" title="一、timers"></a>一、timers</h5><p>timers 阶段的回调函数可能并不会按照设定的时间延迟去执行，因为 event loop 初始化或者其他阶段回调函数的长时间执行会延迟它们的执行。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAsyncOperation</span>(<span class="hljs-params">callback</span>) </span>&#123;    <span class="hljs-comment">// 假设读取文件需耗时 95ms</span>    fs.readFile(<span class="hljs-string">'./a.txt'</span>, callback)&#125;cosnt timeoutScheduled = <span class="hljs-built_in">Date</span>.now();setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> delay = <span class="hljs-built_in">Date</span>.now() - timeoutScheduled;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);&#125;, <span class="hljs-number">100</span>)someAsyncOperation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;    <span class="hljs-keyword">const</span> startCallbackTime = <span class="hljs-built_in">Date</span>.now();    <span class="hljs-keyword">while</span>   (<span class="hljs-built_in">Date</span>.now() - startCallbackTime &lt; <span class="hljs-number">10</span>) &#123;        <span class="hljs-comment">// do something</span>    &#125;&#125;)</code></pre><p>上方示例在 node 里的大致执行步骤如下：</p><ol><li>timer 阶段：因为需要延迟 100ms，所以当前没有 callback 需要执行，进入 pending callback 阶段</li><li>pending callback阶段：没有 I/O 回调需要执行，进入 idle，</li><li>idle 忽略</li><li>poll 阶段：因为此时有 I/O 操作，因此会阻塞在这里，等待95ms至文件读取结束，然后将 callback 放入队列进行执行，耗时10ms。调用结束后，当前队列为空，检查 timers，发现设定时间为95ms，当前运行时间超时了，因此进入 timer 阶段执行回调，所以会打印出”105ms has passed since I was scheduled”</li></ol><h5 id="二、poll"><a href="#二、poll" class="headerlink" title="二、poll"></a>二、poll</h5><p>poll 阶段主要有两个功能：</p><p>1.计算它应该阻塞和轮询 I/O 多长时间</p><p>2.处理该阶段事件</p><p>当 event loop 进入 poll 阶段并且未设定定时器，会出现下面中的某个情况：</p><ul><li>如果 poll 的队列不为空，那么就会遍历队列，并异步执行完所有回调函数，或者达到系统设定的最大时间</li><li>如果 poll 队列为空，那以下情况中的一个会出现：<ol><li>如果代码设定了 setImmediate 方法，event loop 会结束 poll 阶段，进入 check 阶段去执行 check 队列</li><li>如果没有设定 setImmediate 方法，就会阻塞在 poll 阶段，直到有 poll callback 添加到队列中，然后立刻执行。</li></ol></li></ul><p>如果 event loop 进入 poll 阶段并且设定了定时器：</p><ul><li>一旦 poll 队列处于空闲状态，event loop 会查看 timers 里的回调函数，如果至少有一个 回调函数的时间到了，event loop 会按循环顺序进入 timers 阶段去执行这些回调函数。</li><li>按循环顺序说的是 event loop 不会直接进入 timers 阶段，而是要先进入 check、close callback 之后，再进入 timers 阶段。</li></ul><h5 id="三、check"><a href="#三、check" class="headerlink" title="三、check"></a>三、check</h5><ul><li>这个阶段用来存放 setImmediate 回调函数，如果代码中设定了，那么 event loop 不会阻塞等待在 poll 阶段，而是会进入 check 阶段。</li><li>当 poll 阶段结束，进入check 阶段后，会调用 libuv api 去执行回调函数</li></ul><h5 id="四、API-比较"><a href="#四、API-比较" class="headerlink" title="四、API 比较"></a>四、API 比较</h5><ul><li>setTimeout 和 setImmediate<ol><li>setTimeout 设定一个任务在等待指定时间后去执行</li><li>setImmediate 在 poll 阶段完成后立即去调用它设定的代码</li><li>它们回调函数执行的顺序依据它们执行的方式会有不同：如果它们的执行不在 I/O 操作里，那么顺序时不定的，如果在 I/O 中，永远都是 setImmediate 最先执行</li></ol></li></ul><ul><li>process.nextTick</li></ul><p>在技术上来说，nextTick 不属于 event loop 的一部分，凡是放进 nextTick 队列的回调函数会在下一次 event loop 循环开始前执行。需要注意的是，正是因为这个特性，如果递归调用 nextTick，会导致下一次 event loop 无法开始。</p><h5 id="node-中宏任务和微任务"><a href="#node-中宏任务和微任务" class="headerlink" title="node 中宏任务和微任务"></a>node 中宏任务和微任务</h5><p>因为 node 中的 宏任务分处于不同的阶段，并且微任务中的 process.nextTick 都是先于其它微任务执行，所以可以理解为 有4个宏任务队列以及2个微任务队列。</p><p>这里为了便于理解，借用一张图：</p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a8667e6b79cc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" alt="node-eventloop" style="zoom:80%;;margin-left:0" /><p>这里的宏任务和微任务流程模型与浏览器的相同，区别在于：</p><ol><li>node 中的宏任务队列执行顺序取决于 event loop 所处的阶段</li><li>微任务中，process.nextTick 独处一个队列，比其他微任务要早执行</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>event loop 相当于一个总指挥，负责 js 任务的协调与调度。</p><p>参考文献 <a href="https://juejin.cn/post/6844903670291628046#heading-5" target="_blank" rel="noopener">https://juejin.cn/post/6844903670291628046#heading-5</a></p>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Event Loop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟着规范实现一个功能完备的Promise</title>
    <link href="/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/"/>
    <url>/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/</url>
    
    <content type="html"><![CDATA[<pre><code class="hljs mercury">一直以来，对于 <span class="hljs-keyword">promise</span>，只知道如何使用，其内部的运作机制却一直不得而知。为了让自己用得安心，决定跟着规范去了解底层的原理，并手写一个功能完备的 MyPromise.</code></pre><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>promise 是一个对象或者函数，拥有 then 方法</li><li>thenable 可以理解为一个拥有 then 方法的对象或函数</li><li>value 是一个合法的 JavaScript值</li><li>reason 用来表示 promise 拒绝的原因</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>promise 初始状态为 pending，可以转变成 fulfilled 或者 rejected</li><li>如果状态是 fulfilled，则不能转变为 rejected 或者 pending。rejected 同理。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>下面开始尝试第一版：</p><p>因为平时是这样用的：</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    <span class="hljs-comment">// do something</span>    resolve(<span class="hljs-string">'xxx'</span>)&#125;)</code></pre><p>于是首先创建一个 promise 构造函数，接收一个方法 executor 作为参数, 在内部直接执行，并且传入两个方法以供使用者使用。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;        executor(resolve, reject);&#125;</code></pre><p>如果调用 resolve 方法，则会将 Promise实例 状态转变成 fulfilled，如果调用 reject 方法，则会将 Promise 实例状态转变成 rejected。所以接下来给 MyPromise 构造函数添加相应属性，并实现 resolve 和 reject。</p><pre><code class="hljs kotlin">function MyPromise(executor) &#123;    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'pending'</span>;    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">null</span>;        <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;            <span class="hljs-keyword">this</span>.value = value;        &#125;            &#125;    <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;            <span class="hljs-keyword">this</span>.reason = reason;        &#125;    &#125;        executor(resolve, reject);&#125;</code></pre><p>构造函数建造完毕，现在来处理最主要的部分 then 方法，这也是规范给出详细标准的一块儿。</p><pre><code class="hljs actionscript"><span class="hljs-comment">// 可以接收两个方法作为参数, 在内部可以根据 MyPromise 实例的状态进行相应的操作</span>MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onFulfilled, onRejected)</span> </span>&#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;            &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;            &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;            &#125;&#125;</code></pre><p>当 then 执行的时候，如果 status 是 fulfilled 或者 rejected 状态，可以直接执行 onFulfilled 或者 onRejected 方法，但如果依然还是 pending，需要将这些执行操作进行等待，直到状态不是 pending，这时就需要用回调队列去存储执行操作，如下：</p><pre><code class="hljs kotlin">function MyPromise(executor) &#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">this</span>.onFulfilledStack = [];    <span class="hljs-keyword">this</span>.onRejectedStack = [];        <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;        <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;        <span class="hljs-keyword">this</span>.value = value;        <span class="hljs-comment">// 执行回调</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onFulfilledStack.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">this</span>.onFulfilledStack.shift()(<span class="hljs-keyword">this</span>.value);        &#125;    &#125;    <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;        <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;        <span class="hljs-keyword">this</span>.reason = reason;        <span class="hljs-comment">// 执行回调</span>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onRejectedStack.length &gt; <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">this</span>.onRejectedStack.shift()(<span class="hljs-keyword">this</span>.reason);        &#125;    &#125;        executor(resolve, reject);&#125;MyPromise.prototype.then = function(onFulfilled, onRejected) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;        <span class="hljs-keyword">this</span>.onFulfilledStack.push(() =&gt; &#123;            onFulfilled(<span class="hljs-keyword">this</span>.value);        &#125;)        <span class="hljs-keyword">this</span>.onRejectedStack.push(() =&gt; &#123;            onRejected(<span class="hljs-keyword">this</span>.reason)        &#125;)    &#125;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;        onFulfilled(<span class="hljs-keyword">this</span>.value);    &#125;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;        onRejected(<span class="hljs-keyword">this</span>.reason)    &#125;&#125;</code></pre><p>then 方法必须返回一个 promise，因此对 then 方法继续改造：</p><pre><code class="hljs javascript">MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;    <span class="hljs-comment">// ...</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            &#125;)&#125;</code></pre><p>到这里就要思考一下，then 方法为什么要返回一个 promise？ 原因是每一个 promise 都会有一个 then 方法，而如果 then 方法也返回一个 promise，那么这个 then 也会有一个 then 方法，于是可以像下方代码一样链式调用 ：</p><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;    resolve(<span class="hljs-string">'success'</span>)&#125;).<span class="hljs-keyword">then</span>().<span class="hljs-keyword">then</span>()</code></pre><p>但还有个原因。我们不仅可以像上方一样 resolve 一个基本值，也可以 resolve 一个 promise，而这个 promise 的状态的改变是尚未改变的，因此可以将这个 promise 放进 then 返回的这个 promise 内去等待状态改变</p><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;    resolve(<span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(_resolve, _reject)</span> =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            _resolve(<span class="hljs-string">'success'</span>)        &#125;, <span class="hljs-number">2000</span>)    &#125;))&#125;).<span class="hljs-keyword">then</span>().<span class="hljs-keyword">then</span>()MyPromsise.prototype.<span class="hljs-keyword">then</span> = function(onFulfilled, onRejected) &#123;    let _promise = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;        <span class="hljs-regexp">//</span> 因为 onFulfilled(<span class="hljs-keyword">this</span>.value) 和 onRejected(<span class="hljs-keyword">this</span>.reason) 可能返回一个 thenable，因此需要将下方代码移入新 promise内部去执行        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;            <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                onFulfilled(<span class="hljs-keyword">this</span>.value);            &#125;)            <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                onRejected(<span class="hljs-keyword">this</span>.reason)            &#125;)        &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;            onFulfilled(<span class="hljs-keyword">this</span>.value);        &#125;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;            onRejected(<span class="hljs-keyword">this</span>.reason)        &#125;    &#125;)    &#125;</code></pre><p>这里有个问题，我在内部直接调用 onFulfilled 和 onRejected，但却没有对这两个方法类型进行错误处理，也就是必须让它们是 function。</p><pre><code class="hljs javascript">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;    <span class="hljs-comment">// 设置默认的回调方法（需原样返回传进来的值或者抛出同样的值），可以保证 promise 结果能够透传</span>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;    <span class="hljs-comment">// ...</span>&#125;</code></pre><p>这里有一个处理，如果 onFulfilled 和 onRejected 不是 function，那么就将它们赋值成方法，并且将接收到的值进行相应处理：如果是 onFulfilled，直接将值 return，如果是 onRejected, 主动抛出一个错误。这也就实现了 promise 值的透传</p><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;    resolve(<span class="hljs-string">'success'</span>)&#125;).<span class="hljs-keyword">then</span>().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(value)  <span class="hljs-regexp">//</span> success&#125;)</code></pre><p>目前为止，MyPromise 已经具备了可实例化，可执行同步任务的功能。但是上述代码存在有以下问题：</p><ul><li>无法执行异步任务</li></ul><p>2.2.4： onFulfilled or onRejected must not be called until the execution context stack contains only platform code</p><p>意思是：onFulfilled 和 onRejected 方法需要异步执行。</p><p>接下来对 then 方法进行进一步完善, 将它们的执行丢入到异步环境中</p><pre><code class="hljs coffeescript">MyPromsise.prototype.<span class="hljs-keyword">then</span> = function(onFulfilled, onRejected) &#123;    <span class="hljs-regexp">//</span> ...    let _promise = <span class="hljs-literal">null</span>;    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    onFulfilled(<span class="hljs-keyword">this</span>.value);                &#125;)                <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                    onRejected(<span class="hljs-keyword">this</span>.reason)                &#125;)            &#125;)                    &#125;            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                onFulfilled(<span class="hljs-keyword">this</span>.value);            &#125;)                    &#125;                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                onRejected(<span class="hljs-keyword">this</span>.reason)            &#125;)                    &#125;    &#125;)    &#125;</code></pre><p>2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x)</p><p>意思是： 对 onFulfilled 或者 onRejected 返回的值 x 进行 resolvePromise 操作，即需要将 x 当作一个 thenable 来对待，then 返回的 promise 的 状态需要 x 的状态来决定。</p><p>这里需要注意： resolvePromise 需要 promise2 和 x 这两个参，但是 promise2 的状态需要它自身 resolve 和 reject 去改变，因此将 resolve 和 reject 也带上。</p><p>改动如下：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (this.status<span class="hljs-operator"> === </span>'pending') &#123;        this.onFulfilledStack.push(<span class="hljs-literal">()</span> =&gt; &#123;        set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;            <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Fulfilled(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span>;            resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>        &#125;)            &#125;)    this.onRejectedStack.push(<span class="hljs-literal">()</span> =&gt; &#123;        set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;            <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Rejected(<span class="hljs-params">this</span>.<span class="hljs-params">reason</span>)</span>;            resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>        &#125;)                    &#125;)    &#125;<span class="hljs-keyword">if</span> (this.status<span class="hljs-operator"> === </span>'fulfilled') &#123;    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;        <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Fulfilled(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span>;        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>    &#125;)    &#125;<span class="hljs-keyword">if</span> (this.status<span class="hljs-operator"> === </span>'rejected') &#123;    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;        <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Rejected(<span class="hljs-params">this</span>.<span class="hljs-params">reason</span>)</span>;        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>    &#125;)    &#125;</code></pre><p>接下来就是实现 resolvePromise 方法了。</p><p>按照规范 2.3 The Promise Resolution Procedure，一步步实现：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>&#123;    <span class="hljs-comment">// 2.3.1 如果 _promise 和 x 是同一个对象，reject TypeError</span>    <span class="hljs-keyword">if</span> (x<span class="hljs-operator"> === </span>_promise) &#123;        return reject(<span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError(`$&#123;<span class="hljs-params">x</span>&#125; <span class="hljs-params">should</span> <span class="hljs-params">no</span> <span class="hljs-params">refer</span> <span class="hljs-params">to</span> <span class="hljs-params">the</span> <span class="hljs-params">same</span> <span class="hljs-params">object</span> <span class="hljs-params">with</span> MyPromise`)</span>)    &#125;        <span class="hljs-comment">// 当 x 是对象或者函数时：</span>    <span class="hljs-comment">// 判断 x.then 方法中 onFulfilled 回调或者 onRejecetd 回调是否执行过</span>    <span class="hljs-comment">// 因为规范规定：其中每一个回调只能执行一次</span>    <span class="hljs-comment">// 当其中某项执行过，就将 hasCalled 置为 true</span>    <span class="hljs-keyword">let</span> hasCalled = <span class="hljs-literal">false</span>;        <span class="hljs-keyword">if</span> (x instanceof MyPromsie) &#123;        <span class="hljs-comment">// 如果状态没有改变，则需要调用 then 方法，然后在内部还需要对以后的返回值进行 resolvePromise </span>        <span class="hljs-keyword">if</span> (x.status<span class="hljs-operator"> === </span>'pending') &#123;            x.<span class="hljs-keyword">then</span>(y =&gt; &#123;                resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">y</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>            &#125;,<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> &#123;                resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">err</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>            &#125;)        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果状态已经改变，那么 x 就会有一个正常值，假设为 z</span>            <span class="hljs-comment">// 执行 x.then(resolve, reject)，会直接调用 resolve(z) 或者 reject(z) ：</span>            <span class="hljs-comment">// 2.3.2.2 &amp;&amp; 2.3.2.3</span>            x.<span class="hljs-keyword">then</span>(resolve, reject);        &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype.toString.call(x)<span class="hljs-operator"> === </span>'<span class="hljs-literal">[<span class="hljs-identifier">object</span> O<span class="hljs-identifier">bject</span>]</span>'<span class="hljs-operator"> || </span>typeof x<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>') &#123; <span class="hljs-comment">// x 是对象或者函数</span>        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">let</span> <span class="hljs-keyword">then</span> = x.<span class="hljs-keyword">then</span>;            <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">then</span><span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>') &#123;                <span class="hljs-keyword">then</span>.call(x,<span class="hljs-function"> <span class="hljs-params">y</span> =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (hasCalled) &#123; return &#125;                    hasCalled = <span class="hljs-literal">true</span>;                    resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">y</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>                &#125;,<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> &#123;                    <span class="hljs-keyword">if</span> (hasCalled) &#123; return &#125;                    hasCalled = <span class="hljs-literal">true</span>;                    reject(err);                &#125;)            &#125; <span class="hljs-keyword">else</span> &#123;                resolve(x)            &#125;        &#125; catch(err) &#123;            <span class="hljs-comment">// 2.3.3.3.4.1</span>            <span class="hljs-comment">// if resolvePromise or rejectPromise have been called, ignore it.</span>            <span class="hljs-keyword">if</span> (!hasCalled) &#123;                reject(err)            &#125;        &#125;            &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-comment">// 2.3.4</span>        resolve(x);    &#125;&#125;</code></pre><p>如果能通过 promiseA+ 测试，说明该版本的 Promise 符合规范，但是还缺少常用的功能，继续完善：</p><ul><li>MyPromise.resolve</li></ul><p>接收一个值，在内部创建一个新的实例，将状态交给新实例去处理</p><pre><code class="hljs arcade">MyPromise.prototype.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        resolve(value)    &#125;)&#125;</code></pre><p>#发</p><ul><li>MyPromise.catch</li></ul><p>接收一个方法，只会在 rejected 状态下执行</p><pre><code class="hljs actionscript">MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, callback);&#125;</code></pre><ul><li>MyPromise.finally</li></ul><p>接收一个方法，不论 fulfilled 或者 rejected 都会执行</p><pre><code class="hljs actionscript">MyPromise.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(callback, callback);&#125;</code></pre><ul><li>MyPromise.all</li></ul><p>接收一个数组，只有所有项的状态为 fulfilled，最终结果才为 fulfilled，如果有一个 rejected，那么结果就是 rejected</p><pre><code class="hljs typescript">MyPromise.prototype.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> result = [];        <span class="hljs-keyword">let</span> resolveCount = <span class="hljs-number">0</span>;        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;                result[index] = value;                resolveCount++;                <span class="hljs-keyword">if</span> (resolveCount === promiseArr.length) &#123;                    resolve(result);                &#125;            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                reject(err)            &#125;)        &#125;)    &#125;)&#125;</code></pre><ul><li>MyPromise.race</li></ul><p>接收一个数组，结果由第一个状态改变的 thenable 决定</p><pre><code class="hljs typescript">MyPromise.prototype.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;                resolve(value);            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                reject(err)            &#125;)        &#125;)    &#125;)&#125;</code></pre><ul><li>MyPromise.allSettled</li></ul><p>接收一个数组，只有等到所有项的状态都改变了，不论是 fulfilled 还是 rejected，都只会变成 fulfilled</p><pre><code class="hljs typescript">MyPromise.prototype.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> resultArr = [];        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;                resultArr.push(&#123;status: <span class="hljs-string">'fulfilled'</span>, value: value&#125;);                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;                    resolve(resultArr);                &#125;            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                resultArr.push(&#123;status: <span class="hljs-string">'rejected'</span>, reason: err&#125;);                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;                    resolve(resultArr);                &#125;            &#125;)        &#125;)    &#125;)&#125;</code></pre><ul><li>MyPromise.any</li></ul><p>接收一个数组，如果其中有一项的状态为 fulfilled， 那么结果就是 fulfilled，否则如果所有都是 rejected，那结果就是 rejected， 并且 reanson 是 ‘AggregateError: All promises were rejected’</p><pre><code class="hljs typescript">MyPromise.prototype.any = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        <span class="hljs-keyword">let</span> rejectCount = <span class="hljs-number">0</span>;        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;                resolve(value);            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;                rejectCount ++;                <span class="hljs-keyword">if</span> (rejectCount === promiseArr.length) &#123;                    reject(<span class="hljs-string">'AggregateError: All promises were rejected'</span>);                &#125;            &#125;)        &#125;)    &#125;)&#125;</code></pre><p>测试方法：</p><p>#安装 promises-aplus-tests</p><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i promises-aplus-tests -g</code></pre><p>#在代码里加上这段</p><pre><code class="hljs go">MyPromise.deferred = function () &#123;    <span class="hljs-keyword">const</span> <span class="hljs-keyword">defer</span> = &#123;&#125;;    <span class="hljs-keyword">defer</span>.promise = <span class="hljs-built_in">new</span> MyPromise((resolve, reject) =&gt; &#123;        <span class="hljs-keyword">defer</span>.resolve = resolve;        <span class="hljs-keyword">defer</span>.reject = reject;    &#125;)    <span class="hljs-keyword">return</span> <span class="hljs-keyword">defer</span>;&#125;</code></pre><p>#最后</p><pre><code class="hljs css"><span class="hljs-selector-tag">promises-aplus-tests</span> <span class="hljs-selector-tag">promise</span><span class="hljs-selector-class">.js</span></code></pre><p>有一点需要注意：我在实现 promise 内部异步执行时采用的是 setTimeout，但是 promise 的 then 方法是一个微任务，但 setTimeout 是一个宏任务，这与实际有出入。所以这里只是作为代替。</p><p>完整代码地址：<a href="https://github.com/yuwengCipher/MyPromise" target="_blank" rel="noopener">https://github.com/yuwengCipher/MyPromise</a></p>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说 js 的异步处理机制</title>
    <link href="/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h4><p>在 js 中和生活中都会有异步任务的存在，而异步的产生是有前提条件的，那就是这个任务可以被拆解成两部分。</p><p>举个简单的例子。周末我想喝点排骨汤，把所有步骤都准备好后开火炖。正常来说，这锅汤需要3小时才能煲好，很显然我不会傻傻守在这儿等它3小时，因为我还有别的事要做，比如说看电视，嗑瓜子等等。而是3小时后汤煲好了，我才回去盛起来喝。</p><p>所以这个喝汤任务由两个步骤组成：煲汤 + 喝汤；这个喝汤步骤就是异步的</p><h4 id="设计成异步的原因"><a href="#设计成异步的原因" class="headerlink" title="设计成异步的原因"></a>设计成异步的原因</h4><p>从上面可以知道，如果我傻傻的在锅前等3个小时，那么我看电视、嗑瓜子等事情就得向后延3小时，到最后我这一天做不了什么，所以傻等3小时完全是浪费时间。</p><p>js 是单线程，同一时间只能做一件事，长时间的等待势必会造成资源的浪费</p><h4 id="异步实现方案"><a href="#异步实现方案" class="headerlink" title="异步实现方案"></a>异步实现方案</h4><ul><li>回调函数</li></ul><p>回调函数在 js 代码里随处可见，如给 DOM 添加点击事件</p><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> d = document.get<span class="hljs-constructor">ElementId('<span class="hljs-params">test</span>')</span>;d.add<span class="hljs-constructor">EventListener('<span class="hljs-params">click</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">e</span>)</span> &#123;    <span class="hljs-comment">// do something</span>&#125;)<span class="hljs-comment">// callback 就是回调函数</span></code></pre><p>node 里去读取一份文件</p><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;    <span class="hljs-comment">// do something</span>&#125;)</code></pre><p>但是有时候的需求会比较复杂，加入多个任务存在依赖性，就会写出如下代码：</p><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test1</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback1</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;        fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test2</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback2</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;            <span class="hljs-comment">// ...</span>        &#125;)    &#125;)&#125;)</code></pre><p>深层嵌套让我们很是绝望！</p><ul><li>promise</li></ul><p>幸运的是后来有了 promise，带我们逃离了“回调地狱”，来到新世界：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> =&gt; &#123;    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;        resolve(data);    &#125;)&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text1</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback1</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data1</span>)</span>&#123;        <span class="hljs-comment">// do something</span>        resolve(data1);    &#125;)&#125;).<span class="hljs-keyword">then</span>(data =&gt; &#123;    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text1</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback2</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data2</span>)</span>&#123;        <span class="hljs-comment">// do something</span>        resolve(data2);    &#125;)&#125;)</code></pre><p>这样写之后是不是看起来清爽了，瞬间头也不晕了，promise 让流程执行的过程更清晰！</p><p>但是你一定见过这样的代码：</p><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;    fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;        resolve(data);    &#125;)&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    <span class="hljs-comment">// do something</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    <span class="hljs-comment">// do something</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    <span class="hljs-comment">// do something</span>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;    <span class="hljs-comment">// do something</span>&#125;)...</code></pre><p>真的是链式调用一时爽，一直链式调用… 就有点难受了。 promise 抑制了回调地狱的横向扩张，却发现自己的纵向扩张也很厉害。</p><ul><li>generator</li></ul><p>generator 函数与普通的函数不同，函数内的代码可以分段执行，也就是说可以暂停执行，凡是需要暂停的地方用 yield 关键字注明。具体用法参考阮老师文章的介绍 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/04/generator.html</a></p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;    <span class="hljs-keyword">return</span> y;&#125;<span class="hljs-keyword">let</span> gen = genFn();gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span></code></pre><p>于是对于上面依次读取文件的例子可以改写成如下形式：</p><pre><code class="hljs reasonml"><span class="hljs-comment">// 模拟文件请求</span><span class="hljs-keyword">function</span> fake<span class="hljs-constructor">ReadFile(<span class="hljs-params">filename</span>, <span class="hljs-params">duration</span>)</span> &#123;    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;        console.log(filename)        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span>        gen.next(filename)    &#125;, duration)&#125;<span class="hljs-keyword">function</span>* gen<span class="hljs-constructor">Fn()</span> &#123;    <span class="hljs-comment">// 顺序请求三个文件，期望的是顺序打印出结果</span>    yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">a</span>.<span class="hljs-params">txt</span>', 5000)</span>;    yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">b</span>.<span class="hljs-params">txt</span>', 3000)</span>;    yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">c</span>.<span class="hljs-params">txt</span>', 1000)</span>;&#125;const gen = gen<span class="hljs-constructor">Fn()</span>;gen.next<span class="hljs-literal">()</span>;<span class="hljs-comment">// a.txt   5秒后打印</span><span class="hljs-comment">// b.txt   8秒后打印</span><span class="hljs-comment">// c.txt   9秒后打印</span></code></pre><p>虽然获取文件所需时长 a &gt; b &gt; c, 但是打印的结果却是 a，b，c，也就是说在 generator 函数内，yield 是按上到下执行的，使得代码依赖顺序更清晰明了。</p><p>可以看到我需要在文件请求完成之后手动调用 next 方法，因此在实际工作中，我们通常需要将 generator 函数包裹在一个函数内：</p><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> call<span class="hljs-constructor">Gen()</span> &#123;    <span class="hljs-keyword">function</span>* gen<span class="hljs-constructor">Fn()</span> &#123;        yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">a</span>.<span class="hljs-params">txt</span>', 5000, <span class="hljs-params">gen</span>)</span>;        yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">b</span>.<span class="hljs-params">txt</span>', 3000, <span class="hljs-params">gen</span>)</span>;        yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">c</span>.<span class="hljs-params">txt</span>', 1000, <span class="hljs-params">gen</span>)</span>;    &#125;    const gen = gen<span class="hljs-constructor">Fn()</span>;    gen.next<span class="hljs-literal">()</span>;&#125;<span class="hljs-keyword">function</span> fake<span class="hljs-constructor">ReadFile(<span class="hljs-params">filename</span>, <span class="hljs-params">duration</span>, <span class="hljs-params">g</span>)</span> &#123;    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;        console.log(filename)        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span>        g.next(filename)    &#125;, duration)&#125;call<span class="hljs-constructor">Gen()</span>;</code></pre><p>总的来说，generator 函数改善了 promise 的 then “链条”过长的缺点，但是需要额外创建一个函数来包装。</p><ul><li>async await</li></ul><p>作为 ES7 提出的 async 函数，在 generator 基础上进行优化，是目前 js 处理异步操作的最优解决方案，让异步处理代码可读性更强，流程控制更方便。</p><p>我们按照 async 方法的用法来继续优化上面的例子：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;    <span class="hljs-comment">// 因为 await 关键字后面需要接收一个 promise</span>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            resolve(filename)        &#125;, duration)    &#125;)&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);    <span class="hljs-built_in">console</span>.log(a)    <span class="hljs-built_in">console</span>.log(b)    <span class="hljs-built_in">console</span>.log(c)&#125;asyncFn();<span class="hljs-comment">// 9秒后一次性打印</span><span class="hljs-comment">// a.txt </span><span class="hljs-comment">// b.txt </span><span class="hljs-comment">// c.txt</span></code></pre><p>需要注意的是如果 await 后面表达式里包含异步操作但返回的不是 promise，那么就就不会等待到结果返回，比如这样修改：</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;    <span class="hljs-keyword">if</span> (filename === <span class="hljs-string">'a.txt'</span>) &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;            <span class="hljs-keyword">return</span> filename        &#125;, duration)    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;                resolve(filename)            &#125;, duration)        &#125;)    &#125;&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);    <span class="hljs-built_in">console</span>.log(a)    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);    <span class="hljs-built_in">console</span>.log(b)    <span class="hljs-built_in">console</span>.log(c)&#125;asyncFn();<span class="hljs-comment">// undefined 立刻输出</span><span class="hljs-comment">// b.txt     4秒之后输出</span><span class="hljs-comment">// c.txt     4秒之后输出</span></code></pre><p>也就是说第一个 await 没有阻塞 console.log(a) 的执行。因此 async 对 await 后面的表达式又两种处理方式：</p><pre><code class="hljs javascript"><span class="hljs-number">1.</span> promise   <span class="hljs-keyword">async</span> 会执行表达式并等待有返回值才会继续往下执行代码<span class="hljs-number">2.</span> 非 promise   <span class="hljs-keyword">async</span> 执行表达式并立刻获取返回值，如果没有则为 <span class="hljs-literal">undefined</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>js 处理异步的方法经历了 回调函数、promise、generator、async 这四个阶段，每一种新方法都是对前方法的改善，主要处理的点有两点：</p><ol><li>可读性更强</li><li>流程控制更清晰</li></ol>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
