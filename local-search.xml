<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>一个简单的网络请求过程</title>
    <link href="/2021/04/10/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/04/10/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
      <tag>TCP</tag>
      
      <tag>DNS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>axios-总体结构</title>
    <link href="/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <url>/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><strong>本文基于 axios 版本 0.21.1</strong></p><h4 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h4><p>在根目录下找到 index.js，里面只有一句代码，将 axios 进行导出。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">module.exports</span> = require(<span class="hljs-string">'./lib/axios'</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>找到 lib 下的 axios.js 文件</p><ul><li><p>首先引入了相关文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 工具函数库</span><br><span class="hljs-keyword">var</span> utils = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./utils'</span>);<br><span class="hljs-comment">// bind 方法，返回 function wrap</span><br><span class="hljs-keyword">var</span> bind = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./helpers/bind'</span>);<br><span class="hljs-comment">// Axios 构造函数</span><br><span class="hljs-keyword">var</span> Axios = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/Axios'</span>);<br><span class="hljs-comment">// 合并参数</span><br><span class="hljs-keyword">var</span> mergeConfig = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./core/mergeConfig'</span>);<br><span class="hljs-comment">// 默认设置和属性</span><br><span class="hljs-keyword">var</span> defaults = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./defaults'</span>);<br></code></pre></td></tr></table></figure></li><li><p>创建 axios 实例的方法</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">function</span> createInstance (defaultConfig) &#123;<br><span class="hljs-comment">// 创建 Axios 实例</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">context</span> = <span class="hljs-keyword">new</span> Axios(defaultConfig);<br><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">instance</span> = <span class="hljs-keyword">bind</span>(Axios<span class="hljs-variable">.prototype</span><span class="hljs-variable">.request</span>, <span class="hljs-keyword">context</span>);<br>utils<span class="hljs-variable">.extend</span>(<span class="hljs-keyword">instance</span>, Axios<span class="hljs-variable">.prototype</span>, <span class="hljs-keyword">context</span>);<br>utils<span class="hljs-variable">.extend</span>(<span class="hljs-keyword">instance</span>, <span class="hljs-keyword">context</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">instance</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        bind 方法代码如下：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs matlab"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bind</span> <span class="hljs-params">(fn, thisArg)</span> &#123;</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">wrap</span> <span class="hljs-params">()</span> &#123;</span><br>var args = new Array(arguments.<span class="hljs-built_in">length</span>);<br><span class="hljs-keyword">for</span> (var <span class="hljs-built_in">i</span> = <span class="hljs-number">0</span>; <span class="hljs-built_in">i</span> &lt; args.<span class="hljs-built_in">length</span>; <span class="hljs-built_in">i</span>++) &#123;<br>args[<span class="hljs-built_in">i</span>] = arguments[<span class="hljs-built_in">i</span>];<br>&#125;<br><span class="hljs-keyword">return</span> fn.apply(thisArg, args);<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>​        bind 方法的逻辑很简单，就是返回 一个wrap 函数，函数内部会使用 context 调用 Axios.prototype.request。bind执行完后就将 Axios.prototype 和 context 的属性赋值给 wrap 函数。</p><p>​        在该文件后续部分我们可以看到以下两行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br><span class="hljs-keyword">var</span> axios = createInstance(defaults);<br>...<br><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = axios;<br></code></pre></td></tr></table></figure><p>执行 createInstance 方法返回的 instance 赋值给了 axios，那么 axios 的值就是 wrap 函数，这也就是为什么我们使用 axios 时，既可以调用它的方法，也可以直接执行它的原因。</p></li></ul><p>到这里，我们明白了 axios 是什么以及如何创建它的实例。</p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>前面的处理将 Axios 相关属性赋予给了 wrap 函数，那到底是哪些属性呢？该小节将会详细了解下构造函数 Axios。</p><p><strong>文件位于  axios/core/Axios</strong> </p><p>首先引入所需依赖，大概知道是干什么的就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对请求路径进行一些格式化</span><br><span class="hljs-keyword">var</span> buildURL = <span class="hljs-built_in">require</span>(<span class="hljs-string">'../helpers/buildURL'</span>);<br><span class="hljs-comment">// 拦截器构造函数</span><br><span class="hljs-keyword">var</span> InterceptorManager = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./InterceptorManager'</span>);<br><span class="hljs-comment">// 发起 request 请求</span><br><span class="hljs-keyword">var</span> dispatchRequest = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./dispatchRequest'</span>);<br></code></pre></td></tr></table></figure><p>接着往下看</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Axios</span> <span class="hljs-params">(instanceConfig)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.defaults = instanceConfig;<br><span class="hljs-comment">// 拦截器对象</span><br><span class="hljs-keyword">this</span>.interceptors = &#123;<br>request: <span class="hljs-keyword">new</span> InterceptorManager(),<br>response: <span class="hljs-keyword">new</span> InterceptorManager()<br>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在创建实例时可接收一个配置参数</li><li>将接收的配置赋值给自身的 defaults 属性</li><li>拥有一个 拦截器对象，该对象包括请求拦截器和相应拦截器</li><li>拦截器实例是在创建 Axios 实例时才会创建</li></ul><h5 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h5><p>在日常使用中，拦截器的配置是最重要的一部分。我们通过上方路径找到拦截器构造函数文件。</p><p>​        构造函数拥有一个 handlers 数组，用来存储拦截器。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">InterceptorManager</span> <span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">this</span>.handlers = [];<br>&#125;<br></code></pre></td></tr></table></figure><p>​        然后给构造函数原型添加方法函数</p><ol><li><p>使用 use 方法添加一个新的拦截器，</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gradle">InterceptorManager.prototype.use = function use (fulfilled, rejected, <span class="hljs-keyword">options</span>) &#123;<br><span class="hljs-keyword">this</span>.handlers.<span class="hljs-keyword">push</span>(&#123;<br>fulfilled: fulfilled,<br>rejected: rejected,<br>synchronous: <span class="hljs-keyword">options</span> ? <span class="hljs-keyword">options</span>.synchronous : <span class="hljs-keyword">false</span>,<br>runWhen: <span class="hljs-keyword">options</span> ? <span class="hljs-keyword">options</span>.runWhen : <span class="hljs-keyword">null</span><br>&#125;);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.handlers.length - <span class="hljs-number">1</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>每个拦截器包括四个属性：<ol><li>fulfilled：一个方法，在请求或相应被 then 处理前执行</li><li>rejected：一个方法，在请求或相应被 reject 处理前执行</li><li>synchronous：请求拦截器是否采用同步执行机制</li><li>runwhen：表明请求拦截器什么情况下执行。默认为 null，也可以是一个函数。</li></ol></li><li>use 方法返回当前拦截器在拦截器数组中的位置下标</li></ol></li><li><p>使用 eject 方法清除一个拦截器。参数 id 就是拦截器在数组中的下标。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">InterceptorManager.prototype.eject = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">eject</span> <span class="hljs-params">(id)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.handlers[id]) &#123;<br><span class="hljs-comment">// 将下标为 id 处的拦截器置为 null</span><br><span class="hljs-keyword">this</span>.handlers[id] = <span class="hljs-literal">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 forEach 方法执行符合条件的拦截器</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">InterceptorManager.prototype.<span class="hljs-keyword">forEach</span> = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEach</span> <span class="hljs-params">(fn)</span> </span>&#123;<br><span class="hljs-comment">// 遍历拦截器存储数组，执行 fn 时会过滤掉数组中被置为 null 的值。</span><br>utils.<span class="hljs-keyword">forEach</span>(this.handlers, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachHandler</span> <span class="hljs-params">(h)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (h !== <span class="hljs-keyword">null</span>) &#123;<br>fn(h);<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="挂载方法"><a href="#挂载方法" class="headerlink" title="挂载方法"></a>挂载方法</h5><p>构造函数内部添加完属性后，紧接着就是在构造函数原型上添加相应方法：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-comment">// 为 Axios 原型挂载 request 和 getUri 方法</span><br>Axios.prototype.request = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;<br>Axios.prototype.getUri = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getUri</span> (<span class="hljs-params">config</span>) </span>&#123;...&#125;<br><br><span class="hljs-comment">// 为 Axios 原型挂载支持的 method</span><br>utils.forEach([<span class="hljs-string">'delete'</span>, <span class="hljs-string">'get'</span>, <span class="hljs-string">'head'</span>, <span class="hljs-string">'options'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodNoData</span> (<span class="hljs-params">method</span>) </span>&#123;<br>Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, config</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<br><span class="hljs-attribute">method</span>: method,<br><span class="hljs-attribute">url</span>: <span class="hljs-built_in">url</span>,<br><span class="hljs-comment">// 使用这些 method时，有可能不会传 data 属性，所以使用默认的 data</span><br><span class="hljs-attribute">data</span>: (config || &#123;&#125;).data <br>&#125;));<br>&#125;;<br>&#125;);<br>utils.forEach([<span class="hljs-string">'post'</span>, <span class="hljs-string">'put'</span>, <span class="hljs-string">'patch'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">forEachMethodWithData</span> (<span class="hljs-params">method</span>) </span>&#123;<br>Axios.prototype[method] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">url, data, config</span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.request(mergeConfig(config || &#123;&#125;, &#123;<br><span class="hljs-attribute">method</span>: method,<br><span class="hljs-attribute">url</span>: <span class="hljs-built_in">url</span>,<br><span class="hljs-attribute">data</span>: data<br>&#125;));<br>&#125;;<br>&#125;)<br></code></pre></td></tr></table></figure><p>其中包括 HTTP 请求同名的方法 。这些方法会被代理给原型的 request 方法，Axios 将支持的请求的 methods 按照是否需要默认 data 属性分为两类，现在来看看 request 方法的实现。</p><h5 id="request"><a href="#request" class="headerlink" title="request"></a>request</h5><ul><li><p>首先是基本参数的一个默认设置以及合并</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 兼容 axios('example/url'[, config]) 这种传参方式</span><br><span class="hljs-keyword">if</span> (typeof config<span class="hljs-operator"> === </span>'<span class="hljs-built_in">string</span>') &#123;<br>    config = arguments<span class="hljs-literal">[<span class="hljs-number">1</span>]</span><span class="hljs-operator"> || </span>&#123;&#125;;<br>    config.url = arguments<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    config = config<span class="hljs-operator"> || </span>&#123;&#125;;<br>&#125;<br><br><span class="hljs-comment">// 合并 config</span><br>config = merge<span class="hljs-constructor">Config(<span class="hljs-params">this</span>.<span class="hljs-params">defaults</span>, <span class="hljs-params">config</span>)</span>;<br><br><span class="hljs-comment">// 设置 config.method， 默认小写，默认 get 方法</span><br><span class="hljs-keyword">if</span> (config.<span class="hljs-keyword">method</span>) &#123;<br>    config.<span class="hljs-keyword">method</span> = config.<span class="hljs-keyword">method</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (this.defaults.<span class="hljs-keyword">method</span>) &#123;<br>    config.<span class="hljs-keyword">method</span> = this.defaults.<span class="hljs-keyword">method</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    config.<span class="hljs-keyword">method</span> = 'get';<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>对拦截器队列的处理</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 请求拦截器队列</span><br><span class="hljs-keyword">var</span> requestInterceptorChain = [];<br><span class="hljs-comment">// 请求拦截器是否同步执行</span><br><span class="hljs-keyword">var</span> synchronousRequestInterceptors = <span class="hljs-literal">true</span>;<br><br><span class="hljs-keyword">this</span>.interceptors.request.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">unshiftRequestInterceptors</span> <span class="hljs-params">(interceptor)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> interceptor.runWhen === <span class="hljs-string">'function'</span> &amp;&amp; interceptor.runWhen(config) === <span class="hljs-literal">false</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为 interceptor.synchronous 默认为 false，所以 synchronousRequestInterceptors 默认为 false，</span><br>    synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous;<br><br>    <span class="hljs-comment">// 每个拦截器由执行成功和执行失败处理方法组成</span><br>    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);<br>&#125;);<br><br><span class="hljs-comment">// 响应拦截器链</span><br><span class="hljs-keyword">var</span> responseInterceptorChain = [];<br><br><span class="hljs-keyword">this</span>.interceptors.response.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pushResponseInterceptors</span> <span class="hljs-params">(interceptor)</span> </span>&#123;<br>    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p>请求拦截器 执行机制的处理</p><p>​        请求拦截器 执行机制由上面的 synchronousRequestInterceptors 决定，分为 异步和同步两种。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> promise;<br><br><span class="hljs-comment">// 异步执行</span><br><span class="hljs-keyword">if</span> (!synchronousRequestInterceptors) &#123;<br><span class="hljs-comment">// 调用处理方法队列</span><br>    <span class="hljs-keyword">var</span> chain = [dispatchRequest, undefined];<br><span class="hljs-comment">// 将请求拦截器处理方法和响应拦截器处理方法分别放入队列前后</span><br>    <span class="hljs-keyword">Array</span>.prototype.unshift.apply(chain, requestInterceptorChain);<br>    chain.concat(responseInterceptorChain);<br><br>    promise = Promise.resolve(config);<br>    <span class="hljs-comment">// 将包含了请求拦截器的 chain 交给 promise 来处理  </span><br>    <span class="hljs-keyword">while</span> (chain.length) &#123;<br>        promise = promise.then(chain.shift(), chain.shift());<br>    &#125;<br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br><br><span class="hljs-comment">// 同步执行</span><br><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">Config</span> = config;<br><br><span class="hljs-comment">// 先一次性执行完请求拦截器</span><br><span class="hljs-keyword">while</span> (requestInterceptorChain.length) &#123;<br>    <span class="hljs-keyword">var</span> onFulfilled = requestInterceptorChain.shift();<br>    <span class="hljs-keyword">var</span> onRejected = requestInterceptorChain.shift();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Config</span> = onFulfilled(<span class="hljs-keyword">new</span><span class="hljs-type">Config</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>        onRejected(error);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 再异步执行 dispatchRequest（如 XHR），</span><br>    promise = dispatchRequest(<span class="hljs-keyword">new</span><span class="hljs-type">Config</span>);<br>&#125; <span class="hljs-keyword">catch</span> (error) &#123;<br>    <span class="hljs-keyword">return</span> Promise.reject(error);<br>&#125;<br><span class="hljs-comment">// 最后异步执行响应拦截器</span><br><span class="hljs-keyword">while</span> (responseInterceptorChain.length) &#123;<br>    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());<br>&#125;<br><br><span class="hljs-keyword">return</span> promise;<br></code></pre></td></tr></table></figure><p>对拦截器处理的总结：</p><ul><li>存在三个 chain：请求拦截器 requestInterceptorChain 、响应拦截器 responseInterceptorChain、真正的 request 调用 originChain</li><li>拦截器以成对的形式存在，放入对应的拦截器 chain 中</li><li>请求拦截器对依次插入到 chain 头；相应拦截器对依次插入到 chain 尾</li><li>请求拦截器可以同步执行也可以异步执行：<ul><li>如果是异步执行，则会将requestInterceptorChain 插入到 originChain 队头，将 responseInterceptorChain 插入到 originChain 队尾；然后对 originChain 内的元素放入 promise.then 中执行</li><li>如果是同步执行，则会将 requestInterceptorChain 内的元素以迭代的方式执行完毕，然后执行 originChain 内的 request，最后将 responseInterceptorChain 内的元素放入 promise.then 中执行</li></ul></li></ul><p>最后通过一张图来理解请求拦截器处理不同的机制</p></li></ul><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/axios_%E6%89%A7%E8%A1%8C%E5%9B%BE.jpg" srcset="/img/loading.gif" lazyload alt="axios 执行图"></p>]]></content>
    
    
    <categories>
      
      <category>Axios</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2-总体结构</title>
    <link href="/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/"/>
    <url>/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Vue2-compiler</title>
    <link href="/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/compiler/"/>
    <url>/2021/04/06/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/compiler/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅析 generator 与 async 原理</title>
    <link href="/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/"/>
    <url>/2021/04/04/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h4 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h4><p>geneartor 和 async 都是 js 处理异步操作发展历程的产物，它们让异步编程越来越像同步编程。但是由于采用新的语法、关键字，它们是如何做到“类同步”操作的，我们不得而知，因此这篇文章将会窥探内部的秘密。</p><p>下面将借助 babel 本地编译示例代码来进行分析。</p><h4 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h4><p> 一、全局安装 regenerator</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i regenerator -g<br></code></pre></td></tr></table></figure><p> 二、编译 generator</p><p>​        命令加上 –include-runtime，可以得到完整的编译代码</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">regenerator --include-runtime <span class="hljs-keyword">test</span><span class="hljs-number">.</span><span class="hljs-keyword">js</span> &gt; <span class="hljs-keyword">test</span>-fill<span class="hljs-number">.</span><span class="hljs-keyword">js</span><br></code></pre></td></tr></table></figure><p>test-fill.js 就是编译后的代码文件。</p><h4 id="解析-generator"><a href="#解析-generator" class="headerlink" title="解析 generator"></a>解析 generator</h4><p>现在有如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">let</span> gen = genFn();<br>gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>调用 genFn 并不会直接执行，而是会返回一个 generator 对象，每次调用它的 next 方法会执行一个 yield 语句，并返回当前的值及状态。</p><p>这是编译后的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> _marked = <span class="hljs-comment">/*#__PURE__*/</span>regeneratorRuntime.mark(genFn);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> regeneratorRuntime.wrap(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>_context.next = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>_context.next = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>_context.next = <span class="hljs-number">6</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<br><span class="hljs-keyword">return</span> _context.stop();<br>&#125;<br>&#125;<br>&#125;, _marked);<br>&#125;<br><br><span class="hljs-keyword">var</span> g = genFn();<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br><span class="hljs-built_in">console</span>.log(g.next());<br></code></pre></td></tr></table></figure><p>可以看到 genFn 被改写了，调用 regeneratorRuntime.wrap 方法创建，其中传给 wrap 方法的 genFn$ 函数，里面的逻辑很简单，是一个永远都会执行的迭代，里面 switch 中的 case 是原代码中 yield 关键字所在的行数，genFn$ 的参数 _context 记录了原代码的执行上下文内容，每次调用 next 方法，实际上就会调用 genFn$，然后执行对应的逻辑。</p><p>大致的流程弄清楚之后，再来看看 regeneratorRuntime。</p><p>wrap 方法第二个参是 mark(genFn) 的值， mark 方法如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> $<span class="hljs-built_in">Symbol</span> = <span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span> === <span class="hljs-string">"function"</span> ? <span class="hljs-built_in">Symbol</span> : &#123;&#125;;<br><span class="hljs-keyword">var</span> iteratorSymbol = $<span class="hljs-built_in">Symbol</span>.iterator || <span class="hljs-string">"@@iterator"</span>;<br><br><span class="hljs-keyword">var</span> toStringTagSymbol = $<span class="hljs-built_in">Symbol</span>.toStringTag || <span class="hljs-string">"@@toStringTag"</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">GeneratorFunctionPrototype</span> (<span class="hljs-params"></span>) </span>&#123; &#125;<br><br><span class="hljs-keyword">var</span> IteratorPrototype = &#123;&#125;;<br>IteratorPrototype[iteratorSymbol] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;;<br>GeneratorFunctionPrototype.prototype = <span class="hljs-built_in">Object</span>.create(IteratorPrototype);<br><br>exports.mark = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">genFun</span>) </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">Object</span>.setPrototypeOf) &#123;<br><span class="hljs-built_in">Object</span>.setPrototypeOf(genFun, GeneratorFunctionPrototype);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>genFun.__proto__ = GeneratorFunctionPrototype;<br>define(genFun, toStringTagSymbol, <span class="hljs-string">"GeneratorFunction"</span>);<br>&#125;<br>genFun.prototype = <span class="hljs-built_in">Object</span>.create(Gp);<br><span class="hljs-keyword">return</span> genFun;<br>&#125;;<br></code></pre></td></tr></table></figure><ol><li>IteratorPrototype 对象添加 Symbol.iterator属性，使得 IteratorPrototype 拥有 Iterator 接口</li><li>GeneratorFunctionPrototype 函数的原型指向 IteratorPrototype ，所以 GeneratorFunctionPrototype 也拥有 Iterator 接口</li><li>genFun 的   <strong>proto</strong>  指向 GeneratorFunctionPrototype ，同理 genFun  拥有 Iterator 接口</li><li>mark 返回 genFun</li></ol><p>也就是说 mark 方法返回一个拥有 Iterator 接口 genFun。现在看下 wrap 方法。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs smali">function wrap (innerFn, outerFn, self, tryLocsList) &#123;<br>// 确保 protoGenerator 拥有 Itrator 接口<br>var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn<span class="hljs-keyword"> :</span> Generator;<br>var generator = Object.create(protoGenerator.prototype);<br>// context 即 genFn$ 的参数 _context <br>var context =<span class="hljs-built_in"> new </span>Context(try<span class="hljs-class">LocsList || []);</span><br><br>// ._invoke 方法整合了 next、throw 和<span class="hljs-built_in"> return </span>方法<br>generator._invoke = makeInvokeMethod(innerFn, self, context);<br><br><span class="hljs-built_in">return </span>generator;<br>&#125;<br><br>// _invoke 即内部的 invoke<br>function makeInvokeMethod (innerFn, self, context) &#123;<br>   <span class="hljs-built_in"> return </span>function<span class="hljs-built_in"> invoke </span>(method, arg) &#123;<br>        // ...<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>先看看 _invoke 在哪儿调用</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> Gp = GeneratorFunctionPrototype.prototype = Generator.prototype<br><br>defineIteratorMethods(Gp);<br><span class="hljs-comment">// 为 Generator 添加 prototype 添加 next、throw、return 方法</span><br><span class="hljs-comment">// 并且这些方法都会调用 _invoke 方法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineIteratorMethods</span> <span class="hljs-params">(prototype)</span> </span>&#123;<br>[<span class="hljs-string">"next"</span>, <span class="hljs-string">"throw"</span>, <span class="hljs-string">"return"</span>].forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(method)</span> </span>&#123;<br>define(prototype, method, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(arg)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._invoke(method, arg);<br>&#125;);<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>这些弄明白之后，可以简单理一下编译后代码的执行步骤：</p><ol><li>var g = genFn();<ol><li>genFn() 返回 generator 对象，拥有 _invoke 方法</li><li>g 拥有 _invoke</li></ol></li><li>g.next();<ol><li>g 的 next 方法会调用 _invoke 方法</li><li>g.next()  ==&gt;  g._invoke();</li></ol></li></ol><p>到这里就可以去看看 invoke 是如何实现的</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><span class="hljs-comment">// 四种状态：开始、执行中、暂停执行、结束</span><br>var GenStateSuspendedStart = <span class="hljs-string">"suspendedStart"</span>;<br>var GenStateExecuting = <span class="hljs-string">"executing"</span>;<br>var GenStateSuspendedYield = <span class="hljs-string">"suspendedYield"</span>;<br>var GenStateCompleted = <span class="hljs-string">"completed"</span>;<br><br><span class="hljs-comment">// generator 方法执行的状态</span><br>var state = GenStateSuspendedStart;<br><br>return <span class="hljs-keyword">function</span> invoke (<span class="hljs-keyword">method</span>, arg) &#123;<br><span class="hljs-comment">// 方法体内的语句执行过程中不允许继续执行</span><br>    <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> === </span>GenStateExecuting) &#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">"Generator is already running"</span>)</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (state<span class="hljs-operator"> === </span>GenStateCompleted) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">method</span><span class="hljs-operator"> === </span><span class="hljs-string">"throw"</span>) &#123;<br>            throw arg;<br>        &#125;<br>    &#125;<br><br>    context.<span class="hljs-keyword">method</span> = <span class="hljs-keyword">method</span>;<br>    context.arg = arg;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-comment">// 省略容错逻辑</span><br>        <br>        state = GenStateExecuting;<br><br><span class="hljs-comment">// fn.call(obj, arg)</span><br><span class="hljs-comment">// fn 即 genFn$，arg 即为 context</span><br><span class="hljs-comment">//function tryCatch (fn, obj, arg) &#123;</span><br>        <span class="hljs-comment">//    try &#123;</span><br>        <span class="hljs-comment">//        return &#123; type: "normal", arg: fn.call(obj, arg) &#125;;</span><br>        <span class="hljs-comment">//    &#125; catch (err) &#123;</span><br>        <span class="hljs-comment">//        return &#123; type: "throw", arg: err &#125;;</span><br>        <span class="hljs-comment">//    &#125;</span><br>        <span class="hljs-comment">//&#125;</span><br>       <br>       <span class="hljs-comment">// 在这里调用 genFn$ 方法</span><br>        var record = <span class="hljs-keyword">try</span><span class="hljs-constructor">Catch(<span class="hljs-params">innerFn</span>, <span class="hljs-params">self</span>, <span class="hljs-params">context</span>)</span>;<br>        <br>        <span class="hljs-keyword">if</span> (record.<span class="hljs-keyword">type</span><span class="hljs-operator"> === </span><span class="hljs-string">"normal"</span>) &#123; <span class="hljs-comment">// 执行 genFn$ 成功会走如下逻辑</span><br>        <span class="hljs-comment">// 如果语句执行完毕则结束执行，否则暂停执行</span><br>        state = context.<span class="hljs-keyword">done</span><br>                    ? GenStateCompleted<br>                    : GenStateSuspendedYield;<br>            <span class="hljs-comment">// 返回执行 yield 的结果</span><br>            return &#123;<br>                value: record.arg,<br>                <span class="hljs-keyword">done</span>: context.<span class="hljs-keyword">done</span><br>            &#125;;<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (record.<span class="hljs-keyword">type</span><span class="hljs-operator"> === </span><span class="hljs-string">"throw"</span>) &#123; <span class="hljs-comment">// 遇到错误则将方法改为 throw，进入下一个循环执行容错逻辑</span><br>            state = GenStateCompleted;<br>            context.<span class="hljs-keyword">method</span> = <span class="hljs-string">"throw"</span>;<br>            context.arg = record.arg;<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>invoke 通过调用的方法进行不同的操作。遇到  throw 直接 throw 错误；遇到 return 会去 complete generator；遇到 next，就会调用 genFn$ 方法，最终返回一个 value 和 done 属性的对象。</p><h4 id="解析-async"><a href="#解析-async" class="headerlink" title="解析 async"></a>解析 async</h4><p>对于 async 函数，依然使用上面的方法进行编译处理。async 编译后的代码与 generator 编译后的 regeneratorRuntime 对象是一样的，因此我们只需要关注不同点就可以了。</p><p>编译前</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        resolve(<span class="hljs-number">2</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> p();<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>asyncFn();<br><span class="hljs-comment">// 2 1 1</span><br></code></pre></td></tr></table></figure><p>编译后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> p = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>resolve(<span class="hljs-number">2</span>);<br>&#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">var</span> a, b, c;<br><span class="hljs-keyword">return</span> regeneratorRuntime.async(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn$</span> (<span class="hljs-params">_context</span>) </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">switch</span> (_context.prev = _context.next) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>_context.next = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(p());<br><span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>a = _context.sent;<br>_context.next = <span class="hljs-number">5</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:<br>b = _context.sent;<br>_context.next = <span class="hljs-number">8</span>;<br><span class="hljs-keyword">return</span> regeneratorRuntime.awrap(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>c = _context.sent;<br><span class="hljs-built_in">console</span>.log(a);<br><span class="hljs-built_in">console</span>.log(b);<br><span class="hljs-built_in">console</span>.log(c);<br><span class="hljs-keyword">case</span> <span class="hljs-number">12</span>:<br><span class="hljs-keyword">case</span> <span class="hljs-string">"end"</span>:<br><span class="hljs-keyword">return</span> _context.stop();<br>&#125;<br>&#125;<br>&#125;, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-built_in">Promise</span>);<br>&#125;<br><br>asyncFn();<br></code></pre></td></tr></table></figure><p>与 generator 编译之后的代码基本相同，不同的是</p><ol><li>调用的是 regeneratorRuntime.async 方法，接收4个参，其中最后一个是 Promise</li><li>内部方法 return  regeneratorRuntime.awrap, 即将 await xx 改为 regeneratorRuntime.awrap(xx)</li></ol><p>按照顺序，先来看看 async 方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">exports.async = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">innerFn, outerFn, self, tryLocsList, PromiseImpl</span>) </span>&#123;<br><span class="hljs-comment">// 确保 PromiseImpl 是 Promise</span><br>    <span class="hljs-keyword">if</span> (PromiseImpl === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) PromiseImpl = <span class="hljs-built_in">Promise</span>;<br>    <br>    <span class="hljs-keyword">var</span> iter = <span class="hljs-keyword">new</span> AsyncIterator(<br>    <span class="hljs-comment">// wrap 方法返回一个 generator 对象</span><br>        wrap(innerFn, outerFn, self, tryLocsList),<br>        PromiseImpl<br>    );<br><span class="hljs-comment">// iter.next() 是一个 promise 对象</span><br>    <span class="hljs-keyword">return</span> exports.isGeneratorFunction(outerFn)<br>        ? iter<br>        : iter.next().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">result</span>) </span>&#123;   <br>            <span class="hljs-keyword">return</span> result.done ? result.value : iter.next();<br>        &#125;);<br>&#125;;<br></code></pre></td></tr></table></figure><p>new AsyncIterator 内部做了些什么工作呢？简化之后就很明了。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">AsyncIterator</span> <span class="hljs-params">(generator, PromiseImpl)</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invoke</span> <span class="hljs-params">(method, arg, resolve, reject)</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueue</span> <span class="hljs-params">(method, arg)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callInvokeWithMethodAndArg</span> <span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 返回 promise 实例</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PromiseImpl(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(resolve, reject)</span> </span>&#123;<br>                invoke(method, arg, resolve, reject);<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">var</span> previousPromise;<br>        <span class="hljs-keyword">return</span> previousPromise = callInvokeWithMethodAndArg();<br>    &#125;<br>    <span class="hljs-keyword">this</span>._invoke = enqueue;<br>&#125;<br></code></pre></td></tr></table></figure><p>defineIteratorMethods 方法将 next(还有 throw、return) 方法代理给了 _invoke，所以 iter.next() 会调用 _invoke，即 enqueue，而 enqueue 返回一个 promise 实例，因此可以调用 then 方法。</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">iter.next().<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> <span class="hljs-title"></span>(result) &#123;   <br>    <span class="hljs-keyword">return</span> <span class="hljs-type">result.done</span> ? result.value : <span class="hljs-type">iter.next</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p>这段是控制 await 顺序执行的开始和结束</p><p>首先执行 iter.next()，相当于执行  enqueue，进而执行 invoke。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> invoke (<span class="hljs-keyword">method</span>, arg, resolve, reject) &#123;<br>    var <span class="hljs-type">record</span> = tryCatch(generator[<span class="hljs-keyword">method</span>], generator, arg);<br>    <span class="hljs-keyword">if</span> (<span class="hljs-type">record</span>.<span class="hljs-keyword">type</span> === "throw") &#123;<br>        reject(<span class="hljs-type">record</span>.arg);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        var result = <span class="hljs-type">record</span>.arg;<br>        var <span class="hljs-keyword">value</span> = result.<span class="hljs-keyword">value</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">value</span> &amp;&amp;<br>            typeof <span class="hljs-keyword">value</span> === "object" &amp;&amp;<br>            hasOwn.<span class="hljs-keyword">call</span>(<span class="hljs-keyword">value</span>, "__await")) &#123;<br>            <span class="hljs-keyword">return</span> PromiseImpl.resolve(<span class="hljs-keyword">value</span>.__await).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-keyword">value</span>) &#123;<br>                invoke("next", <span class="hljs-keyword">value</span>, resolve, reject);<br>            &#125;, <span class="hljs-keyword">function</span> (err) &#123;<br>                invoke("throw", err, resolve, reject);<br>            &#125;);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> PromiseImpl.resolve(<span class="hljs-keyword">value</span>).<span class="hljs-keyword">then</span>(<span class="hljs-keyword">function</span> (unwrapped) &#123;<br>            result.<span class="hljs-keyword">value</span> = unwrapped;<br>            resolve(result);<br>        &#125;, <span class="hljs-keyword">function</span> (error) &#123;<br>            <span class="hljs-keyword">return</span> invoke("throw", error, resolve, reject);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行步骤如下：</p><ol><li>var record = tryCatch(generator[method], generator, arg);<ol><li>因为 generator[method] 代理给了 _invoke。因此会执行 return { type: “normal”, arg: <em>fn</em>.call(<em>obj</em>, <em>arg</em>) };所以这里的 _invoke 是 generator 的 _invoke，而不是 iter 的 _invoke。</li><li>接下来执行 _invoke 的步骤与 generator 函数一样，执行被包裹的函数，最终会返回 {value: xx, done: xx} 对象，但不一样的是，如果函数体没有执行完毕之前，value 是一个对象，有一个 __await 属性。</li></ol></li><li>如果 tryCatch 执行失败，则直接 reject。</li><li>如果执行成功：<ol><li>如果函数体内的 await 还未执行结束，则会将 record.value.__await 值当作参数，递归调用 invoke 方法</li><li>如果函数体执行完毕，此时的 value 是 undefined，将 record 用异步的方式返回，就会执行 iter.next() 的 then 方法内的回调，这里就是直接执行 return result.value。 因此 async 默认返回 undefined。</li></ol></li></ol><p>到这里，我们就简单理解了 generator 和 async 函数内部的工作原理。其中，async 是在 generator 的基础上工作的，它使用递归方式取代多个 next 方法调用。</p><p>奉上一张编译后代码中方法调用的简图以作参考。</p><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/babel_%E7%BC%96%E8%AF%91_async_generator.png" srcset="/img/loading.gif" lazyload alt="babel 编译 async&amp;generator"></p><h4 id="实现一个简版-async"><a href="#实现一个简版-async" class="headerlink" title="实现一个简版 async"></a>实现一个简版 async</h4><p>通过上面的分析，我们可以知道，async 就是一个不需要手动执行 next 方法的 generator，明白了这点就好动手了。</p><p>先上一个示例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span> (<span class="hljs-params">filename, duration</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(filename)<br>            resolve(filename)<br>        &#125;, duration)<br>    &#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">yield</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-number">5</span>;<br>&#125;<br><span class="hljs-keyword">let</span> g = genFn();<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><span class="hljs-built_in">console</span>.log(g.next())<br><br><span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 4, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: 5, done: false &#125;</span><br><span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br><span class="hljs-comment">// b.txt   3秒后输出</span><br><span class="hljs-comment">// a.txt   5秒后输出</span><br></code></pre></td></tr></table></figure><p>如上例所示，在实现 async 有2个问题需要解决：</p><ol><li>如何保证异步代码按调用顺序去执行（异步代码默认使用 promise 包裹）</li><li>如何自动调用 next</li></ol><p>先来实现自动调用，首先想到的是声明一个方法，在里面去执行 next 方法，然后递归调用。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">function</span> <span class="hljs-string">asyncFn</span> <span class="hljs-string">(genFn)</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-string">function</span> <span class="hljs-string">invokeNext</span> <span class="hljs-string">(generator)</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-string">//</span> <span class="hljs-string">在这里执行</span> <span class="hljs-string">next</span> <span class="hljs-string">方法</span><br>        <span class="hljs-string">let</span> <span class="hljs-string">result</span> <span class="hljs-string">=</span> <span class="hljs-string">generator.next();</span><br>        <span class="hljs-string">//</span> <span class="hljs-string">如果调用结束就不再继续调用</span><br>        <span class="hljs-string">if</span> <span class="hljs-string">(result.done</span> <span class="hljs-string">===</span> <span class="hljs-literal">true</span><span class="hljs-string">)</span> <span class="hljs-string">&#123;</span><br>            <span class="hljs-string">return;</span><br>        <span class="hljs-string">&#125;</span><br>        <span class="hljs-string">invokeNext(generator)</span><br>    <span class="hljs-string">&#125;</span><br><span class="hljs-string">//</span> <span class="hljs-string">获取遍历器对象</span><br>    <span class="hljs-string">let</span> <span class="hljs-string">g</span> <span class="hljs-string">=</span> <span class="hljs-string">genFn.call(null);</span><br>    <span class="hljs-string">invokeNext(g)</span><br><span class="hljs-string">&#125;</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">测试一下</span><br><span class="hljs-string">function*</span> <span class="hljs-string">genFn_</span> <span class="hljs-string">()</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-string">yield</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br>    <span class="hljs-string">yield</span> <span class="hljs-number">2</span><span class="hljs-string">;</span><br>    <span class="hljs-string">yield</span> <span class="hljs-number">3</span><span class="hljs-string">;</span><br>    <span class="hljs-string">yield</span> <span class="hljs-number">4</span><span class="hljs-string">;</span><br>    <span class="hljs-string">yield</span> <span class="hljs-number">5</span><span class="hljs-string">;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">//</span> <span class="hljs-string">无异步代码可以按顺序执行</span><br><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><br><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><br><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><br><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><br><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">false</span> <span class="hljs-string">&#125;</span><br><span class="hljs-string">//</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">value:</span> <span class="hljs-string">undefined,</span> <span class="hljs-attr">done:</span> <span class="hljs-literal">true</span> <span class="hljs-string">&#125;</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">对于前面异步代码的执行就会出先问题</span><br></code></pre></td></tr></table></figure><p>js 处理异步操作有多种方式，除了 generator 和 async，我们还有 promise，所以考虑用 promise 来管理每个 next 的调用顺序，事情就变得简单了，完整代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span> (<span class="hljs-params">genFn</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">invokeNext</span> (<span class="hljs-params">generator</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> value = generator.next();<br>            resolve(value)<br>        &#125;).then(<span class="hljs-function">(<span class="hljs-params">result</span>) =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.log(result);<br>            <span class="hljs-keyword">if</span> (result.done === <span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 如果是 promise 对象，则需要在 then 方法回调里去调用下一个 next</span><br>            <span class="hljs-keyword">if</span> (result.value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>                result.value.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    invokeNext(generator)<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                invokeNext(generator)<br>            &#125;<br>        &#125;, err =&gt; &#123;<br>            reject(err);<br>        &#125;)<br>    &#125;<br>    <br>    <span class="hljs-keyword">const</span> g = genFn.call(<span class="hljs-literal">null</span>);<br>    invokeNext(g)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Generator</tag>
      
      <tag>Async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>弄懂 event loop</title>
    <link href="/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/"/>
    <url>/2021/04/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是-event-loop"><a href="#什么是-event-loop" class="headerlink" title="什么是 event loop"></a>什么是 event loop</h4><p>简单来说，event loop 就是 JavaScript 宿主处理事件执行的一种机制。</p><p>js 以前是专门用来处理浏览器交互的，比如说 DOM 点击事件等，因此被设计成单线程，所谓单线程，就是同一时间只能处理一件事情，这也就保证了页面中一次只能处理一个事件，避免造成交互混乱的问题。</p><p><strong>开始之前，需要明确的是 JavaScript引擎是单线程的，但是 js 运行环境是多线程。因为浏览器是多线程的，除了 js 引擎线程，还包括 GUI 渲染线程、定时器触发线程、HTTP 请求线程以及 DOM 事件触发线程；node也可以使用 child_process 创建多个子线程。</strong></p><p>现在有事件 A 和 B，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> A = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am A'</span>);<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;<br><br><span class="hljs-keyword">const</span> B = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'i am B'</span>);<br>&#125;<br><br>A();<br>B();<br></code></pre></td></tr></table></figure><p>按照单线程的要求，需要等到 A 执行完毕，才会执行 B，那么打印顺序会是如下所示：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">console.<span class="hljs-built_in">log</span>('i am A');<br>console.<span class="hljs-built_in">log</span>('i am B');<br></code></pre></td></tr></table></figure><p>但实际上的顺序是：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">console.<span class="hljs-built_in">log</span>('i am B');<br>console.<span class="hljs-built_in">log</span>('i am A');<br></code></pre></td></tr></table></figure><p>这就是 event loop 机制在起作用，因为 console.log(‘i am B’) 是同步任务，而 setTimeout 是异步任务，同步任务执行完才会去执行异步任务</p><h4 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h4><ul><li>什么是宏任务和微任务？</li></ul><p>这里有几个概念容易混淆，那就是同步任务和异步任务，宏任务和微任务。js 的代码执行遵循在代码块内从上往下执行的规则，同步任务会依次执行；而异步任务则会分为宏任务和微任务，比如 setTimeout 的第一个参数是宏任务，promise.then 中注册的方法是微任务，会按照宏任务和微任务的执行规则进行执行。</p><ul><li>宏任务和微任务有哪些？</li></ul><p>js 执行的宿主环境有浏览器和 Node,  所以我们通过宿主环境的不同来整理这些异步任务：</p><table><thead><tr><th>宏任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>setTimeout</td><td>√</td><td>√</td></tr><tr><td>setInterval</td><td>√</td><td>√</td></tr><tr><td>setImmediate</td><td>x</td><td>√</td></tr><tr><td>I/O</td><td>√</td><td>√</td></tr><tr><td>requestAnimationFrame</td><td>√</td><td>x</td></tr></tbody></table><table><thead><tr><th>微任务</th><th>浏览器</th><th>node</th></tr></thead><tbody><tr><td>mutationObserver</td><td>√</td><td>x</td></tr><tr><td>promise</td><td>√</td><td>√</td></tr><tr><td>process.nextTick</td><td>x</td><td>√</td></tr></tbody></table><ul><li>宏任务和微任务的执行顺序</li></ul><p>要点一：一个宏任务里可能会包含多个微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 promise 里的 同步任务'</span>)<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务1'</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是微任务2'</span>)<br>&#125;)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我是 setTimeout 里的 宏任务'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>我们来分析下这段代码里的宏任务和微任务有哪些：<br>宏任务：setTimeout 的回调<br>微任务：两个 then 方法的回调</p><p>要点二：宏任务是一个一个执行的，而微任务是批量执行的，当前批次微任务没有完成之前，下一个宏任务不会执行</p><p>因此执行顺序是:</p><ol><li>遇到 promise，参数里面的代码是同步的，所有会先执行 console.log(‘我是 promise 里的 同步任务’)</li><li>执行两个 then 方法的回调</li><li>执行 setTimeout 的回调</li></ol><p>即：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autoit">// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是 promise 里的 同步任务'</span>)<br>// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是微任务1'</span>)<br>// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是微任务2'</span>)<br>// console.<span class="hljs-built_in">log</span>(<span class="hljs-string">'我是 setTimeout 里的 宏任务'</span>)<br></code></pre></td></tr></table></figure><h4 id="浏览器下的-event-loop"><a href="#浏览器下的-event-loop" class="headerlink" title="浏览器下的 event loop"></a>浏览器下的 event loop</h4><p><img src="https://coding-pages-bucket-3560923-8733773-16868-593524-1259394930.cos-website.ap-hongkong.myqcloud.com/blogImgs/%E6%B5%8F%E8%A7%88%E5%99%A8_event_loop.png" srcset="/img/loading.gif" lazyload alt="浏览器 event loop"></p><p>如图所示，代码执行步骤如下：</p><ol><li>js 在执行代码时，会将代码放入执行栈中，遇到同步任务，会依次执行；遇到如 DOM 点击事件、ajax 以及 定时器等异步任务，浏览器会交给其他辅线程调用 WebApis  进行处理。</li><li>如果 WebApis 处理的异步任务有了结果，就会将该任务推入到回调队列（callback queue）中，回调队列分为宏任务队列和微任务队列。</li><li>一旦执行栈内（stack）的任务执行完成，就会将回调队列里的任务放入执行栈中执行，顺序如下：<ol><li>如果微任务队列中存在任务，则一次性执行所有微任务</li><li>将宏任务队列的第一个任务放入执行栈中执行</li></ol></li></ol><p>以上步骤的循环就是浏览器中的 event loop。</p><p>看一个简单例子感受下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback1</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;)<br><br><span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">'success'</span>)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback2</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback3</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>);<span class="hljs-keyword">return</span> <span class="hljs-number">2</span>&#125;)<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'start'</span>)<br><span class="hljs-comment">// start</span><br><span class="hljs-comment">// 1</span><br><span class="hljs-comment">// 2</span><br><span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure><ol><li>遇到 setTimeout，等待时间到达后将 callback1 放入宏任务队列</li><li>遇到 promise.then，等待时间到达后将 callback2 与 callback3  按顺序放入微任务队列</li><li>执行同步任务 console.log。</li><li>执行完同步任务，将微任务队列里的任务一次性执行</li><li>微任务执行完之后，执行宏任务队列的第一个任务</li></ol><h4 id="node-下的-event-loop"><a href="#node-下的-event-loop" class="headerlink" title="node 下的 event loop"></a>node 下的 event loop</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs smali">   ┌───────────────────────────┐                             <br>┌─&gt;│           timers          │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐                                    <br>│  │     pending callbacks     │                             <br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>│  │       idle, prepare       │<br>│  └─────────────┬─────────────┘      ┌───────────────┐<br>│  ┌─────────────┴─────────────┐      │   incoming:   │<br>│  │           poll            │&lt;─────┤ connections,  │<br>│  └─────────────┬─────────────┘      │   data, etc.  │<br>│  ┌─────────────┴─────────────┐      └───────────────┘<br>│  │          <span class="hljs-built_in"> check </span>          │<br>│  └─────────────┬─────────────┘<br>│  ┌─────────────┴─────────────┐<br>└──┤      close callbacks      │<br>   └───────────────────────────┘<br></code></pre></td></tr></table></figure><p>如上图所示，node 中的 event loop 分为6个循环阶段，当 node.js 启动的时候，会初始化 event loop</p><ul><li>timers： 这个阶段执行 setTimeout 和 setInterval 的回调函数</li><li>pending callbacks：在下一个循环中执行 I/O 回调函数</li><li>idle, prepare：只在 node 内部触发</li><li>poll：获取新的 I/O 事件，在适当的时候阻塞在这里</li><li>check：执行 setImmediate 的回调函数</li><li>close callbacks：执行关闭事件的回调函数，如 socket.on(‘close’, … )</li></ul><p>下面主要对 timers、poll、check 三个阶段进行解析：</p><h5 id="一、timers"><a href="#一、timers" class="headerlink" title="一、timers"></a>一、timers</h5><p>timers 阶段的回调函数可能并不会按照设定的时间延迟去执行，因为 event loop 初始化或者其他阶段回调函数的长时间执行会延迟它们的执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">someAsyncOperation</span>(<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-comment">// 假设读取文件需耗时 95ms</span><br>    fs.readFile(<span class="hljs-string">'./a.txt'</span>, callback)<br>&#125;<br><br>cosnt timeoutScheduled = <span class="hljs-built_in">Date</span>.now();<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> delay = <span class="hljs-built_in">Date</span>.now() - timeoutScheduled;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;delay&#125;</span>ms have passed since I was scheduled`</span>);<br>&#125;, <span class="hljs-number">100</span>)<br><br>someAsyncOperation(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> startCallbackTime = <span class="hljs-built_in">Date</span>.now();<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">Date</span>.now() - startCallbackTime &lt; <span class="hljs-number">10</span>) &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>上方示例在 node 里的大致执行步骤如下：</p><ol><li>timer 阶段：因为需要延迟 100ms，所以当前没有 callback 需要执行，进入 pending callback 阶段</li><li>pending callback阶段：没有 I/O 回调需要执行，进入 idle，</li><li>idle 忽略</li><li>poll 阶段：因为此时有 I/O 操作，因此会阻塞在这里，等待95ms至文件读取结束，然后将 callback 放入队列进行执行，耗时10ms。调用结束后，当前队列为空，检查 timers，发现设定时间为95ms，当前运行时间超时了，因此进入 timer 阶段执行回调，所以会打印出”105ms has passed since I was scheduled”</li></ol><h5 id="二、poll"><a href="#二、poll" class="headerlink" title="二、poll"></a>二、poll</h5><p>poll 阶段主要有两个功能：</p><p>1.计算它应该阻塞和轮询 I/O 多长时间</p><p>2.处理该阶段事件</p><p>当 event loop 进入 poll 阶段并且未设定定时器，会出现下面中的某个情况：</p><ul><li>如果 poll 的队列不为空，那么就会遍历队列，并异步执行完所有回调函数，或者执行耗时达到系统设定的最大时间</li><li>如果 poll 队列为空，那以下情况中的一个会出现：<ol><li>如果代码设定了 setImmediate 方法，event loop 会结束 poll 阶段，进入 check 阶段去执行 check 队列</li><li>如果没有设定 setImmediate 方法，就会阻塞在 poll 阶段，直到有 poll callback 添加到队列中，然后立刻执行。</li></ol></li></ul><p>如果 event loop 进入 poll 阶段并且设定了定时器：</p><ul><li>一旦 poll 队列处于空闲状态，event loop 会查看 timers 里的回调函数，如果至少有一个回调函数的时间到了，event loop 会按循环顺序进入 timers 阶段去执行这些回调函数。</li><li>按循环顺序说的是 event loop 不会直接进入 timers 阶段，而是要先进入 check、close callback 之后，再进入 timers 阶段。</li></ul><h5 id="三、check"><a href="#三、check" class="headerlink" title="三、check"></a>三、check</h5><ul><li>这个阶段用来存放 setImmediate 回调函数，如果代码中设定了，那么 event loop 不会阻塞等待在 poll 阶段，而是会进入 check 阶段。</li><li>当 poll 阶段结束，进入check 阶段后，会调用 libuv api 去执行回调函数</li></ul><h5 id="四、API-比较"><a href="#四、API-比较" class="headerlink" title="四、API 比较"></a>四、API 比较</h5><ul><li>setTimeout 和 setImmediate<ol><li>setTimeout 设定一个任务在等待指定时间后去执行</li><li>setImmediate 在 poll 阶段完成后立即去调用它设定的代码</li><li>它们回调函数执行的顺序依据它们执行的方式会有不同：如果它们的执行不在 I/O 操作里，那么顺序时不定的，如果在 I/O 中，永远都是 setImmediate 最先执行</li></ol></li></ul><ul><li>process.nextTick</li></ul><p>在技术上来说，nextTick 不属于 event loop 的一部分，凡是放进 nextTick 队列的回调函数会在下一次 event loop 循环开始前执行。需要注意的是，正是因为这个特性，如果递归调用 nextTick，会导致下一次 event loop 无法开始。</p><h5 id="node-中宏任务和微任务"><a href="#node-中宏任务和微任务" class="headerlink" title="node 中宏任务和微任务"></a>node 中宏任务和微任务</h5><p>因为 node 中的 宏任务分处于不同的阶段，并且微任务中的 process.nextTick 都是先于其它微任务执行，所以可以理解为 有4个宏任务队列以及2个微任务队列。</p><p>这里为了便于理解，借用一张图：</p><img src="https://user-gold-cdn.xitu.io/2018/9/5/165a8667e6b79cc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" srcset="/img/loading.gif" lazyload alt="node-eventloop" style="zoom:80%;;margin-left:0" /><p>这里的宏任务和微任务流程模型与浏览器的相同，区别在于：</p><ol><li>node 中的宏任务队列执行顺序取决于 event loop 所处的阶段</li><li>微任务中，process.nextTick 独处一个队列，比其他微任务要早执行</li></ol><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>event loop 相当于一个总指挥，负责 js 任务的协调与调度。</p><p>参考文献 <a href="https://juejin.cn/post/6844903670291628046#heading-5" target="_blank" rel="noopener">https://juejin.cn/post/6844903670291628046#heading-5</a></p>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Event Loop</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跟着规范实现一个功能完备的Promise</title>
    <link href="/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/"/>
    <url>/2021/04/02/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/</url>
    
    <content type="html"><![CDATA[<p>一直以来，对于 promise，只知道如何使用，其内部的运作机制却不得而知。本着知其然，知其所以然（为了让自己用得安心）的理念，决定跟着规范去了解底层的原理，并手写一个功能完备的 MyPromise.</p><h4 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h4><ul><li>promise 是一个对象或者函数，拥有 then 方法</li><li>thenable 可以理解为一个拥有 then 方法的对象或函数</li><li>value 是一个合法的 JavaScript值</li><li>reason 用来表示 promise 拒绝的原因</li></ul><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>promise 初始状态为 pending，可以转变成 fulfilled 或者 rejected</li><li>如果状态是 fulfilled，则不能转变为 rejected 或者 pending。rejected 同理。</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>下面开始尝试第一版：</p><p>平时都是通过 new 来创建一个 promise 实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>    resolve(<span class="hljs-string">'xxx'</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>于是首先创建一个 promise 构造函数，接收一个方法 executor 作为参数, 在内部直接执行，并且传入两个方法以供使用者使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">MyPromise</span>(<span class="hljs-params">executor</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> resolve = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>    <span class="hljs-keyword">const</span> reject = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<br>    <br>    executor(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果调用 resolve 方法，会将 Promise实例 状态转变成 fulfilled，如果调用 reject 方法，则会将 Promise 实例状态转变成 rejected。所以接下来给 MyPromise 构造函数添加相应属性，并实现 resolve 和 reject。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function MyPromise(executor) &#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'pending'</span>;<br>    <span class="hljs-keyword">this</span>.value = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">this</span>.reason = <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>    <span class="hljs-comment">// 只有处于 pending 状态，才能发生状态改变</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;<br>            <span class="hljs-keyword">this</span>.value = value;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;<br>            <span class="hljs-keyword">this</span>.reason = reason;<br>        &#125;<br>    &#125;<br>    <br>    executor(resolve, reject);<br>&#125;<br></code></pre></td></tr></table></figure><p>构造函数建造完毕，现在来处理最主要的部分 then 方法，这也是规范给出详细标准的一部分。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 可以接收两个方法作为参数, 在内部可以根据 MyPromise 实例的状态进行相应的操作</span><br>MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(onFulfilled, onRejected)</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>        <br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当 then 执行的时候，如果 status 是 fulfilled 或者 rejected 状态，可以直接执行 onFulfilled 或者 onRejected 方法，但如果依然还是 pending，需要将这些执行操作放入等待区，也就是存入到回调队列中，如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><br>MyPromise.prototype.then = function(onFulfilled, onRejected) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onFulfilledStack.push(() =&gt; &#123;<br>            onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;)<br>        <span class="hljs-keyword">this</span>.onRejectedStack.push(() =&gt; &#123;<br>            onRejected(<span class="hljs-keyword">this</span>.reason)<br>        &#125;)<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>        onFulfilled(<span class="hljs-keyword">this</span>.value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>        onRejected(<span class="hljs-keyword">this</span>.reason)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么现在，待执行栈已经存在了状态改变的回调，需要在合适的时机去执行，所以需要完善 resolve 和 reject 方法。一旦状态改变，则将带执行栈中的回调全部执行。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">const</span> resolve = (value) =&gt; &#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'fulfilled'</span>;<br>    <span class="hljs-keyword">this</span>.value = value;<br>    <span class="hljs-comment">// 执行回调</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onFulfilledStack.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onFulfilledStack.shift()(<span class="hljs-keyword">this</span>.value);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> reject = (reason) =&gt; &#123;<br>    <span class="hljs-keyword">this</span>.status = <span class="hljs-string">'rejected'</span>;<br>    <span class="hljs-keyword">this</span>.reason = reason;<br>    <span class="hljs-comment">// 执行回调</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>.onRejectedStack.length &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">this</span>.onRejectedStack.shift()(<span class="hljs-keyword">this</span>.reason);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们都知道then 方法必须返回一个 promise，因此需要对 then 方法进一步改造：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">MyPromise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>到这里就要思考一下，then 方法为什么要返回一个 promise？ 原因是每一个 promise 都会有一个 then 方法，而如果 then 方法也返回一个 promise，那么这个 then 也会有一个 then 方法，于是可以像下方代码一样链式调用 ：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).<span class="hljs-keyword">then</span>().<span class="hljs-keyword">then</span>()<br></code></pre></td></tr></table></figure><p>但还有个原因。我们不仅可以像上方一样 resolve 一个基本值，也可以 resolve 一个 promise，如下方例子：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(_resolve, _reject)</span> =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            _resolve(<span class="hljs-string">'success'</span>)<br>        &#125;, <span class="hljs-number">2000</span>)<br>    &#125;))<br>&#125;).<span class="hljs-keyword">then</span>().<span class="hljs-keyword">then</span>()<br></code></pre></td></tr></table></figure><p>因为被 resolve 的 promise 的状态是尚未改变的，因此可以将这个 promise 放进 then 返回的这个 promise 内去等待状态改变，所以这一步我们将 then 方法内原先的处理逻辑挪到这个返回的 promise 内部。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">MyPromsise.prototype.<span class="hljs-keyword">then</span> = function(onFulfilled, onRejected) &#123;<br>    let _promise = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> 因为 onFulfilled(<span class="hljs-keyword">this</span>.value) 和 onRejected(<span class="hljs-keyword">this</span>.reason) 可能返回一个 thenable，因此需要将下方代码移入新 promise内部去执行<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            &#125;)<br>            <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onRejected(<span class="hljs-keyword">this</span>.reason)<br>            &#125;)<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>            onFulfilled(<span class="hljs-keyword">this</span>.value);<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>            onRejected(<span class="hljs-keyword">this</span>.reason)<br>        &#125;<br>    &#125;)<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>有个问题，我们在内部直接调用 onFulfilled 和 onRejected，但却没有对这两个方法类型进行错误处理，也就是必须保证它们是 function。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">MyPromsise.prototype.then = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-comment">// 设置默认的回调方法（需原样返回传进来的值或者抛出同样的值），可以保证 promise 结果能够透传</span><br>    onFulfilled = <span class="hljs-keyword">typeof</span> onFulfilled === <span class="hljs-string">'function'</span> ? onFulfilled : <span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> value;<br>    onRejected = <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">'function'</span> ? onRejected : <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123; <span class="hljs-keyword">throw</span> reason &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里有一个处理，如果 onFulfilled 和 onRejected 不是 function，那么就将它们赋值成方法，并且将接收到的值进行相应处理：如果是 onFulfilled，直接将值 return，如果是 onRejected, 主动抛出一个错误。这也就实现了 promise 值的透传</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">'success'</span>)<br>&#125;).<span class="hljs-keyword">then</span>().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(value)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value)  <span class="hljs-regexp">//</span> success<br>&#125;)<br></code></pre></td></tr></table></figure><p>目前为止，MyPromise 已经具备了可实例化，可执行同步任务的功能。但还无法执行异步任务。</p><p>规范2.2.4： onFulfilled or onRejected must not be called until the execution context stack contains only platform code。</p><p>意思是：onFulfilled 和 onRejected 方法需要异步执行。</p><p>接下来对 then 方法进行进一步完善, 将它们的执行丢到异步环境中</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">MyPromsise.prototype.<span class="hljs-keyword">then</span> = function(onFulfilled, onRejected) &#123;<br>    <span class="hljs-regexp">//</span> ...<br>    let _promise = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">return</span> _promise = <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'pending'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                <span class="hljs-keyword">this</span>.onFulfilledStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    onFulfilled(<span class="hljs-keyword">this</span>.value);<br>                &#125;)<br>                <span class="hljs-keyword">this</span>.onRejectedStack.push(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                    onRejected(<span class="hljs-keyword">this</span>.reason)<br>                &#125;)<br>            &#125;)<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'fulfilled'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onFulfilled(<span class="hljs-keyword">this</span>.value);<br>            &#125;)<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.status === <span class="hljs-string">'rejected'</span>) &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                onRejected(<span class="hljs-keyword">this</span>.reason)<br>            &#125;)<br>        &#125;<br>    &#125;)<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>规范2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x)</p><p>意思是： 对 onFulfilled 或者 onRejected 返回的值 x 进行 resolvePromise 操作，即需要将 x 当作一个 thenable 来对待，then 返回的 promise 的 状态需要 x 的状态来决定。</p><p>这里需要注意： resolvePromise 需要 promise2（即 then 返回的 promise） 和 x 这两个参，但是 promise2 的状态需要它自身 resolve 和 reject 去改变，因此将 resolve 和 reject 也带上。</p><p>改动如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span> (this.status<span class="hljs-operator"> === </span>'pending') &#123;<br>    this.onFulfilledStack.push(<span class="hljs-literal">()</span> =&gt; &#123;<br>        set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;<br>            <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Fulfilled(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span>;<br>            resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span><br>        &#125;)<br>    &#125;)<br>    this.onRejectedStack.push(<span class="hljs-literal">()</span> =&gt; &#123;<br>        set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;<br>            <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Rejected(<span class="hljs-params">this</span>.<span class="hljs-params">reason</span>)</span>;<br>            resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span><br>        &#125;) <br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">if</span> (this.status<span class="hljs-operator"> === </span>'fulfilled') &#123;<br>    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;<br>        <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Fulfilled(<span class="hljs-params">this</span>.<span class="hljs-params">value</span>)</span>;<br>        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span><br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">if</span> (this.status<span class="hljs-operator"> === </span>'rejected') &#123;<br>    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;<br>        <span class="hljs-keyword">let</span> x = on<span class="hljs-constructor">Rejected(<span class="hljs-params">this</span>.<span class="hljs-params">reason</span>)</span>;<br>        resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是实现 resolvePromise 方法了。</p><p>按照规范 2.3 The Promise Resolution Procedure，一步步实现：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">x</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span>&#123;<br>    <span class="hljs-comment">// 2.3.1 如果 _promise 和 x 是同一个对象，reject TypeError</span><br>    <span class="hljs-keyword">if</span> (x<span class="hljs-operator"> === </span>_promise) &#123;<br>        return reject(<span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError(`$&#123;<span class="hljs-params">x</span>&#125; <span class="hljs-params">should</span> <span class="hljs-params">no</span> <span class="hljs-params">refer</span> <span class="hljs-params">to</span> <span class="hljs-params">the</span> <span class="hljs-params">same</span> <span class="hljs-params">object</span> <span class="hljs-params">with</span> MyPromise`)</span>)<br>    &#125;<br>    <br>    <span class="hljs-comment">// 当 x 是对象或者函数时：</span><br>    <span class="hljs-comment">// 判断 x.then 方法中 onFulfilled 回调或者 onRejecetd 回调是否执行过</span><br>    <span class="hljs-comment">// 因为规范规定：其中每一个回调只能执行一次</span><br>    <span class="hljs-comment">// 当其中某项执行过，就将 hasCalled 置为 true</span><br>    <span class="hljs-keyword">let</span> hasCalled = <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">if</span> (x instanceof MyPromsie) &#123;<br>        <span class="hljs-comment">// 如果状态没有改变，则需要调用 then 方法，然后在内部还需要对以后的返回值进行 resolvePromise </span><br>        <span class="hljs-keyword">if</span> (x.status<span class="hljs-operator"> === </span>'pending') &#123;<br>            x.<span class="hljs-keyword">then</span>(y =&gt; &#123;<br>                resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">y</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span><br>            &#125;,<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> &#123;<br>                resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">err</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span><br>            &#125;)<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果状态已经改变，那么 x 就会有一个正常值，假设为 z</span><br>            <span class="hljs-comment">// 执行 x.then(resolve, reject)，会直接调用 resolve(z) 或者 reject(z) ：</span><br>            <span class="hljs-comment">// 2.3.2.2 &amp;&amp; 2.3.2.3</span><br>            x.<span class="hljs-keyword">then</span>(resolve, reject);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>prototype.toString.call(x)<span class="hljs-operator"> === </span>'<span class="hljs-literal">[<span class="hljs-identifier">object</span> O<span class="hljs-identifier">bject</span>]</span>'<span class="hljs-operator"> || </span>typeof x<span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>') &#123; <span class="hljs-comment">// x 是对象或者函数</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">then</span> = x.<span class="hljs-keyword">then</span>;<br>            <span class="hljs-keyword">if</span> (typeof <span class="hljs-keyword">then</span><span class="hljs-operator"> === </span>'<span class="hljs-keyword">function</span>') &#123;<br>                <span class="hljs-keyword">then</span>.call(x,<span class="hljs-function"> <span class="hljs-params">y</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (hasCalled) &#123; return &#125;<br>                    hasCalled = <span class="hljs-literal">true</span>;<br>                    resolve<span class="hljs-constructor">Promise(<span class="hljs-params">_promise</span>, <span class="hljs-params">y</span>, <span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span><br>                &#125;,<span class="hljs-function"> <span class="hljs-params">err</span> =&gt;</span> &#123;<br>                    <span class="hljs-keyword">if</span> (hasCalled) &#123; return &#125;<br>                    hasCalled = <span class="hljs-literal">true</span>;<br>                    reject(err);<br>                &#125;)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                resolve(x)<br>            &#125;<br>        &#125; catch(err) &#123;<br>            <span class="hljs-comment">// 2.3.3.3.4.1</span><br>            <span class="hljs-comment">// if resolvePromise or rejectPromise have been called, ignore it.</span><br>            <span class="hljs-keyword">if</span> (!hasCalled) &#123;<br>                reject(err)<br>            &#125;<br>        &#125;<br>        <br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 2.3.4</span><br>        resolve(x);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果能通过 promiseA+ 测试，说明该版本的 Promise 符合规范，但是还缺少常用的功能，继续完善：</p><p><strong>MyPromise.resolve</strong></p><p>接收一个值，在内部创建一个新的实例，将状态交给新实例去处理</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">MyPromise.prototype.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(value)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>#发</p><p><strong>MyPromise.catch</strong></p><p>接收一个方法，只会在 rejected 状态下执行</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">MyPromise.prototype.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(<span class="hljs-literal">null</span>, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.finally</strong></p><p>接收一个方法，不论 fulfilled 或者 rejected 都会执行</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">MyPromise.prototype.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(callback)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.then(callback, callback);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.all</strong></p><p>接收一个数组，只有所有项的状态为 fulfilled，最终结果才为 fulfilled，如果有一个 rejected，那么结果就是 rejected</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript">MyPromise.prototype.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> result = [];<br>        <span class="hljs-keyword">let</span> resolveCount = <span class="hljs-number">0</span>;<br>        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                result[index] = value;<br>                resolveCount++;<br>                <span class="hljs-keyword">if</span> (resolveCount === promiseArr.length) &#123;<br>                    resolve(result);<br>                &#125;<br>            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.race</strong></p><p>接收一个数组，结果由第一个状态改变的 thenable 决定</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript">MyPromise.prototype.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        promiseArr.forEach(<span class="hljs-function">(<span class="hljs-params">currentPromise, index</span>) =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value);<br>            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                reject(err)<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.allSettled</strong></p><p>接收一个数组，只有等到所有项的状态都改变了，不论是 fulfilled 还是 rejected，都只会变成 fulfilled</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript">MyPromise.prototype.allSettled = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> resultArr = [];<br>        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resultArr.push(&#123;status: <span class="hljs-string">'fulfilled'</span>, value: value&#125;);<br>                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;<br>                    resolve(resultArr);<br>                &#125;<br>            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                resultArr.push(&#123;status: <span class="hljs-string">'rejected'</span>, reason: err&#125;);<br>                <span class="hljs-keyword">if</span> (resultArr.length === promiseArr.length) &#123;<br>                    resolve(resultArr);<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>MyPromise.any</strong></p><p>接收一个数组，如果其中有一项的状态为 fulfilled， 那么结果就是 fulfilled，否则如果所有都是 rejected，那结果就是 rejected， 并且 reanson 是 ‘AggregateError: All promises were rejected’</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript">MyPromise.prototype.any = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promiseArr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">let</span> rejectCount = <span class="hljs-number">0</span>;<br>        promiseArr.forEach(<span class="hljs-function"><span class="hljs-params">currentPromise</span> =&gt;</span> &#123;<br>            currentPromise.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>                resolve(value);<br>            &#125;, <span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>                rejectCount ++;<br>                <span class="hljs-keyword">if</span> (rejectCount === promiseArr.length) &#123;<br>                    reject(<span class="hljs-string">'AggregateError: All promises were rejected'</span>);<br>                &#125;<br>            &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法：</p><p>#安装 promises-aplus-tests</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i promises-aplus-tests -g<br></code></pre></td></tr></table></figure><p>#在代码里加上这段</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">MyPromise.deferred = function () &#123;<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">defer</span> = &#123;&#125;;<br>    <span class="hljs-keyword">defer</span>.promise = <span class="hljs-built_in">new</span> MyPromise((resolve, reject) =&gt; &#123;<br>        <span class="hljs-keyword">defer</span>.resolve = resolve;<br>        <span class="hljs-keyword">defer</span>.reject = reject;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">defer</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>#最后</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">promises-aplus-tests</span> <span class="hljs-selector-tag">promise</span><span class="hljs-selector-class">.js</span><br></code></pre></td></tr></table></figure><p>有一点需要注意：我在实现 promise 内部异步执行时采用的是 setTimeout，而 promise 的 then 方法是一个微任务这与实际有出入。不过用于理解其中的异步理念已经足够了。追求完美的同学可自行实现不同的版本。</p><p>完整代码地址：<a href="https://github.com/yuwengCipher/MyPromise" target="_blank" rel="noopener">https://github.com/yuwengCipher/MyPromise</a></p>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Promise</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>说说 js 的异步处理机制</title>
    <link href="/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/01/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h4 id="什么是异步"><a href="#什么是异步" class="headerlink" title="什么是异步"></a>什么是异步</h4><p>在 JavaScript 中和生活中都会有异步任务的存在，而异步的产生是有前提条件的，那就是这个任务可以被拆解成两部分。</p><p>举个简单的例子。周末我想喝点排骨汤，把所有步骤都准备好后开火炖。正常来说，这锅汤需要3小时才能煲好，很显然我不会傻傻守在这儿等它3小时，因为我还有别的事要做，比如说看电视，嗑瓜子等等。而是3小时后汤煲好了，我才回去盛起来喝。</p><p>所以这个喝汤任务由两个步骤组成：煲汤 + 喝汤；这个喝汤步骤就是异步的</p><h4 id="设计成异步的原因"><a href="#设计成异步的原因" class="headerlink" title="设计成异步的原因"></a>设计成异步的原因</h4><p>从上面可以知道，如果我傻傻的在锅前等3个小时，那么我看电视、嗑瓜子等事情就得向后延3小时，到最后我这一天做不了什么，所以傻等3小时完全是浪费时间。</p><p>js 是单线程，同一时间只能做一件事，长时间的等待势必会造成资源的浪费</p><h4 id="异步实现方案"><a href="#异步实现方案" class="headerlink" title="异步实现方案"></a>异步实现方案</h4><ul><li>回调函数</li></ul><p>回调函数在 js 代码里随处可见，如给 DOM 添加点击事件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> d = document.get<span class="hljs-constructor">ElementId('<span class="hljs-params">test</span>')</span>;<br>d.add<span class="hljs-constructor">EventListener('<span class="hljs-params">click</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br><span class="hljs-comment">// callback 就是回调函数</span><br></code></pre></td></tr></table></figure><p>node 里去读取一份文件</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>但是有时候的需求会比较复杂，加入多个任务存在依赖性，就会写出如下代码：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;<br>    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test1</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback1</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;<br>        fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test2</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback2</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;<br>            <span class="hljs-comment">// ...</span><br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>深层嵌套让我们很是绝望！</p><ul><li>promise</li></ul><p>幸运的是后来有了 promise，带我们逃离了“回调地狱”，来到新世界：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise((<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> =&gt; &#123;<br>    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data</span>)</span>&#123;<br>        resolve(data);<br>    &#125;)<br>&#125;)<br>.<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text1</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback1</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data1</span>)</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        resolve(data1);<br>    &#125;)<br>&#125;)<br>.<span class="hljs-keyword">then</span>(data =&gt; &#123;<br>    fs.read<span class="hljs-constructor">File('.<span class="hljs-operator">/</span><span class="hljs-params">test</span>.<span class="hljs-params">text1</span>', <span class="hljs-params">function</span> <span class="hljs-params">callback2</span>(<span class="hljs-params">err</span>, <span class="hljs-params">data2</span>)</span>&#123;<br>        <span class="hljs-comment">// do something</span><br>        resolve(data2);<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>这样写之后是不是看起来清爽了，瞬间头也不晕了，promise 让流程执行的过程更清晰！</p><p>但是你一定见过这样的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">'./test.text'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">err, data</span>)</span>&#123;<br>        resolve(data);<br>    &#125;)<br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;)<br>...<br></code></pre></td></tr></table></figure><p>真的是链式调用一时爽，一直链式调用… 就有点难受了。 promise 抑制了回调地狱的横向扩张，却发现自己的纵向扩张也很厉害。</p><ul><li>generator</li></ul><p>generator 函数与普通的函数不同，函数内的代码可以分段执行，也就是说可以暂停执行，凡是需要暂停的地方用 yield 关键字注明。具体用法参考阮老师文章的介绍 <a href="http://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/04/generator.html</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">genFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">let</span> y = <span class="hljs-keyword">yield</span> x * <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">return</span> y;<br>&#125;<br><span class="hljs-keyword">let</span> gen = genFn();<br>gen.next() <span class="hljs-comment">// &#123;value: 2, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: NaN, done: false&#125;</span><br>gen.next() <span class="hljs-comment">// &#123;value: undefined, done: true&#125;</span><br></code></pre></td></tr></table></figure><p>于是对于上面依次读取文件的例子可以改写成如下形式：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 模拟文件请求</span><br><span class="hljs-keyword">function</span> fake<span class="hljs-constructor">ReadFile(<span class="hljs-params">filename</span>, <span class="hljs-params">duration</span>)</span> &#123;<br>    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;<br>        console.log(filename)<br>        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span><br>        gen.next(filename)<br>    &#125;, duration)<br>&#125;<br><br><span class="hljs-keyword">function</span>* gen<span class="hljs-constructor">Fn()</span> &#123;<br>    <span class="hljs-comment">// 顺序请求三个文件，期望的是顺序打印出结果</span><br>    yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">a</span>.<span class="hljs-params">txt</span>', 5000)</span>;<br>    yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">b</span>.<span class="hljs-params">txt</span>', 3000)</span>;<br>    yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">c</span>.<span class="hljs-params">txt</span>', 1000)</span>;<br>&#125;<br><br>const gen = gen<span class="hljs-constructor">Fn()</span>;<br>gen.next<span class="hljs-literal">()</span>;<br><br><span class="hljs-comment">// a.txt   5秒后打印</span><br><span class="hljs-comment">// b.txt   8秒后打印</span><br><span class="hljs-comment">// c.txt   9秒后打印</span><br></code></pre></td></tr></table></figure><p>虽然获取文件所需时长 a &gt; b &gt; c, 但是打印的结果却是 a，b，c，也就是说在 generator 函数内，yield 是按上到下执行的，使得代码执行顺序更清晰明了。</p><p>可以看到我需要在文件请求完成之后手动调用 next 方法，因此在实际工作中，我们通常需要将 generator 函数包裹在一个函数内：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> call<span class="hljs-constructor">Gen()</span> &#123;<br>    <span class="hljs-keyword">function</span>* gen<span class="hljs-constructor">Fn()</span> &#123;<br>        yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">a</span>.<span class="hljs-params">txt</span>', 5000, <span class="hljs-params">gen</span>)</span>;<br>        yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">b</span>.<span class="hljs-params">txt</span>', 3000, <span class="hljs-params">gen</span>)</span>;<br>        yield fake<span class="hljs-constructor">ReadFile('<span class="hljs-params">c</span>.<span class="hljs-params">txt</span>', 1000, <span class="hljs-params">gen</span>)</span>;<br>    &#125;<br>    const gen = gen<span class="hljs-constructor">Fn()</span>;<br>    gen.next<span class="hljs-literal">()</span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> fake<span class="hljs-constructor">ReadFile(<span class="hljs-params">filename</span>, <span class="hljs-params">duration</span>, <span class="hljs-params">g</span>)</span> &#123;<br>    set<span class="hljs-constructor">Timeout(()</span> =&gt; &#123;<br>        console.log(filename)<br>        <span class="hljs-comment">// 这里需要主动调用迭代器对象的 next 方法</span><br>        g.next(filename)<br>    &#125;, duration)<br>&#125;<br><br>call<span class="hljs-constructor">Gen()</span>;<br></code></pre></td></tr></table></figure><p>总的来说，generator 函数改善了 promise 的 then “链条”过长的缺点，但是需要额外创建一个函数来包装。</p><ul><li>async await</li></ul><p>作为 ES7 提出的 async 函数，在 generator 基础上进行优化，是目前 js 处理异步操作的最优解决方案，让异步处理代码可读性更强，流程控制更方便。</p><p>我们按照 async 方法的用法来继续优化上面的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    <span class="hljs-comment">// 因为 await 关键字后面需要接收一个 promise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            resolve(filename)<br>        &#125;, duration)<br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br><br>asyncFn();<br><br><span class="hljs-comment">// 9秒后一次性打印</span><br><span class="hljs-comment">// a.txt </span><br><span class="hljs-comment">// b.txt </span><br><span class="hljs-comment">// c.txt</span><br></code></pre></td></tr></table></figure><p>需要注意的是如果 await 后面表达式里包含异步操作但返回的不是 promise，那么就就不会等待到结果返回，比如这样修改：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fakeReadFile</span>(<span class="hljs-params">filename, duration, g</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (filename === <span class="hljs-string">'a.txt'</span>) &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">return</span> filename<br>        &#125;, duration)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>                resolve(filename)<br>            &#125;, duration)<br>        &#125;)<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">asyncFn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'a.txt'</span>, <span class="hljs-number">5000</span>);<br>    <span class="hljs-built_in">console</span>.log(a)<br>    <span class="hljs-keyword">let</span> b = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'b.txt'</span>, <span class="hljs-number">3000</span>);<br>    <span class="hljs-keyword">let</span> c = <span class="hljs-keyword">await</span> fakeReadFile(<span class="hljs-string">'c.txt'</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-built_in">console</span>.log(b)<br>    <span class="hljs-built_in">console</span>.log(c)<br>&#125;<br>asyncFn();<br><br><span class="hljs-comment">// undefined 立刻输出</span><br><span class="hljs-comment">// b.txt     4秒之后输出</span><br><span class="hljs-comment">// c.txt     4秒之后输出</span><br></code></pre></td></tr></table></figure><p>也就是说第一个 await 没有阻塞 console.log(a) 的执行。因此 async 对 await 后面的表达式又两种处理方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">1.</span> promise<br>   <span class="hljs-keyword">async</span> 会执行表达式并等待有返回值才会继续往下执行代码<br><span class="hljs-number">2.</span> 非 promise<br>   <span class="hljs-keyword">async</span> 执行表达式并立刻获取返回值，如果没有则为 <span class="hljs-literal">undefined</span><br></code></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>js 处理异步的方法经历了 回调函数、promise、generator、async 这四个阶段，每一种新方法都是对前方法的改善，主要处理的点有两点：</p><ol><li>可读性更强</li><li>流程控制更清晰</li></ol>]]></content>
    
    
    <categories>
      
      <category>异步编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
