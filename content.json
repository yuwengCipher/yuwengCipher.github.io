{"meta":{"title":"Cipher","subtitle":"","description":"","author":"cipher","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-16T01:28:06.000Z","updated":"2020-05-16T01:29:30.109Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-16T01:28:06.000Z","updated":"2021-04-29T23:45:42.072Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"探寻 slot 的奥秘","slug":"源码阅读/vue2/探寻 slot 的奥秘","date":"2021-07-17T16:00:00.000Z","updated":"2021-08-30T02:38:52.987Z","comments":true,"path":"2021/07/18/源码阅读/vue2/探寻 slot 的奥秘/","link":"","permalink":"http://yoursite.com/2021/07/18/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%8E%A2%E5%AF%BB%20slot%20%E7%9A%84%E5%A5%A5%E7%A7%98/","excerpt":"","text":"前言slot 思想借鉴于 Web Component，使用 &lt;slot&gt; 为内容提供一个占位符，然后我们就可以往里面填充自定义内容。slot 有不同的用法形式，官方文档也有详细说明，因此本篇不是来讲解用法的，我们的任务是弄明白 slot 工作的原理。 由于 slot 的用法有很多种，每一种涉及的情形和处理也不同，但基本原理是相同的，所以本篇只会讲解具名插槽 named slots 和 作用域插槽 scoped slots。 开始之前，需提前查看 模板怎么变成真实DOM 了解 Vue 大致的渲染流程，在这篇中，transform 步骤讲的是 AST 如何转变为 render 字符串，涉及到的 genELement 方法中会使用 genSlot 处理 slot。 具名插槽我们将 demo 修改为如下所示： 12345678910111213141516// html&lt;div id=\"demo\"&gt; &lt;Child&gt; &lt;template v-slot:default&gt;&#123;&#123;branches[0]&#125;&#125;&lt;/template&gt; &lt;/Child&gt;&lt;/div&gt;// jsVue.component(\"Child\", &#123; template: '&lt;p&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/p&gt;'&#125;)new Vue(&#123; data: &#123; branches: ['A', 'B'] &#125;&#125;) genSlot12345678function genSlot (el, state) &#123; // 获取 slotName，默认为 default var slotName = el.slotName || '\"default\"'; var children = genChildren(el, state); var res = \"_t(\" + slotName + (children ? (\",function()&#123;return \" + children + \"&#125;\") : ''); // 省略 return res + ')'&#125; genSlot 就是将 AST 中的 slot 属性包装成 render 函数字符串，render 函数中使用 _t 方法渲染 slot 属性。此 demo 的 render 函数字符串为 _t(“default”) _t 指向 renderSlot 方法，它最终返回 vnodes。 renderSlot1234function renderSlot (name, fallbackRender, props, bindObject) &#123; var scopedSlotFn = this.$scopedSlots[name]; // 省略&#125; 这里面需要用到 this.$scopedSlots，而 this.$scopedSlots 是在 Vue.prototype._render 函数内部执行 normalizeScopedSlots() 得到的 normalizeScopedSlots123456789101112var vm = this;var ref = vm.$options;var render = ref.render;var _parentVnode = ref._parentVnode;if (_parentVnode) &#123; vm.$scopedSlots = normalizeScopedSlots( _parentVnode.data.scopedSlots, vm.$slots, vm.$scopedSlots );&#125; 这里面又涉及到几个属性，在说明之前，需要搞清楚子组件一个大概的处理流程： 首先在父组件页面，对 Child 组件使用 _c 方法处理，会创建它的 vnode，创建代码如下： 123456var vnode = new VNode( (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')), data, undefined, undefined, undefined, context, &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;, asyncFactory) 最后一个对象会作为 componentOptions 传入，Ctor 是构造函数 VueComponent ，children 是 branches[0]。 然后就需要渲染子组件本身了，调用的方法就是创建组件的构造函数，也就是执行 new vnode.componentOptions.Ctor(options)，然后在内部就会调用 _init(options)。入参 options 如下所示： 12345var options = &#123; _isComponent: true, _parentVnode: vnode, parent: parent&#125; options._parentVnode 就是 Child vnode。 知道了这个处理流程后，下面就说明 normalizeScopedSlots 入参： _parentVnode 就是 Child vnode，那 data.scopedSlots 是被 Child 组件包裹的 slot 属性，这个后面会具体说。 另外两个参数 vm.$slots 和 vm.$scopedSlots 初始定义在 initRender 方法里。 initRender12345678910// 省略function initRender (vm) &#123; var options = vm.$options; // parentVnode 就是子组件在父组件中的占位符，也就是 Child 组件 var parentVnode = vm.$vnode = options._parentVnode; // context 就是 vue var renderContext = parentVnode &amp;&amp; parentVnode.context; vm.$slots = resolveSlots(options._renderChildren, renderContext); vm.$scopedSlots = emptyObject;&#125; vm.$scopedSlots 默认是一个空对象。vm.$slots 是执行 resolveSlots 方法得到的。这里需要弄清楚 _renderChildren 是什么 由于 Child 是 component，所以在调用 _init(options) 初始化时执行的是 initInternalComponent(vm, options)， 123456// initInternalComponent// 省略var opts = vm.$options = Object.create(vm.constructor.options);var parentVnode = options._parentVnode;var vnodeComponentOptions = parentVnode.componentOptions;opts._renderChildren = vnodeComponentOptions.children; vnodeComponentOptions.children 指的是 Child 组件在父组件中的占位 vnode，在这里就是 branches[0] 所对应的 vnode。 那现在我们来看看 resolveSlots([vnode], vm) 的执行结果 123456789101112131415161718192021222324252627282930function resolveSlots ( children, context) &#123; if (!children || !children.length) &#123; return &#123;&#125; &#125; var slots = &#123;&#125;; for (var i = 0, l = children.length; i &lt; l; i++) &#123; var child = children[i]; var data = child.data; if (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123; delete data.attrs.slot; &#125; if ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != null ) &#123; var name = data.slot; var slot = (slots[name] || (slots[name] = [])); if (child.tag === 'template') &#123; slot.push.apply(slot, child.children || []); &#125; else &#123; slot.push(child); &#125; &#125; else &#123; (slots.default || (slots.default = [])).push(child); &#125; &#125; return slots&#125; 先创建一个声明式对象 slots，如果 children 存在，那么就会去遍历 children 如果 child vnode 是作为 slot，那么就要删除 data.attrs.slot 如果 存在多个 named slot，只有与 Child 组件存在于同一个上下文才会被存入 slots[name] 中 否则就存入 slots[default] 中 由于文本 vnode 不存在 data 属性，因此这里会进入最后一个分支，为 slots 添加 default 数组并将 vnode 存入，即 slots = {default: [vnode]}。 总结来说，就是不同类型的 slot 会被存入不同的集合中。 弄明白了这些之后，我们再回过头来看看 normalizeScopedSlots。 它有三个参数，第一个 slots 是上面的 _parentVnode.data.scopedSlots，值是 undefined；第二个 normalSlots 是 resolveSlots() 的值 slots；第三个参数 vm.$scopedSlots 是一个空对象。 1234567891011121314151617181920212223242526272829303132333435363738394041function normalizeScopedSlots ( slots, normalSlots, prevSlots) &#123; var res; var hasNormalSlots = Object.keys(normalSlots).length &gt; 0; var isStable = slots ? !!slots.$stable : !hasNormalSlots; var key = slots &amp;&amp; slots.$key; if (!slots) &#123; res = &#123;&#125;; &#125; else if (slots._normalized) &#123; return slots._normalized &#125; else if ( isStable &amp;&amp; prevSlots &amp;&amp; prevSlots !== emptyObject &amp;&amp; key === prevSlots.$key &amp;&amp; !hasNormalSlots &amp;&amp; !prevSlots.$hasNormal ) &#123; return prevSlots &#125; else &#123; res = &#123;&#125;; for (var key$1 in slots) &#123; if (slots[key$1] &amp;&amp; key$1[0] !== '$') &#123; res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]); &#125; &#125; &#125; // expose normal slots on scopedSlots for (var key$2 in normalSlots) &#123; if (!(key$2 in res)) &#123; res[key$2] = proxyNormalSlot(normalSlots, key$2); &#125; &#125; def(res, '$stable', isStable); def(res, '$key', key); def(res, '$hasNormal', hasNormalSlots); return res&#125; 由于 slots 不存在，那么 res = {}，然后遍历 normalSlots，为 res 添加 slot 属性：key 是 ‘default’，value 方法 proxyNormalSlot。 123function proxyNormalSlot (slots, key) &#123; return function () &#123; return slots[key]; &#125;&#125; proxyNormalSlot 返回的也是一个方法，执行这个方法就会得到对应 slotName 的 vnode，在这里就是 return slots[‘default’]。 最后是给 res 添加 $stable、$key、$hasNormal 这三个属性。 也就是说 $scopedSlots 是如下对象： 123456$scopedSlots = &#123; default: () =&gt; &#123; return vnode&#125;, $stable: isStable, $key: key, $hasNormal: hasNormalSlots,&#125; 现在 $scopedSlots 对象拿到了，那么在 renderSlot 内就可以通过 this.$scopedSlots[‘default’] 拿到对应的 vnode，后面就是进入正常的 DOM 创建流程了。 以上，我们关注重点信息，梳理了 slot 内容是如何从父组件传递到子组件的过程，可以结合下图进行查看： 同名插槽上面的例子中只有一个 default slot，假如存在多个同名插槽，会是一个什么样的结果呢？。 将例子稍微改动如下：有2个相同的 default 和 b 插槽。 12345678910111213&lt;div id=\"demo\"&gt; &lt;Child&gt; &lt;template&gt;default: &#123;&#123;branches[0]&#125;&#125;&lt;/template&gt;&lt;br&gt; &lt;template&gt;default: &#123;&#123;branches[1]&#125;&#125;&lt;/template&gt;&lt;br&gt; &lt;template v-slot:b&gt;b: &#123;&#123;branches[1]&#125;&#125;&lt;/template&gt;&lt;br&gt; &lt;template v-slot:b&gt;b: &#123;&#123;branches[0]&#125;&#125;&lt;/template&gt; &lt;/Child&gt;&lt;/div&gt;// jsVue.component(\"Child\", &#123; template: '&lt;p&gt;&lt;slot&gt;&lt;/slot&gt;&lt;slot name=\"b\"&gt;&lt;/slot&gt;&lt;/p&gt;'&#125;) 经过 normalizeScopedSlots 处理之后，可以看到 $scopedSlots 是这样： 1234567$scopedSlots = &#123; b: () =&gt; &#123; return vnode&#125;, default: () =&gt; &#123; return vnode&#125;, $stable: isStable, $key: key, $hasNormal: hasNormalSlots,&#125; 但是页面显示为: 1234default: Adefault: Bb: A 父组件的 AST 处理生成的 render 函数如下： 1234(function anonymous() &#123;with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('child',&#123;scopedSlots:_u([&#123;key:\"b\",fn:function()&#123;return [_v(_s(branches[0]))]&#125;,proxy:true&#125;])&#125;,[[_v(_s(branches[0]))],_c('br'),_v(\" \"),[_v(_s(branches[1]))],_c('br'),_v(\" \"),_c('br')],2)],1)&#125;&#125;) 假如再修改成下面这样：为默认 template 添加了一个 v-slot:default 1234&lt;template&gt;default: &#123;&#123;branches[0]&#125;&#125;&lt;/template&gt;&lt;br&gt;&lt;template v-slot:default&gt;default: &#123;&#123;branches[1]&#125;&#125;&lt;/template&gt;&lt;br&gt;&lt;template v-slot:b&gt;b: &#123;&#123;branches[1]&#125;&#125;&lt;/template&gt;&lt;br&gt;&lt;template v-slot:b&gt;b: &#123;&#123;branches[0]&#125;&#125;&lt;/template&gt; 页面显示为： 1default: Bb: A 父组件的 AST 处理生成的 render 函数如下： 1234(function anonymous() &#123;with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('child',&#123;scopedSlots:_u([&#123;key:\"default\",fn:function()&#123;return [_v(\"default: \"+_s(branches[1]))]&#125;,proxy:true&#125;,&#123;key:\"b\",fn:function()&#123;return [_v(\"b: \"+_s(branches[0]))]&#125;,proxy:true&#125;])&#125;,[[_v(\"default: \"+_s(branches[0]))],_c('br'),_v(\" \"),_c('br'),_v(\" \"),_c('br')],2)],1)&#125;&#125;) 结合以上例子的不同结果，可以得出一个结论：默认插槽多个内容会合并显示，具名插槽会以最后一个内容显示，并且如果存在具名 default，那么默认插槽的内容就会被舍弃。 那现在有两个问题，一个是同名具名插槽为什么会只保留最有一个？另一个是具名 default 为什么会导致默认 default 内容丢失？ 接下来我们先看看第一个问题。 可以看到 Child 组件中具名插槽这一部分被当做 scopedSlots 存入 data 中进行处理，处理的方法是 _u，也就是 resolveScopedSlots。其他的则存入 children 中正常处理。那我们继续往前查看 AST tree。 开始之前，需要了解一点，模板字符串是以标签为单位进行分隔处理的，每一对标签处理结束时会调用 closeElement 方法处理。 步骤一：首先会执行 processElement 方法。 123if (!inVPre &amp;&amp; !element.processed) &#123; element = processElement(element, options);&#125; 在它的内部执行 processSlotContent(element) 处理 slot，因为我们用的新语法即使用 template 标签来包括内容，所以只看下面这部分： 1234567891011121314151617181920212223242526if (el.tag === 'template') &#123; var slotBinding = getAndRemoveAttrByRegex(el, slotRE); if (slotBinding) &#123; &#123; if (el.slotTarget || el.slotScope) &#123; warn$2( \"Unexpected mixed usage of different slot syntaxes.\", el ); &#125; if (el.parent &amp;&amp; !maybeComponent(el.parent)) &#123; warn$2( \"&lt;template v-slot&gt; can only appear at the root level inside \" + \"the receiving component\", el ); &#125; &#125; var ref = getSlotName(slotBinding); var name = ref.name; var dynamic = ref.dynamic; el.slotTarget = name; el.slotTargetDynamic = dynamic; el.slotScope = slotBinding.value || emptySlotScopeToken; &#125;&#125; 在模板中的标签被处理时，标签上的属性会被存进 AST 中的 attrList 中，那么 v-slot 属性就会被存进去。getAndRemoveAttrByRegex(el, slotRE) 就是取出 slot 属性对象 slotBinding，然后就是为自身 AST 添加 slot 相关的 slotTarget、slotScope 等属性 步骤二：为父 AST 添加 scopedSlots 属性。 processElement 处理完成后，接着会执行下面这段逻辑： 1234567891011if (currentParent &amp;&amp; !element.forbidden) &#123; if (element.elseif || element.else) &#123; processIfConditions(element, currentParent); &#125; else &#123; if (element.slotScope) &#123; var name = element.slotTarget || '\"default\"' ; (currentParent.scopedSlots || (currentParent.scopedSlots = &#123;&#125;))[name] = element; &#125; // 省略 &#125;&#125; currentParent 是 Child，而且 template 标签中不存在 v-if 等指令，那么就会进入第二分支。 element.slotScope 和 element.slotTarget 在 processElement 处理时已经加上了。首先将 element.slotTarget 也就是 slot 的名称赋值给 name。然后就是对 currentParent.scopedSlots 的处理，如果不存在就声明为对象；如果它存在，那么就将当前 AST 作为一个属性存入，key 就是 template 的 slot 命名，比如说这种： currentParent.scopedSlots[‘b’] = bAST 概括来说，步骤一是为 AST 添加 slotTarget 和 slotScope 等属性，步骤二是将 AST 存入父组件的 scopedSlots 对象中。经过第二个步骤的处理，同名插槽会覆盖前面的内容，也就是说同名插槽只保留最后一个的内容。 现在来看第二个问题。 我们知道 render 函数中的 _u 就是 resolveScopedSlots 1234567891011121314151617181920212223function resolveScopedSlots ( fns, res, hasDynamicKeys, contentHashKey) &#123; res = res || &#123; $stable: !hasDynamicKeys &#125;; for (var i = 0; i &lt; fns.length; i++) &#123; var slot = fns[i]; if (Array.isArray(slot)) &#123; resolveScopedSlots(slot, res, hasDynamicKeys); &#125; else if (slot) &#123; if (slot.proxy) &#123; slot.fn.proxy = true; &#125; res[slot.key] = slot.fn; &#125; &#125; if (contentHashKey) &#123; (res).$key = contentHashKey; &#125; return res&#125; 它的第一个参数是一个数组，比如说下面这种： 1[&#123;key:\"default\",fn:function()&#123;return [_v(\"default: \"+_s(branches[1]))]&#125;,proxy:true&#125;,&#123;key:\"b\",fn:function()&#123;return [_v(\"b: \"+_s(branches[0]))]&#125;,proxy:true&#125;] 在对数组的循环处理中，内部逻辑最终会进入第二个分支，执行 res[slot.key] = slot.fn，那么 res 就拥有了名称为 b 和 default 的方法。也就是说在执行 _c(‘child’) 时， Child vnode 的 scopedSlots 是一个拥有这2个方法的对象。 我们再回到 Child 组件内部的 slot 处理方法 normalizeScopedSlots，我们看一下重点部分，简化后如下所示 123456789101112res = &#123;&#125;;for (var key$1 in slots) &#123; if (slots[key$1] &amp;&amp; key$1[0] !== '$') &#123; res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]); &#125;&#125;for (var key$2 in normalSlots) &#123; if (!(key$2 in res)) &#123; res[key$2] = proxyNormalSlot(normalSlots, key$2); &#125;&#125; 这里的 slots 就是 _parentVnode.data.scopedSlots，拥有 b 和 default 方法；normalSlots 是被 Child 组件包裹的 vnode。 第一个循环里，是对 normalSlots 的处理 12345678910111213141516171819202122function normalizeScopedSlot (normalSlots, key, fn) &#123; var normalized = function () &#123; var res = arguments.length ? fn.apply(null, arguments) : fn(&#123;&#125;); res = res &amp;&amp; typeof res === 'object' &amp;&amp; !Array.isArray(res) ? [res] : normalizeChildren(res); var vnode = res &amp;&amp; res[0]; return res &amp;&amp; ( !vnode || (res.length === 1 &amp;&amp; vnode.isComment &amp;&amp; !isAsyncPlaceholder(vnode)) ) ? undefined : res &#125;; if (fn.proxy) &#123; Object.defineProperty(normalSlots, key, &#123; get: normalized, enumerable: true, configurable: true &#125;); &#125; return normalized&#125; normalizeScopedSlot 实际上就是返回一个方法，也就是每遍历一个 vnode，就会为 res 添加一个方法，那么如果遇到同名的，就会覆盖掉原有的。另外还重写了 normalSlots，它本来是 Child 包裹的 vnode，但是经过处理后，它也是跟 scopedSlots 类似的对象。当前的例子来说，就是将它变成拥有 b 和 default 方法的对象。也就是说默认 default 的内容被去除了。 作用域插槽简单来说，作用域插槽使父组件能够获取到子组件里的属性。 我们将 demo 改成如下所示： 123456789101112&lt;Child&gt; &lt;template v-slot:default=\"slotProps\"&gt;change in parent: &#123;&#123;slotProps.branchesInChild[1]&#125;&#125;&lt;/template&gt;&lt;br&gt;&lt;/Child&gt;Vue.component(\"Child\", &#123; data () &#123; return &#123; branchesInChild: ['A', 'B'], &#125; &#125;, template: '&lt;p&gt;&lt;slot v-bind:branchesInChild=\"branchesInChild\"&gt;render in child: &#123;&#123;branchesInChild[0]&#125;&#125;&lt;/slot&gt;&lt;/p&gt;'&#125;) Child 组件默认应该会渲染成 render in child: A，但是我们做了修改如父组件中所示，页面会被渲染成 change in parent: B。 说明可以在父组件层面拿到子组件提供的信息去决定 Child 组件的渲染。这在日常工作中经常遇到，也非常有用，比如说需要将 table 组件中的某一个 column 渲染的信息自定义。 接下来就以此为例看看这是如何实现的吧。 首先看 processSlotContent(element) 处理 template 标签中的 slot 属性（上面有罗列代码，这里不重复了）： 它通过 getAndRemoveAttrByRegex 拿到 slotBinding，其中就包括我们绑定的 default=slotProps，name 是 ‘default’，value 是 ‘slotProps’。将 ‘default’ 赋值给 element.slotTarget、 ‘slotProps’ 赋值给 element.slotScope。 我们来看看 parnet 组件的 render 函数 1234(function anonymous() &#123;with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('child',&#123;scopedSlots:_u([&#123;key:\"default\",fn:function(slotProps)&#123;return [_v(\"change in parent: \"+_s(slotProps.branchesInChild[1]))]&#125;&#125;])&#125;,[_c('br')])],1)&#125;&#125;) 可以看到 scopedSlots 中的处置方法现在需要接收 slotProps 对象用作渲染指定属性，而且渲染的就是我们在父组件中设置的值 change in parent: 。 依据上面 normalizeScopedSlots 方法的解析我们知道，vm.$scopedSlots.default 就会是封装这个 fn 的 normalized 方法。它在内部会接收参数，作为入参调用 fn。 1var res = arguments.length ? fn.apply(null, arguments) : fn(&#123;&#125;); 那现在就需要看看这个 slotProps 对象是如何传进去的。 先看看 Child 组件内部的 render 函数 1234(function anonymous() &#123;with(this)&#123;return _c('p',[_t(\"default\",function()&#123;return [_v(\"render in child: \"+_s(branchesInChild[0]))]&#125;,&#123;\"branchesInChild\":branchesInChild&#125;)],2)&#125;&#125;) _t 是 renderSlot，三个参数分别是 fnKey、fnVal 和 {“branchesInChild”:branchesInChild}。这里的重点就是多了一个 {“branchesInChild”:branchesInChild} 这个对象，它会作为 props 传入 renderSlot 中，用于通过 this.$scopedSlots 中的方法获取 vnodes。 1234567891011121314151617181920212223242526272829303132function renderSlot ( name, fallbackRender, props, bindObject) &#123; var scopedSlotFn = this.$scopedSlots[name]; var nodes; if (scopedSlotFn) &#123; props = props || &#123;&#125;; if (bindObject) &#123; if (!isObject(bindObject)) &#123; warn('slot v-bind without argument expects an Object', this); &#125; props = extend(extend(&#123;&#125;, bindObject), props); &#125; nodes = scopedSlotFn(props) || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender); &#125; else &#123; nodes = this.$slots[name] || (typeof fallbackRender === 'function' ? fallbackRender() : fallbackRender); &#125; var target = props &amp;&amp; props.slot; if (target) &#123; return this.$createElement('template', &#123; slot: target &#125;, nodes) &#125; else &#123; return nodes &#125;&#125; 简单梳理一下处理逻辑： 首先获取到 vm.$scopedSlots[‘default’] 方法。这个是存在的，进入第一个分支。 props 就是第三个对象参数，bindObject 不存在，那么就直接执行 scopedSlotFn(props)，将 branchesInChild 传入了 default 方法中去获取 vnodes，赋值给 nodes props.slot 不存在，直接返回 nodes。 就这样在 renderSlot 方法内部将 branchesInChild 信息作为入参，使用 vm.$scopedSlots[‘default’] 方法获取到了 Child 组件包裹的 vnodes，然后将 vnodes 创建为 DOM 渲染到了页面上，实现了在父组件拿到子组件指定的信息，然后渲染自定义信息的功能。 最后本篇主要了解了 slot 渲染的原理以及 scoped slot 实现的原理，总结如下： 默认插槽其实跟一般的具名插槽一样，因为它会被默认为 default 插槽 父组件针对 template 上的插槽名称会创建对应方法存于 scopedSlots，执行这个方法就会返回被 template 包裹的内容 vnodes。如果存在同名的，只会保留后一个的内容。然后子组件内部渲染时会去找插槽名对应的方法去渲染。 父组件中 template 的 v-slot:default=”slotProps” 在被转成 render 字符串时会给方法添加一个可以接收的参数 slotProps;子组件中 slot 的 v-bind:branchesInChild=”branchesInChild” 在被转成 render 字符串时会给 _t 方法添加一个 props 参数 {“branchesInChild”:branchesInChild}。这样就可以将 props 传入方法中去获取 vnodes。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"简单说说 Vue diff 算法","slug":"源码阅读/vue2/简单说说 Vue diff 算法","date":"2021-06-24T16:00:00.000Z","updated":"2021-09-01T03:03:43.545Z","comments":true,"path":"2021/06/25/源码阅读/vue2/简单说说 Vue diff 算法/","link":"","permalink":"http://yoursite.com/2021/06/25/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E7%AE%80%E5%8D%95%E8%AF%B4%E8%AF%B4%20Vue%20diff%20%E7%AE%97%E6%B3%95/","excerpt":"","text":"前言diff 针对的目标是 vnode 即 virtual dom。那为什么需要 vnode 呢？根本目的不是为了节约 DOM 操作的性能开销，而是可以多端使用。如果根标签下只有一个文本，直接使用原生方法去操作 DOM 肯定是要比使用 vnode 更好的，因此说 vnode 节约性能开销还是会需要基于内容多少去谈。vnode 是字符串模板经过 AST 转换，再到 render 函数转换，最后由 render 函数生成的，那么就可以用于服务端，由服务端去创建 html 并返回给客服端使用。 在模板怎么变成真实DOM篇中，我们将侧重点放在了整个渲染流程，关注的是初始渲染。那这一篇就来看看当页面更新渲染时发生的 patchVnode，以及涉及到的 diff 算法。 修改 demo 如下： 12345678910111213141516// html&lt;div id=\"demo\"&gt; &lt;ul&gt; &lt;li v-for=\"(branch, index) in branches\"&gt;&#123;&#123;branch&#125;&#125;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;// jsdata: &#123; branches: ['A', 'B', 'C', 'D'],&#125;,mounted () &#123; setTimeout(() =&gt; &#123; this.branches = ['A', 'E', 'B', 'F', 'C', 'D'] &#125;, 1000)&#125;, patchVnode跟初次渲染走 createElm 分支不同的是，更新渲染执行的是 patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly) 12345678910111213141516171819202122function patchVnode (oldVnode, vnode, insertedVnodeQueue, ownerArray, index, removeOnly) &#123; // 省略 var oldCh = oldVnode.children; var ch = vnode.children; if (isUndef(vnode.text)) &#123; if (isDef(oldCh) &amp;&amp; isDef(ch)) &#123; if (oldCh !== ch) &#123; updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); &#125; &#125; else if (isDef(ch)) &#123; &#123; checkDuplicateKeys(ch); &#125; if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, ''); &#125; addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue); &#125; else if (isDef(oldCh)) &#123; removeVnodes(oldCh, 0, oldCh.length - 1); &#125; else if (isDef(oldVnode.text)) &#123; nodeOps.setTextContent(elm, ''); &#125; &#125; else if (oldVnode.text !== vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text); &#125;&#125; 我们省略掉不重要的处理之后，剩下的就是需要关注的重点。 依据新 vnode.text 是否存在分为两种情况进行处理。如果存在 vnode.text 意味着当前 vnode 就是文本类型，那么只需在判断 oldVnode 与 vnode 文本不相等之后重新更新 text 就行。如果 vnode.text 不存在又分为多种情况。 第一种：oldCh 与 ch 都存在并且它们不相等，调用 updateChildren 处理 oldCh 与 ch。第二种：只存在 ch，说明是新增加的 child。 首先检查 child 的 children 的 key 是否重复 如果 oldVnode.text 存在，则需将 elm 的文本内容赋值为空字符串 最后调用 addVnodes 将 ch 添加到 elm 中第三种：只存在 oldCh, 说明该 oldCh 需要被删除掉，所以调用 removeVnodes 执行删除操作第四种：oldCh 与 ch 都不存在，但是 oldVnode.text 存在，那么也是会将 elm 的文本内容赋值为空字符串 接下来我们来看看 updateChildren 是如何处理 children 的。 diff当 newVnode 拥有 children 并且当 oldCh 和 ch 不相等时，这时就会执行 updateChildren 对 oldCh 和 ch 进行 diff 操作。 1234567891011function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) &#123; var oldStartIdx = 0; var newStartIdx = 0; var oldEndIdx = oldCh.length - 1; var oldStartVnode = oldCh[0]; var oldEndVnode = oldCh[oldEndIdx]; var newEndIdx = newCh.length - 1; var newStartVnode = newCh[0]; var newEndVnode = newCh[newEndIdx]; var oldKeyToIdx, idxInOld, vnodeToMove, refElm;&#125; 这部分是 diff 操作的准备工作。对于新旧 vnode，分别有各自的 startIdx、endIdx、startVnode、endVnode。 然后就开始真正的 diff 过程。通过 while 循环来按照一定的规则比对新旧 vnode，最后执行新增、更新或者移除操作。比对的顺序是从两端向中间移动，这些规则分为7种情况。 另外为了表述的简洁，我在这里将 startIdx 向右移动一位并且 startVnode 重新指向这个 vnode 称为 startVnode 右进一位，将 endIdx 向左移动一位并且 endVnode 重新指向这个 vnode 称为 endVnode 左进一位。 diff 情形第一种123if (isUndef(oldStartVnode)) &#123; oldStartVnode = oldCh[++oldStartIdx];&#125; 如果 oldStartVnode 不存在，oldStartVnode 右进一位。 第二种123if (isUndef(oldEndVnode)) &#123; oldEndVnode = oldCh[--oldEndIdx];&#125; 如果 oldEndVnode 不存在，oldEndVnode 左进一位。 第三种12345if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx];&#125; 进入这一分支，说明 oldStartVnode 和 newStartVnode 都存在，那么就会比较他们是否是同一个 vnode。那什么情况是 sameVnode 呢？看看它是如何判断的吧。 12345678910111213141516function sameVnode (a, b) &#123; return ( a.key === b.key &amp;&amp; a.asyncFactory === b.asyncFactory &amp;&amp; ( ( a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) ) || ( isTrue(a.isAsyncPlaceholder) &amp;&amp; isUndef(b.asyncFactory.error) ) ) )&#125; 可以里面涉及到许多属性的判断，在这里就不具体去说了。为了便于理解，依据我们当前 demo 来说，就是判断 key 是否相等。 由于我们没有设置 key 属性，因此这里的以及后面的 sameVnode 判断都默认为 true。 判断通过后，就调用 patchVnode 处理 oldStartVnode 和 newStartVnode。处理完成后，oldStartVnode 和 newStartVnode 都右进一位。 第四种12345if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx];&#125; 如果 oldEndVnode 和 newEndVnode 是同一个 vnode，同样使用 patchVnode 处理它们，完成后 oldEndVnode 和 newEndVnode 都左进一位。 第五种123456if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx];&#125; 进入这一分支，说明 oldStartVnode 与 newStartVnode 不相等并且 oldEndVnode 与 newEndVnode 也不相等。那么此时需要将 oldStartVnode 与 newEndVnode 进行比较，这样比较的原因是考虑到一种情况，那就是原来旧 vnode 中的某一项在新 node 树中位置向右移动了，那么就不用进行移除和新增 dom，而只需要移动 dom 就行，节约了移除和新增的新能开销。 处理完成后，oldStartVnode 向右进一位，newEndVnode 向左进一位。 第六种123456if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); canMove &amp;&amp; nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx];&#125; 这一种与上面说的情况相反，考虑的是原来旧 vnode 中的某一项在新 node 树中位置向左移动了，因此处理 oldEndVnode 和 newStartVnode。 处理完成后，newStartVnode 向右进一位，oldEndVnode 向左进一位。 第七种进入这个分支，说明新旧 vnode 树前后都不相等。我们来看看它是如何处理这种情况的 1234if (isUndef(oldKeyToIdx)) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); &#125;idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx); oldKeyToIdx 是未处理 oldVnode 在 oldCh 中的位置信息，比如说现在就剩 B 没有处理，并且都设置了 key 为自身，如下所示 1&lt;li v-for=\"(branch, index) in branches\" :key=\"branch\"&gt;&#123;&#123;branch&#125;&#125;&lt;/li&gt; 那么 oldKeyToIdx 就像这样 123oldKeyToIdx = &#123; B: 1&#125; 对象集合中的 key 是 Vnode.key，value 是在 oldCh 中的下标。 然后就是获取 newStartVnode 在 oldCh 里的位置下标，分为两种情况。一是如果 newStartVnode.key 存在，那么就拿这个 key 去 oldKeyToIdx 匹配；二是 newStartVnode.key 不存在，调用 findIdxInOld 去寻找下标。 123456789101112if (isUndef(idxInOld)) &#123; createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);&#125; else &#123; vnodeToMove = oldCh[idxInOld]; if (sameVnode(vnodeToMove, newStartVnode)) &#123; patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx); oldCh[idxInOld] = undefined; canMove &amp;&amp; nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm); &#125; else &#123; createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx); &#125;&#125; 到这里就可以拿到 idxInOld 了。接下来就分两种情况进行操作了： 如果 idxInOld 不存在，说明 newStartVnode 是新增的，那么就调用 createElm 创建新 DOM 并插入 DOM； 如果 idxInOld 存在，就在 oldCh 中找到这个下标的 vnode，赋值给 vnodeToMove。 如果 vnodeToMove 与 newStartVnode 相等，则调用 patchVnode 处理它们。处理完成后，将 oldCh[idxInOld] 赋值为 undefined，然后执行移动操作。 如果不相等，说明它们的 key 相同，但由于是不同的 elm，那么也还是按照新增处理，调用 createElm 方法。 上面的处理完成后，newStartVnode 向右进一位。 新增或是移除两棵 vnode tree 如下： 理想状态是经过上述7种情况的处理，如果新旧 vnode 的数量是一样的，那么 oldCh 和 ch 都会同时处理完成。但是按照文章开头设置的 dmeo 来执行的话，最后会剩下 C、D 两个节点没有处理，那么就会执行新增操作。如果将例子相反设置，那么 E、F 就会被执行移除操作。 相信你发现了一个问题，那就是处理 C、D 的新增操作其实是不必要的，因为它们本来就在 oldCh 中存在，我们只需要复用就行了。那是什么原因导致没有按照设想的步骤来执行的呢？ diff 过程在上面的 demo 中，我们在用 v-for 渲染列表时并没有添加 key 属性。也就是因为没有设置 key，在比较 sameVnode 时 由于 undefined === undefined，sameVnode() 一直为 true，所以才会一直执行第三种情况，自始至终都是都是从头向尾进行 patch。 由于 oldCh 长度大于 ch，当 ch 处理完之后，oldCh 还剩两项，进入下一轮比较时，oldStartIndx(4) &gt; oldEndIndx(3)，就会跳出循环，执行 addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue)。其中 newStartIdx = 3，newEndIdx = 5，它们的中间就是 C 和 D 所对应的 li vnode，那么这两个 vnode 就会被拿去创建成 DOM。 我们都知道官方提醒我们在使用 v-for 渲染列表时要给每一项都设置独一无二的 key，这是为什么呢？因为独一无二的 key 可以匹配真正相同的 vnode，过滤假的相同。这句话怎么理解呢？ 我们先给每一项都设置 key 为 index，如下： 1&lt;li v-for=\"(branch, index) in branches\" :key=\"index\"&gt;&#123;&#123;branch&#125;&#125;&lt;/li&gt; 按理说一个列表中的 index 是不可能相等的，但是如果按照 sameVnode 的判断逻辑来说，B 所对应的 li 与 E 所对应的 li 依然还是相同的，因为它们所处的位置下标都是1，那么 key 都是 1，因此 key 设置成 index 是无效的。 如果我们把 key 设置成 branch，B 和 E 是不可能相等的，那么就过滤掉了这个假相同，达到了我们的目的。因此我们平时在写业务代码时可以把 key 设置成 id。 1&lt;li v-for=\"(branch, index) in branches\" :key=\"branch\"&gt;&#123;&#123;branch&#125;&#125;&lt;/li&gt; 按照前后顺序进行处理，当新旧树中相同部分的 A、C、D 被处理结束后，就剩如下所示： 此时就会进入第七种情况处理 E。去获取 E 在 oldCh 中的下标，因为 oldCh 不存在 E，所以 idxInOld = undefined，那么就当做新 elm，做新增处理，它在 ch 中的位置下标为 1，那么就会插入到下标为1的位置。 然后进入第三种情况处理 B。处理完之后只剩下 F，又会被当做新 elm，做新增处理，它在 ch 中的位置下标为 3，插入到下标为3的位置。 最后这篇文章从源码的角度简单讲述了 Vue diff 的过程，目的是对 diff 原理有一个大框架上的理解。简单总结一下： diff 采用的策略是从两头往中间进行 diff patch 新旧树中存在多个相同 vnode，只是位置不同时，设置独一无二的 key 有助于减少创建 DOM 带来的性能消耗","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue 检测变化的限制及相应处理办法","slug":"源码阅读/vue2/Vue 检测变化的限制及相应处理办法","date":"2021-06-06T16:00:00.000Z","updated":"2021-08-19T07:18:22.221Z","comments":true,"path":"2021/06/07/源码阅读/vue2/Vue 检测变化的限制及相应处理办法/","link":"","permalink":"http://yoursite.com/2021/06/07/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/Vue%20%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E9%99%90%E5%88%B6%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%A4%84%E7%90%86%E5%8A%9E%E6%B3%95/","excerpt":"","text":"前言官方文档说：由于 JavaScript 的限制，Vue 不能检测数组和对象的变化。然后分别列出了对象及数组中存在的限制情况和解决办法。由于它只说明是 JavaScript 的限制，具体原因没有提及，这难免会让人感到些许疑惑。因此本篇就是专门记录这个限制的原因及解决办法的原理。 限制的真正原因大家都知道，Vue 使用 Object.defineProperty 去对 data 中的数据增加数据劫持，然后这些数据就拥有了响应式属性。那会是 Object.defineProperty 的限制吗？先看数组方面的限制，我们写一个小 demo 测试一下： 12345678910let arr = [1, 2]Object.defineProperty(arr, 0, &#123; get: function() &#123; return 1 &#125;, set: function(newVal) &#123; console.log('set value: ' + newVal) &#125;&#125;)arr[0] = 3 将数组下标 0 位置做了数据劫持，然后执行 arr[0] = 3，发现控制台打印除了 set value: 3。也就是说对数组做数据劫持是没有问题的。那 Vue 是怎么处理数组的呢？我们来看下官方 demo，修改如下： 1234567891011121314// html&lt;div id=\"demo\"&gt; &#123;&#123; JSON.stringify(branches) &#125;&#125;&lt;/div&gt;// jsdata: &#123; branches: ['master', 'dev', &#123; testArray: 'tag_0' &#125;],&#125;mounted () &#123; setTimeout(() =&gt; &#123; this.branches[0] = 'tag_1' &#125;, 1000)&#125;, 1秒之后将 branches.master 赋值为 ‘tag_1’, 但是页面依然显示的是 [“master”,”dev”,{“testArray”:”tag_0”}]，跟官方描述的一样，这样的设置是不会更新页面的。 我们找到源码中的 initData 方法。它最终会执行 observe(data, true /* asRootData */)。 123456789101112131415161718192021function observe (value, asRootData) &#123; if (!isObject(value) || value instanceof VNode) &#123; return &#125; var ob; if (hasOwn(value, '__ob__') &amp;&amp; value.__ob__ instanceof Observer) &#123; ob = value.__ob__; &#125; else if ( shouldObserve &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) &#123; ob = new Observer(value); &#125; if (asRootData &amp;&amp; ob) &#123; ob.vmCount++; &#125; return ob&#125; 想要真正的拥有响应式属性，必须得执行 ob = new Observer(value) 这一段代码，但是由于我们所修改的第一项 ‘master’ 并不是对象，因此不会执行到下面，也就是说 master 属性不是响应式的，那么当修改它时，Vue 就无法检测了。 那只要是数组里的属性都无法通过下标修改吗？我们试着修改一下数组中第三项的属性: 12345mounted () &#123; setTimeout(() =&gt; &#123; this.branches[2].testArray = 'tag_1' &#125;, 1000)&#125;, 可以看到页面在1秒之后显示为 [“master”,”dev”,{“testArray”:”tag_1”}]。说明 Vue 是可以监测到数组属性的修改。因为 this.branches[2] 是一个对象，通过了第一层判断，会执行添加响应式属性的代码，所以 Vue 能检测到变动。 总结起来，原因是 Vue 对数组中的非对象属性不会添加响应式属性，所以通过下标修改的属性如果不是对象，Vue 是检测不到的，而如果是对象则能正常响应。 至于为什么这样设计，尤大大解释是对性能及用户体验性价比的考量。 那对于对象而言，假如现在根对象有一个对象 anotherBranch: {}, 当我们使用 this.anotherBranch.tag = ‘tag_3’，那么这个 tag 属性也不是响应式的。了解生命周期的应该知道，当我们添加属性时，添加响应式属性过程已经执行完毕了。 如何回避限制有了这样的设计，官方也给出了如何去回避这些限制的解决办法。对象和数组的解决办法中有一个相同点，那就是使用 $set 方法。比如说我想修改 master 的值，那我可以这样用： this.$set(this.branches, 0, ‘tag_1’) 1秒之后页面显示的是 [“tag_1”,”dev”,{“testArray”:”tag_0”}]，符合预期！那接下来我们就来看看这个方法的奥秘。 1234567891011121314Vue.prototype.$set = set;function set (target, key, val) &#123; // 省略 if (Array.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123; target.length = Math.max(target.length, key); target.splice(key, 1, val); return val &#125; // 省略 defineReactive(ob.value, key, val); ob.dep.notify(); return val&#125; 对于数组，就是执行 Array.splice() 方法修改了数组的值，也就是修改了 currentBranch 的值。由于 currentBranch 是 data 对象中的一个属性，拥有响应式属性，现在发生了改变，就会触发它的 set 方法，那么就会触发页面的重新渲染。而在这次渲染之前，master 变成了 tag_1，所以页面中 master 变成了 tag_1。其实不仅仅是 splice 方法可以实现，只要是能修改数组的方法就可以回避这个限制。这个回避策略也可以理解成将数组属性的变化转给数组的变化。 对于对象，就是在我们手动添加属性后，重新执行 Object.defineProperty 为该属性增加响应式属性，并执行 dep.notify() 重新收集依赖，然后就可以在后期检测到变化并且能通知订阅者更新。 最后总结起来，Vue 检测变化的限制实际上是这些变动的属性没有响应式属性。其中，数组属性是官方基于性能方面的考虑没有添加响应式属性，而对象是因为错过了添加响应是属性的时机。对应的解决办法就是：数组属性的变化转接给数组的变化、对象属性重新添加响应式属性并重新收集依赖。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"props 是如何传递的","slug":"源码阅读/vue2/props 是如何传递的","date":"2021-05-22T16:00:00.000Z","updated":"2021-08-31T03:36:02.917Z","comments":true,"path":"2021/05/23/源码阅读/vue2/props 是如何传递的/","link":"","permalink":"http://yoursite.com/2021/05/23/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/props%20%E6%98%AF%E5%A6%82%E4%BD%95%E4%BC%A0%E9%80%92%E7%9A%84/","excerpt":"","text":"前言props 是父组件向子组件传递数据的通道。在子组件中注册一些自定义 prop，当一个值作为 prop attribute 传递给这个 prop 之后，我们在子组件实例中访问这个值就像访问 data 中的值一样。这个设计非常有趣而且简单易用，但你有没有想过底层是如何实现的？我想过而且想知道设计细节，所以这篇就是来寻找答案的！ 按照惯例，还是以官方 dmeo（examples/commits） 为例，稍作改动如下，但需要注意的是在 html 中使用 prop ，传递时需要用短横线分隔命名。 12345678910111213141516171819202122// html&lt;div id=\"demo\"&gt; &lt;Child :parent-message=\"message\"&gt;&lt;/Child&gt;&lt;/div&gt;// jsVue.component(\"Child\", &#123; props: ['parentMessage'], template: '&lt;p&gt;parentMessage is ：&#123;&#123;parentMessage&#125;&#125;&lt;/p&gt;'&#125;)new Vue(&#123; el: '#demo', data: &#123; message: 'Hello', &#125;, mounted () &#123; setTimeout(() =&gt; &#123; this.message = 'cipher' &#125;, 1000) &#125;,&#125;) Vue.component 是什么我们使用 Vue.component() 注册一个组件，然后就可以使用这个组件。那这个方法是如何注册组件的呢？我们知道 vue 初始化程序时会执行 initGlobalAPI(Vue) 初始化全局 api 以供后期使用，其中就包括 initAssetRegisters(Vue)。 1234567891011121314151617181920212223242526272829303132333435var ASSET_TYPES = [ 'component', 'directive', 'filter'];function initAssetRegisters (Vue) &#123; /** * Create asset registration methods. */ ASSET_TYPES.forEach(function (type) &#123; Vue[type] = function ( id, definition ) &#123; if (!definition) &#123; return this.options[type + 's'][id] &#125; else &#123; /* istanbul ignore if */ if (type === 'component') &#123; validateComponentName(id); &#125; if (type === 'component' &amp;&amp; isPlainObject(definition)) &#123; definition.name = definition.name || id; definition = this.options._base.extend(definition); &#125; if (type === 'directive' &amp;&amp; typeof definition === 'function') &#123; definition = &#123; bind: definition, update: definition &#125;; &#125; this.options[type + 's'][id] = definition; return definition &#125; &#125;; &#125;);&#125; 简单来说，就是为 Vue 添加 ASSET_TYPES 类型的属性，属性值是一个方法。那也就是可以知道 Vue.component = function(id, definition) {}，并且它会返回 definition。由于我们调用的时候，满足条件二，所以会对 definition 进行处理：首先是添加 name = ‘Child’ 属性；因为 this.options._base = Vue，所以接着调用 Vue.extend 处理 definition，即： 123456789Vue.extend(&#123; props: ['parentMessage'], data: function () &#123; return &#123; childMessage: 'hi', &#125; &#125;, template: '&lt;p&gt;parentMessage is ：&#123;&#123;parentMessage&#125;&#125;&lt;/p&gt;'&#125;) 而 Vue.extend 处理如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253Vue.extend = function (extendOptions) &#123; extendOptions = extendOptions || &#123;&#125;; var Super = this; var SuperId = Super.cid; var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;); if (cachedCtors[SuperId]) &#123; return cachedCtors[SuperId] &#125; var name = extendOptions.name || Super.options.name; if (name) &#123; validateComponentName(name); &#125; var Sub = function VueComponent (options) &#123; this._init(options); &#125;; Sub.prototype = Object.create(Super.prototype); Sub.prototype.constructor = Sub; Sub.cid = cid++; Sub.options = mergeOptions( Super.options, extendOptions ); Sub['super'] = Super; if (Sub.options.props) &#123; initProps(Sub); &#125; if (Sub.options.computed) &#123; initComputed(Sub); &#125; Sub.extend = Super.extend; Sub.mixin = Super.mixin; Sub.use = Super.use; ASSET_TYPES.forEach(function (type) &#123; Sub[type] = Super[type]; &#125;); if (name) &#123; Sub.options.components[name] = Sub; &#125; Sub.superOptions = Super.options; Sub.extendOptions = extendOptions; Sub.sealedOptions = extend(&#123;&#125;, Sub.options); // cache constructor cachedCtors[SuperId] = Sub; return Sub&#125;; Super 就是 Vue，将 Sub.prototype 的原型指向 Super.prototype，并且还将 Vue 本身的属性赋值给 Sub，这样 Sub 就拥有了 Vue 的基本功能，而 Sub 内部执行的就是 Vue._init()，因此 Sub 就可以跟 Vue 一样进行创建组件了。 父组件传递属性，子组件接收属性这些初始化工作做好之后，就开始执行父组件的 new Vue() 流程，执行转译的三个步骤： parse、transform、generate。转译步骤可以查看 模板怎么变成真实DOM 。其中 transform 会将 AST 转换成如下 render 函数： 1234(function anonymous() &#123;with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('child',&#123;attrs:&#123;\"parent-message\":message&#125;&#125;)],1)&#125;&#125;) 子组件的 vnode 创建源于 _c(‘child’,{attrs:{“parent-message”:message}}), _c 内部会执行 _createElement 方法，由于符合创建 component 的条件，所以会走 createComponent 方法。 12345678910111213function _createElement (context, tag, data, children, normalizationType) &#123; // 省略 if (typeof tag === 'string') &#123; var Ctor; ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag); if (config.isReservedTag(tag)) &#123; // 省略 &#125; else if ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, 'components', tag))) &#123; // component vnode = createComponent(Ctor, data, context, children, tag); &#125; &#125;&#125; createComponent 参数解释如下： Ctor 就是上面说的 Sub，即 function VueComponent() {}, data: {attrs: parent-message: ‘Hello’}。说明一下，这里显示的是 message 的值 Hello，是因为在执行 _c 之前，触发 message get 属性就能拿到它的值 ‘Hello’ children: undefined tag: ‘child’。被转换成了小写 123456789101112131415161718192021222324252627282930313233343536// 省略createComponent(Ctor, data, context, children, tag) &#123; // baseCtor 就是 Vue 构造函数 var baseCtor = context.$options._base; var propsData = extractPropsFromVNodeData(data, Ctor, tag);&#125;// extractPropsFromVNodeDatavar propOptions = Ctor.options.props;var res = &#123;&#125;;var attrs = data.attrs;var props = data.props;if (isDef(attrs) || isDef(props)) &#123; for (var key in propOptions) &#123; var altKey = hyphenate(key); &#123; var keyInLowerCase = key.toLowerCase(); if ( key !== keyInLowerCase &amp;&amp; attrs &amp;&amp; hasOwn(attrs, keyInLowerCase) ) &#123; tip( \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" + (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" + \" \\\"\" + key + \"\\\". \" + \"Note that HTML attributes are case-insensitive and camelCased \" + \"props need to use their kebab-case equivalents when using in-DOM \" + \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\" ); &#125; &#125; checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false); &#125;&#125;return res extractPropsFromVNodeData 方法中会先获取到 Child 组件中的 props 赋值给 propOptions，即：{parentMessage: {type: null}}；data 中只存在 attrs = {parent-message: “Hello”}，props 是 undefined，但只要其中有一个存在就会去遍历 propOptions： altKey 就是通过正则将 parentMessage 转换为 “parent-message” keyInLowerCase 是将 parentMessage 转成小写的 “parentmessage” 最后执行 checkProp(res, attrs, key, altKey, false)。所做的事情就是执行 res[key] = attrs[altKey]，即：res[‘parentMessage’] = attrs[‘parent-message’] = ‘Hello’; 这里要讲一下 checkProp 123456789101112131415161718function checkProp (res, hash, key, altKey, preserve) &#123; if (isDef(hash)) &#123; if (hasOwn(hash, key)) &#123; res[key] = hash[key]; if (!preserve) &#123; delete hash[key]; &#125; return true &#125; else if (hasOwn(hash, altKey)) &#123; res[key] = hash[altKey]; if (!preserve) &#123; delete hash[altKey]; &#125; return true &#125; &#125; return false&#125; 如果 attrs 或者 props 没有值，那么就会直接返回 false；如果存在，就有可能出现两种情况： 第一种是使用 :parentMessage=”message” 这种形式绑定属性，那么就会匹配第一个分支，执行 res[‘parentMessage’] = attrs[‘parentMessage’];第二种就是 demo 的这种形式，执行 res[‘parentMessage’] = attrs[‘parent-message’]。 propsData 就是最后返回的 res。 获取完 propsData 之后，就要给子组件添加组件管理的钩子函数。 12345678910111213141516// 先将组件的事件提取出来，因为组件的事件不能按照 Dom 事件进行处理var listeners = data.on;// 将原生事件替换组件的事件，因为它可以按照 Dom 事件处理data.on = data.nativeOn;installComponentHooks(data);// installComponentHooksvar hooks = data.hook || (data.hook = &#123;&#125;);for (var i = 0; i &lt; hooksToMerge.length; i++) &#123; var key = hooksToMerge[i]; var existing = hooks[key]; var toMerge = componentVNodeHooks[key]; if (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123; hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge; &#125;&#125; 全局对象变量 componentVNodeHooks 拥有四个方法：init、prepatch、insert、destroy，hooksToMerge 就是 componentVNodeHooks key 的集合 [‘init’、’prepatch’、’insert’、’destroy’]。 满足以下条件就可以给 hooks 添加这同 key 方法： hooks[key] !== componentVNodeHooks[key] hooks[key] 不存在或者 hooks[key]._merged = false 另外如果 hooks[key] 存在，则赋值的是 merge 之后的方法。 最后就是创建 vnode。 123456var vnode = new VNode( (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')), data, undefined, undefined, undefined, context, &#123; Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children &#125;, asyncFactory); 在 extend(definition) 内部，将 Sub.cid 赋值为 cid++，因此 Ctor.cid = Sub.cid = 1 name = ‘Child’ data 拥有了 hook 钩子函数 propsData = {parentMessage: “Hello”} tag = ‘child’ Ctor = function VueComponent() {} 最后一个参整体作为 componentOptions 赋值给 vnode.componentOptions，这是 component 的一个特殊属性。 子组件和父组件 vnode 创建完成后，就开始进入 patch 阶段，创建 Dom，对每一个 vnode 调用 createElm。我们跳过父组件的创建，直接来看 createComponent(vnode, insertedVnodeQueue, parentElm, refElm) 创建 child 组件。parentElm 就是父组件的 dom。特别注意，这个 createComponent 是 createPatchFunction 内部的方法，与上面提到的不是同一个。 12345678910function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) &#123; var i = vnode.data; if (isDef(i)) &#123; var isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive; if (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123; i(vnode, false /* hydrating */); &#125; // 省略 &#125;&#125; 调用 hook.init 初始化 component。 1234567891011121314151617init: function init (vnode, hydrating) &#123; if ( vnode.componentInstance &amp;&amp; !vnode.componentInstance._isDestroyed &amp;&amp; vnode.data.keepAlivez ) &#123; // kept-alive components, treat as a patch var mountedNode = vnode; // work around flow componentVNodeHooks.prepatch(mountedNode, mountedNode); &#125; else &#123; var child = vnode.componentInstance = createComponentInstanceForVnode( vnode, activeInstance ); child.$mount(hydrating ? vnode.elm : undefined, hydrating); &#125;&#125;, 初始 componentInstance 是不存在的，所以会走第二分支调用 createComponentInstanceForVnode()，将返回的值赋值给 vnode.componentInstance 和变量 child，最后调用 child.$mount() 进行挂载。 其中 createComponentInstanceForVnode 接收的第二个参会作为该组件的 parent，activeInstance 是个全局变量，在 setActiveInstance 方法里会将它赋值为 vm。 12345678910111213function createComponentInstanceForVnode (vnode, parent) &#123; var options = &#123; _isComponent: true, _parentVnode: vnode, parent: parent &#125;; var inlineTemplate = vnode.data.inlineTemplate; if (isDef(inlineTemplate)) &#123; options.render = inlineTemplate.render; options.staticRenderFns = inlineTemplate.staticRenderFns; &#125; return new vnode.componentOptions.Ctor(options)&#125; _isComponent: true 标识它自己是 component; options._parentVnode 就是它自身的 vnode; vnode.componentOptions.Ctor 就是 VueComponent 构造函数，这里执行它，就是执行 _init 方法，创建一个组件实例，就像执行 new Vue() 一样，只是 options 不同而已。 在 initState 中会去执行 initProps(vm, opts.props) 处理 props： 123456789101112131415161718192021222324// propsOptions = opts.props = &#123;parentMessage: &#123;type: null&#125;&#125;function initProps (vm, propsOptions) &#123; // propsdata = &#123;parentMessage: 'Hello'&#125; var propsData = vm.$options.propsData || &#123;&#125;; var props = vm._props = &#123;&#125;; var loop = function (key) &#123; // value 即：'Hello' var value = validateProp(key, propsOptions, propsData, vm); &#123; defineReactive(props, key, value, function () &#123; if (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123; warn( \"Avoid mutating a prop directly since the value will be \" + \"overwritten whenever the parent component re-renders. \" + \"Instead, use a data or computed property based on the prop's \" + \"value. Prop being mutated: \\\"\" + key + \"\\\"\", vm ); &#125; &#125;); &#125; &#125;; for (var key in propsOptions) loop(key);&#125; 它所做的事有两点： 声明一个变量 props，将它与 vm._props 都指向 {}，如果 props 发生改变，vm._props 也会跟着改变 为 props.parentMessage 添加数据劫持并且赋值为 ‘Hello’。 通过断点调试，你会发现执行完这一步后，vm.prototype 添加上了 parentMessage 属性，值也是 ‘Hello’。这是为什么呢？在开始去寻找答案之前，我们可以猜测是 vm._props 与 vm.prototype 自身做了某种联系才会有这样的同步效果。因为 vm 的构造函数是 VueComponent，我们找到最上面的 extend 方法，里面有一个这样的处理： 123if (Sub.options.props) &#123; initProps(Sub);&#125; Sub.options.props = {parentMessage: {type: null}} 进入 initProps(Sub) 处理流程： 12345678910111213141516function initProps (Comp) &#123; var props = Comp.options.props; for (var key in props) &#123; proxy(Comp.prototype, \"_props\", key); &#125;&#125;function proxy (target, sourceKey, key) &#123; sharedPropertyDefinition.get = function proxyGetter () &#123; return this[sourceKey][key] &#125;; sharedPropertyDefinition.set = function proxySetter (val) &#123; this[sourceKey][key] = val; &#125;; Object.defineProperty(target, key, sharedPropertyDefinition);&#125; 由上可知，proxy 的作用就是为 target[key] 添加响应式属性 get/set。这里就是为 VueComponent.prototype[parentMessage] 添加属性，get 方法获取的是 vm._props.parentMessage。这里相当于使用 props 需要通过两层代理： 第一层：vm.prototype.parentMessage ——&gt; vm.prototype.parentMessage.get() ——&gt; return vm._props.parentMessage第二层：vm._props.parentMessage ——&gt; vm._props.parentMessage.get() ——&gt; return ‘Hello’ 串起来就是 vm.prototype.parentMessage ——&gt; vm._props.parentMessage。 最后的渲染组件实例创建完成后，调用 child.$mount() 开始进行 child 组件的 parse、transform、patch 处理过程。其中生成的 render 函数如下所示： 1234(function anonymous() &#123;with(this)&#123;return _c('p',[_v(\"parentMessage is ï¼š\"+_s(parentMessage))])&#125;&#125;) 当使用 parentMessage 这个属性时，会触发 vm.prototype.parentMessage 的 get 方法，拿到 ‘Hello’，那么 ‘Hello’ 就可以被渲染到页面中了。也就实现了 parentMessage 从父组件传递，到子组件接收，再到子组件渲染的这样一个过程。用一张图来表示一下整个流程： 为什么 props 的值会跟着父组件改变message 会在1秒之后变成 cipher，而 parentMessage is：Hello 也会显示为 parentMessage is：cipher，为什么 props 的值会跟着父组件改变？ 在 computed的[怪异]表现 中已经讲过，message 的改变会触发父组件的重新渲染，那么就会将我们上面说到的流程重新走一遍，而这次传进来的 message 是 cipher，所以也就会显示 cipher。 子组件如何更改 prop在 initProps 中为 prop 绑定数据劫持时，会传入一个 customSetter 方法，当我们试图改变 props 时，就会执行这个方法，提示不能在直接在子组件更改属性，需要父组件去更改，然后子组件来更新。官方给出的方案是 .sync 修饰符。我们将 demo 改成如下所示： 12345678910// html&lt;Child :parent-message.sync=\"message\"&gt;&lt;/Child&gt;// js// 将 parentMessage 的更改挪到 child 中mounted () &#123; setTimeout(() =&gt; &#123; this.$emit('update:parentMessage', 'change in child') &#125;, 1000)&#125;, 这样修改之后，1秒之后，页面就从 parentMessage is：Hello 显示为 parentMessage is：change in child。实现了在子组件去更改父组件的 prop。 想知道原因，我们就得从源头下手，那就是父组件的 parse 阶段，在这个阶段会将 template 转换成 AST，会发现 child 的 AST.attrsList 属性如下： 12345678attrsList = [ &#123; end: 57 name: \":parent-message.sync\" start: 27 value: \"message\" &#125;] 依然像普通属性一样存储。在 模板怎么变成真实DOM 中，我们讲过对字符串是按照标签来拆解解析，遇到闭合标签会调用 parseEndTag 处理，而该方法内部则会调用 closeElement 去执行结束标签解析动作，而 closeElement 又会调用 processElement 去处理还没有处理过且不存在 pre 属性的 element，处理 element 包括处理 attrs，方法是 processAttrs。 重点来看 processAttrs 方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788function processAttrs (el) &#123; // 获取 attrsList var list = el.attrsList; var i, l, name, rawName, value, modifiers, syncGen, isDynamic; for (i = 0, l = list.length; i &lt; l; i++) &#123; // 获取到 attr 的名称和值 name = rawName = list[i].name; value = list[i].value; // 符合 attr 名字规则继续往下执行 if (dirRE.test(name)) &#123; // mark element as dynamic el.hasBindings = true; // 这一步就是将 :parent-message.sync 进行处理，只将 sync: true 存入对象中 modifiers = parseModifiers(name.replace(dirRE, '')); // support .foo shorthand syntax for the .prop modifier if (modifiers) &#123; // 到这里 name 为 :parent-message name = name.replace(modifierRE, ''); &#125; // 接下来会分成三类来处理，分别是 v-bind、v-on 和 自定义 directives // 这里省略后两种，只保留 v-bind // 因为 :parent-message 是 v-bind:parent-message 的缩写形式，所以会进入下层逻辑 if (bindRE.test(name)) &#123; // v-bind // name 为 parent-message name = name.replace(bindRE, ''); // value 为 message value = parseFilters(value); // 这里判断 name 是否是动态的，很显然我们这里不是动态的 isDynamic = dynamicArgRE.test(name); if (isDynamic) &#123; name = name.slice(1, -1); &#125; if ( value.trim().length === 0 ) &#123; warn$2( (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\") ); &#125; if (modifiers) &#123; if (modifiers.prop &amp;&amp; !isDynamic) &#123; name = camelize(name); if (name === 'innerHtml') &#123; name = 'innerHTML'; &#125; &#125; if (modifiers.camel &amp;&amp; !isDynamic) &#123; name = camelize(name); &#125; // 上面的直接跳过，来到这里，sync 是存在的 if (modifiers.sync) &#123; syncGen = genAssignmentCode(value, \"$event\"); if (!isDynamic) &#123; // 为 update:parentMessage 添加事件 addHandler( el, (\"update:\" + (camelize(name))), syncGen, null, false, warn$2, list[i] ); // 为 update:parent-message 添加事件 if (hyphenate(name) !== camelize(name)) &#123; addHandler( el, (\"update:\" + (hyphenate(name))), syncGen, null, false, warn$2, list[i] ); &#125; &#125; &#125; &#125; if ((modifiers &amp;&amp; modifiers.prop) || ( !el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name) )) &#123; addProp(el, name, value, list[i], isDynamic); &#125; else &#123; addAttr(el, name, value, list[i], isDynamic); &#125; &#125; &#125; &#125;&#125; 常规处理可以看代码里的注释，这里只重点说下进入 modifiers 逻辑内的两个处理： syncGen = genAssignmentCode(value, “$event”) addHandler 先来看 genAssignmentCode 1234567891011function genAssignmentCode ( value, assignment) &#123; var res = parseModel(value); if (res.key === null) &#123; return (value + \"=\" + assignment) &#125; else &#123; return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\") &#125;&#125; parseModel 返回一个对象 {exp: “message”, key: null}。因此这里会走第一分支返回字符串：”message=$event”。 然后就是调用 addHandler 方法：addHandler(el, “update:parentMessage”, “message=$event”, null, false, warn, list[i]) 123456789101112131415161718function addHandler (el, name, value, modifiers, important, warn, range, dynamic) &#123; modifiers = modifiers || emptyObject; var events = el.events || (el.events = &#123;&#125;); // 省略 var newHandler = rangeSetItem(&#123; value: value.trim(), dynamic: dynamic &#125;, range); if (modifiers !== emptyObject) &#123; newHandler.modifiers = modifiers; &#125; var handlers = events[name]; if (Array.isArray(handlers)) &#123; important ? handlers.unshift(newHandler) : handlers.push(newHandler); &#125; else if (handlers) &#123; events[name] = important ? [newHandler, handlers] : [handlers, newHandler]; &#125; else &#123; events[name] = newHandler; &#125;&#125; 通过 rangeSetItem 创建一个事件处理方法，赋值给 el.events[‘update:parentMessage’]。rangeSetItem 内部做了些什么处理呢？ 1234567891011function rangeSetItem (item, range) &#123; if (range) &#123; if (range.start != null) &#123; item.start = range.start; &#125; if (range.end != null) &#123; item.end = range.end; &#125; &#125; return item&#125; 传入的 item 是对象 { value: “message=$event”, dynamic: null }，rangeSetItem 是给这个对象添加 start 和 end 属性，然后返回 item。 也就是说为 el 添加了一个可以监听的事件 “update:parentMessage”。 el.events[‘update:parentMessage’] 的值如下所示 123456&#123; dynamic: undefined end: 57 start: 27 value: \"message=$event\"&#125; processAttrs 执行完之后，依据条件，会继续执行 addAttr(el, name, value, list[i], isDynamic) 向 el.attrs push 进一个对象，即下面这个： 1234567&#123; dynamic: false end: 57 name: \"parent-message\" start: 27 value: \"message\"&#125; 这些都处理完之后，相当于准备工作都完成了，那么按照上方的执行流程图，AST 创建完成后，会生成 render 函数，如下所示： 1234(function anonymous() &#123;with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('child',&#123;attrs:&#123;\"parent-message\":message&#125;,on:&#123;\"update:parentMessage\":function($event)&#123;message=$event&#125;,\"update:parent-message\":function($event)&#123;message=$event&#125;&#125;&#125;)],1)&#125;&#125;) 可以看到这一次子组件添加了 on 事件对象，那么在 createComponent 内部就会将 on 事件对象赋值给 listeners，然后存入 componentOptions，最后 componentOptions 会被传入 new Vnode() 中创建 vnode。 现在 vnode 创建成功，就可以开始进入 patch 阶段创建 Dom 了。而创建 Dom 就会会执行 child._init() 方法。_init 方法内部执行的 initInternalComponent 方法有这样一段处理： 123var opts = vm.$options = Object.create(vm.constructor.options);var vnodeComponentOptions = parentVnode.componentOptions;opts._parentListeners = vnodeComponentOptions.listeners; 转换过来就是这样：vm.$options._parentListeners = parentVnode.componentOptions.listeners。 在 _init 内部会继续执行 initEvents(vm)，也就是会执行 updateComponentListeners(vm, listeners)。 12345678910111213141516171819202122232425262728293031323334353637383940414243function initEvents (vm) &#123; vm._events = Object.create(null); vm._hasHookEvent = false; // init parent attached events var listeners = vm.$options._parentListeners; if (listeners) &#123; updateComponentListeners(vm, listeners); &#125;&#125;function updateComponentListeners (vm, listeners, oldListeners) &#123; target = vm; // add 是一个方法 updateListeners(listeners, oldListeners || &#123;&#125;, add, remove, createOnceHandler, vm); target = undefined;&#125;// 继续执行 updateListenersfunction updateListeners (on, oldOn, add, remove, createOnceHandler, vm) &#123; var name, def, cur, old, event; for (name in on) &#123; def = cur = on[name]; old = oldOn[name]; event = normalizeEvent(name); if (isUndef(cur)) &#123; warn( \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur), vm ); &#125; else if (isUndef(old)) &#123; if (isUndef(cur.fns)) &#123; cur = on[name] = createFnInvoker(cur, vm); &#125; if (isTrue(event.once)) &#123; cur = on[name] = createOnceHandler(event.name, cur, event.capture); &#125; add(event.name, cur, event.capture, event.passive, event.params); &#125; else if (cur !== old) &#123; old.fns = cur; on[name] = old; &#125; &#125;&#125; updateListeners 做的事情就是遍历 listeners 对象，获取到每一个事件的事件名和执行的方法，执行 add(event.name, cur, event.capture, event.passive, event.params)。 123function add (event, fn) &#123; target.$on(event, fn);&#125; 而 add 方法就是调用 $on 去注册方法，所以我们就可以使用 $emit 去触发这个事件。 讲完了整个流程之后，需要再补充一个问题：message 改变之后触发的更新，render 函数中如何添加上 on 事件对象？ 在 模板怎么变成真实DOM 中，我们讲 genElement 步骤时提到过，如果是 component，会走 genComponent 生成 component render 字符串： 1return (\"_c(\" + componentName + \",\" + (genData(el, state)) + (children ? (\",\" + children) : '') + \")\") getData 就是获取各种属性信息包括 attrs 等。简化之后如下 12345678// attributesif (el.attrs) &#123; data += \"attrs:\" + (genProps(el.attrs)) + \",\";&#125;// event handlersif (el.events) &#123; data += (genHandlers(el.events, false)) + \",\";&#125; 因为我们在前面为 el.event 添加了事件对象，因此就可以通过 genHandlers(el.events, false) 去添加 on 事件对象 1234567891011121314151617var prefix = isNative ? 'nativeOn:' : 'on:';var staticHandlers = \"\";var dynamicHandlers = \"\";for (var name in events) &#123; var handlerCode = genHandler(events[name]); if (events[name] &amp;&amp; events[name].dynamic) &#123; dynamicHandlers += name + \",\" + handlerCode + \",\"; &#125; else &#123; staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\"; &#125;&#125;staticHandlers = \"&#123;\" + (staticHandlers.slice(0, -1)) + \"&#125;\";if (dynamicHandlers) &#123; return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"&#125; else &#123; return prefix + staticHandlers&#125; prefix 是判断是否是原生事件，这里就是 on。遍历 events 对象，拿到每个事件的执行方法，因为事件名是静态的，所以会走第二分支，最后执行 return “on:{“update:parentMessage”:function($event){message=$event},”update:parent-message”:function($event){message=$event}}” 这样就为子组件的 render 字符串加上了 on 属性。 最后本文依据父组件传递、子组件接收、子组件渲染这样一个流程讲解了 props 渲染过程。也解析了通过特定的语法，可以在子组件内触发父组件属性的更新，进而更新 prop 的原理。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"computed 的[怪异]表现","slug":"源码阅读/vue2/computed 的[怪异]表现","date":"2021-05-11T16:00:00.000Z","updated":"2021-08-25T03:24:11.032Z","comments":true,"path":"2021/05/12/源码阅读/vue2/computed 的[怪异]表现/","link":"","permalink":"http://yoursite.com/2021/05/12/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/computed%20%E7%9A%84[%E6%80%AA%E5%BC%82]%E8%A1%A8%E7%8E%B0/","excerpt":"","text":"前言官方文档中说明了 computed 存在的理由，有两条，一是如果插值表达式中的逻辑比较复杂，则可以使用 computed 代替；二是用来封装复杂计算，因为 computed 拥有缓存功能，只有响应式依赖项发生了改变， computed 的值才会改变。个人觉得第一条使用方法也可以代替，主要原因还是第二条，作用很大。但是不知道大家在使用 computed 属性的时候有没有如下疑问： computed 其实是一个方法，为什么可以像普通值一样使用，不需要带 () 进行调用 依赖项的改变如何促使 computed 改变 为什么 computed 拥有缓存功能 如果没有在模板中使用，即使依赖项发生改变，computed 也不会重新求值 如果依赖项不是响应式的，为什么不会重新求值 刚开始使用的时候，就非常不理解这些不寻常的表现，于是想着通过阅读源码去弄懂这一切，特此记录一下。本文会以官方 demo 为例， Vue 如何处理 computedcomputed 为什么可以像普通值一样使用123456789101112&lt;div id=\"demo\"&gt; &lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;/div&gt;data: &#123; message: 'Hello'&#125;,computed: &#123; reversedMessage: function () &#123; return this.message.split('').reverse().join('') &#125;&#125; 从源码中找到 initState，它是合并完 options 之后执行的方法，里面会调用 initComputed(vm, opts.computed) 处理 computed，opts 就是合并完成的 options。 12345678910function initComputed (vm, computed) &#123; for (var key in computed) &#123; var userDef = computed[key]; var getter = typeof userDef === 'function' ? userDef : userDef.get; // 省略 if (!(key in vm)) &#123; defineComputed(vm, key, userDef); &#125; &#125;&#125; 遍历 computed 对象，获取到 key 对应的方法，如果是浏览器端，就创建一个 watcher。然后判断 vm 是否已经存在该 key 的属性，如果没有就去定义这个 computed 属性。 1234567891011function defineComputed (target, key, userDef) &#123; var shouldCache = !isServerRendering(); if (typeof userDef === 'function') &#123; sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : createGetterInvoker(userDef); sharedPropertyDefinition.set = noop; &#125; // 省略 Object.defineProperty(target, key, sharedPropertyDefinition);&#125; sharedPropertyDefinition 拥有 get 和 set 方法，set 是 noop，可以忽视，get 分为两种情况：如果不是服务端渲染，那么就是使用 createComputedGetter(‘reversedMessage’) 创建，否则就是 createGetterInvoker(userDef) 创建。最后使用 Object.defineProperty 将 reversedMessage 这个属性添加到 vm 中。准备工作已经做好了，因为 computed 是放在模板中的，那么肯定会经过 render 函数去处理，下面就是 render 函数。 1234(function anonymous() &#123;with(this)&#123;return _c('div',&#123;attrs:&#123;\"id\":\"demo\"&#125;&#125;,[_c('p',[_v(\"Computed reversed message: \\\"\"+_s(\"olleH\")+\"\\\"\")])])&#125;&#125;) 可以看到 被转换成了 _s(reversedMessage)，当 _s(reversedMessage) 执行的时候，相当于执行 _s(this.reversedMessage)，此时 this.reversedMessage 就会触发前面绑定的 get 方法，也就是 computedGetter。 123456789101112return function computedGetter () &#123; var watcher = this._computedWatchers &amp;&amp; this._computedWatchers[key]; if (watcher) &#123; if (watcher.dirty) &#123; watcher.evaluate(); &#125; if (Dep.target) &#123; watcher.depend(); &#125; return watcher.value &#125;&#125; 因为是浏览器端，所以在 initComputed 内部声明过 watcher，即： 123456789var computedWatcherOptions = &#123; lazy: true &#125;;if (!isSSR) &#123; watchers[key] = new Watcher( vm, getter || noop, noop, computedWatcherOptions );&#125; 并且 watcher options 的 lazy 设置为 true，在 Watcher 构造函数内会将 dirty 设置成这样: this.dirty = this.lazy，因此 this.dirty = true。也就会执行 watcher.evaluate()。watcher.evaluate 方法又会涉及到 watcher.get 方法，因此同时展示如下： 1234567891011121314151617181920212223242526Watcher.prototype.evaluate = function evaluate () &#123; this.value = this.get(); this.dirty = false;&#125;;Watcher.prototype.get = function get () &#123; pushTarget(this); var value; var vm = this.vm; try &#123; value = this.getter.call(vm, vm); &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\")); &#125; else &#123; throw e &#125; &#125; finally &#123; if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value&#125;; 首先调用 watcehr.get()，会触发 this.getter.call(vm, vm)，即调用 reversedMessage 方法，将 watcher.value 赋值为 ‘olleH’; 最后返回 watcher.value 即 ‘olleH’。那么 render 函数的这部分 [_v(“Computed reversed message: &quot;“+_s(reversedMessage)+”&quot;“)]，就变成了 [_v(“Computed reversed message: &quot;“+_s(“olleH”)+”&quot;“)]。这样就实现了 computed 不带()进行使用了，其实是在内部去调用 reversedMessage 方法。这个实现有两个关键点： 将 computed.reversedMessage 代理给了 vm.rereversedMessage 使用 object.defineProperty 对 vm.rereversedMessage 进行数据劫持 computed 如何响应式改变在 demo 中 mounted 钩子中加上下面这段代码 123setTimeout(() =&gt; &#123; this.message = 'cipher'&#125;, 1000) 然后可以看到，在一秒后改变 message 的值，页面显示从 Computed reversed message: “olleH” 变成了 Computed reversed message: “rehpic”，符合预期，响应式依赖项改变时，computed 也发生了改变。我们来看看这是怎么实现的。 message 作为一个响应式属性，在最开始进行响应式设定的时候，它拥有一个 get 方法： 1234567891011121314151617181920var dep = new Dep();get: function reactiveGetter () &#123; // 获取 message 当前值 var value = getter ? getter.call(obj) : val; // 如果收集者存在当前目标 if (Dep.target) &#123; // 将 Dep.target 存入 dep.subs 中 dep.depend(); // 如果 observe 返回的值需要响应式处理 if (childOb) &#123; // // 将 Dep.target 存入 childOb.dep.subs 中 childOb.dep.depend(); // 处理数组情况 if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value&#125;, 上面已经说过，reversedMessage 渲染时会在内部调用 reversedMessage 方法去获取最新的值，而这个值就是 this.message.split(‘’).reverse().join(‘’) 返回的，此时就会触发 message 的 get 方法，即上面那段代码。reversedMessage get 方法触发的时候，会执行 pushTarget(this) 将 Dep.target 设置成 this._computedWatchers[‘reversedMessage’]，那么当执行 dep.depend() 时，最后就会执行 dep.addSub(watcher) 将 watcher 存入 dep.subs 数组中，这个 dep 是 message 的监听收集器，也就是说 message 改变会通知到 reversedMessage watcher。 综合上面说的步骤，总结一下方法执行图： 执行完 watcher.evaluate，reversedMessage watcher 就被收集到 message 的订阅者集合中了。 1秒之后，this.message 变成 cipher，那么就会去执行 message.set。 123456789101112131415161718192021222324252627set: function reactiveSetter (newVal) &#123; // 省略 dep.notify();&#125;Dep.prototype.notify = function notify () &#123; // subs 中拥有 reversedMessage var subs = this.subs.slice(); // 如果不是异步的，那么就要将 watcher 按照初始化的顺序进行排序。 if (!config.async) &#123; subs.sort(function (a, b) &#123; return a.id - b.id; &#125;); &#125; // 遍历订阅者，执行订阅者的更新操作 for (var i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); &#125;&#125;;Watcher.prototype.update = function update () &#123; if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; queueWatcher(this); &#125;&#125; 执行到 update 内部时你会发现，在最开始将 lazy 设置成了 true，那么这里并不会进入第二分支去执行 watcher.run，也就是说并不会更新 reversedMessage。那问题来了，reversedMessage是怎么更改的呢？在继续讲解之前，我们需要了解的一点是，每个组件实例都对应一个 watcher 实例，在程序初始化是会在 mountComponent 中为 vm 声明一个 watcher，存在全局的 targetStack 中进行维护。 12345678910111213function mountComponent(vm, el, hydrating) &#123; updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; new Watcher(vm, updateComponent, noop, &#123; before: function before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate'); &#125; &#125; &#125;, true /* isRenderWatcher */);&#125; 了解了这个后，再回到上面的 computedGetter，在 watcher.evaluate 执行完之后，紧接着执行下面这一段： 123if (Dep.target) &#123; watcher.depend();&#125; 需要注意 watcher.depend 和 dep.depend 执行的逻辑是不同的，前者是将 deps 集合中依次执行 depend，而 dep.depend 是执行单个。此时的 Dep.target 就是 vm watcher。 至于为什么 Dep.target 是 vm watcher，这里可以简单说下：vm watcher 存入之后，targetStack = [vm]。pushTarget(this) 会将 reversedMessage watcher 也存入 targetStaack 中，即 targetStack = [vm, reversedMessage]。get 方法最后会执行 popTarget()，它就是将栈中最后一个弹出，并把 Dep.target 指定给栈中剩下 watcher 的最后一个，也就是 vm，所以 watcher.evaluate() 执行完之后，Dep.target 就是 vm watcher。 123456Watcher.prototype.depend = function depend () &#123; var i = this.deps.length; while (i--) &#123; this.deps[i].depend(); &#125;&#125;; reversedMessage.deps 里存放的就是收集它自身的 dep，也就是 message 的监听收集器。 12345Dep.prototype.depend = function depend () &#123; if (Dep.target) &#123; Dep.target.addDep(this); &#125;&#125;; 也就是会将 vm 存入 message 的 dep.subs 中，此时，dep.subs = [reversedMessage, vm]。到这里初始化操作结束了，页面显示为 Computed reversed message: “olleH”。 1秒之后进行 message 的更改操作，重新执行 notify 方法，而 reversedMessage update 依旧不会去执行更新 reversedMessage。。。这仿佛又走的老路子而且还是走不通的。其实不然，因为这次跟上次不同了，这次 dep.subs 中新增了一个 vm 的 watcher，所以执行完 reversedMessage 的 update，接着会执行 vm 的 update 方法。 因为 vm.lazy 和 vm.sync 都是 false，所以会走第三分支，执行 queueWatcher(this) 1234567891011121314151617181920212223242526272829303132var queue = [];var waiting = false;var has = &#123;&#125;;var flushing = false;function queueWatcher (watcher) &#123; var id = watcher.id; if (has[id] == null) &#123; has[id] = true; if (!flushing) &#123; queue.push(watcher); &#125; else &#123; // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. var i = queue.length - 1; while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i--; &#125; queue.splice(i + 1, 0, watcher); &#125; // queue the flush if (!waiting) &#123; waiting = true; if (!config.async) &#123; flushSchedulerQueue(); return &#125; nextTick(flushSchedulerQueue); &#125; &#125;&#125; flush 默认为 false，将 vm 添加到 queue 中，执行 nextTick(flushSchedulerQueue)，先来看看 nextTick 方法： 1234567891011121314151617181920var pending = false;var callbacks = [];function nextTick (cb, ctx) &#123; var _resolve; callbacks.push(function () &#123; if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, 'nextTick'); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125;&#125; 将 flushSchedulerQueue 包装在方法内，存入 callbacks 中，然后去执行 timerFunc()，timerFunc 有如下几种情况： 12345678910111213141516171819202122232425262728293031if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) &#123; var p = Promise.resolve(); timerFunc = function () &#123; p.then(flushCallbacks); if (isIOS) &#123; setTimeout(noop); &#125; &#125;; isUsingMicroTask = true;&#125; else if (!isIE &amp;&amp; typeof MutationObserver !== 'undefined' &amp;&amp; ( isNative(MutationObserver) || MutationObserver.toString() === '[object MutationObserverConstructor]')) &#123; var counter = 1; var observer = new MutationObserver(flushCallbacks); var textNode = document.createTextNode(String(counter)); observer.observe(textNode, &#123; characterData: true &#125;); timerFunc = function () &#123; counter = (counter + 1) % 2; textNode.data = String(counter); &#125;; isUsingMicroTask = true;&#125; else if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) &#123; timerFunc = function () &#123; setImmediate(flushCallbacks); &#125;;&#125; else &#123; timerFunc = function () &#123; setTimeout(flushCallbacks, 0); &#125;;&#125; 就是将 flushCallbacks 作为各种方法的回调函数，而官方的意思是考虑到各平台的差异以及会造成的 bug，按照优先级来说，微任务 &gt; 宏任务，优先使用 promise，最差情况使用 setTimeout。概括来说，就是在数据发生变动时，将所涉及到的 watcher 存入 queue 中，然后使用 nextTick 方法可以让这些 watcher 的更新在下一个时间循环中执行。另外 $nextTick 内部就是执行的 nextTick 方法，因此我们可以使用 $nextTick 在下一个循环中执行方法。 12345678function flushCallbacks () &#123; pending = false; var copies = callbacks.slice(0); callbacks.length = 0; for (var i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125;&#125; flushCallbacks 依次执行 callbacks 集合里的方法，当它执行时就会执行 flushSchedulerQueue 方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445function flushSchedulerQueue () &#123; currentFlushTimestamp = getNow(); flushing = true; var watcher, id; queue.sort(function (a, b) &#123; return a.id - b.id; &#125;); for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; if (watcher.before) &#123; watcher.before(); &#125; id = watcher.id; has[id] = null; watcher.run(); // in dev build, check and stop circular updates. if (has[id] != null) &#123; circular[id] = (circular[id] || 0) + 1; if (circular[id] &gt; MAX_UPDATE_COUNT) &#123; warn( 'You may have an infinite update loop ' + ( watcher.user ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\") : \"in a component render function.\" ), watcher.vm ); break &#125; &#125; &#125; var activatedQueue = activatedChildren.slice(); var updatedQueue = queue.slice(); resetSchedulerState(); callActivatedHooks(activatedQueue); callUpdatedHooks(updatedQueue); if (devtools &amp;&amp; config.devtools) &#123; devtools.emit('flush'); &#125;&#125; ​简单说下流程： 首先要对 queue 里的 watcher 进行排序。原因有三点： 父组件必须要优先与子组件更新（父组件比子组件先创建） watcher 分为 user watcher 和 render watcher，user watcher 必须优先与 render watcher（user watcher 比 render watcher 先创建） 排序后，如果子组件在父组件 watcher 执行过程中被销毁了，就会跳过子组件的 watcher 执行。 遍历 queue，如果 watcher.before 存在，优先执行，比如说 beforeUpdate 钩子函数就是在 vm render watcher.before 中执行的；然后执行 watcher.run() 执行 activated 和 updated 钩子。 开发模式下触发 devtools flush 事件 来看看 watcher.run： 1234567891011121314151617181920Watcher.prototype.run = function run () &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || isObject(value) || this.deep ) &#123; // set new value var oldValue = this.value; this.value = value; if (this.user) &#123; var info = \"callback for watcher \\\"\" + (this.expression) + \"\\\"\"; invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info); &#125; else &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125;&#125;; 首先执行 this.get()，触发 this.getter 方法执行，vm.getter 就是 updateComponent，也就是说会重新走 render -&gt; update 过程。而就是在 render 过程里，会重新执行 this.reversedMessage() 更新 reversedMessage 的值。 到这里，将 computed 所涉及到的方法调用整理成一张流程图，如下： 为什么 computed 拥有缓存功能这个问题其实跟 “如果依赖项不是响应式的，即使改变，computed 为什么也不会重新求值” 这个是一样的。 我在 demo 中增加一个使用 reversedMessage 的代码 12&lt;p&gt;Computed reversed message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt;&lt;p&gt;multiple message: \"&#123;&#123; reversedMessage &#125;&#125;\"&lt;/p&gt; 1234Watcher.prototype.evaluate = function evaluate () &#123; this.value = this.get(); this.dirty = false;&#125;; 在 computedGetter 中，只有 this.dirty = true，才会去执行 watcher.evaluate()，也就是去计算 reversedMessage 的值。当第一次使用 reversedMessage 时，当前的 dirty = true，去计算拿到值赋值给 watcher.value，计算完成之后将 dirty 置为 false；第二次使用时就不会去执行 evaluate，拿到的就是第一次计算的值。这样就实现了缓存的功能。 如果没有在模板中使用，即使依赖项发生改变，computed 也不会再次执行修改 demo 如下： 123456789101112mounted () &#123; this.reversedMessage; setTimeout(() =&gt; &#123; this.message = 'cipher' &#125;, 1000)&#125;,computed:&#123; reversedMessage: function () &#123; console.log('改变 reversedMessage 的值'); return this.message.split('').reverse().join('') &#125;&#125; 这一次在 mounted 钩子中不带() 使用，会触发 reversedMessage 方法执行，但是1秒之后 message 更改了，但是 reversedMessage 却没有执行。 我们看上面 computed 执行流程图，_render() 执行会触发 _s(this.reverseMessage)，进而触发计算，调用方法，但是现在我没有在模板中使用，那么在 render 函数中就不会有 _s(this.reverseMessage)，也就不会有后续的计算操作了，因此 computed 方法不会执行。但是为什么在 mounted 中使用 this.reversedMessage() 会报错，而使用 this.reversedMessage 却可以正常使用？ this.reversedMessage 触发 reversedMessage 的 getter，跟上面提到的执行步骤是一样的，所以会执行 reversedMessage 方法。也就是说 this.reversedMessage() 相当于是 this.reversedMessage()()，this.reversedMessage() 执行完后的值不是方法，所以后面接 () 使用就会报错。 最后computed 的怪异表现其实来自于与 method 的相似性。形式上是 method，但是使用上是 data。 底层上为 computed 添加数据劫持，然后将 computed 代理给了 vm，在当做 data 一样使用时就可以触发 get 去执行这个 computed。 如果不在模板中使用，那么响应式依赖项就算改变了也不会重新求值，是因为重新求值依靠的是页面渲染时触发 computed。 缓存功能其实依赖于 computed 对应 watcher 的 dirty 属性。它的 dirty 默认为 true，只有为 true 才能求值。在进行一次求值后会将 dirty 改为 false，那么下次执行到这里时不会重新求值，而是直接拿上次的值。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"模板怎么变成真实 DOM","slug":"源码阅读/vue2/模板怎么变成真实 DOM","date":"2021-05-01T16:00:00.000Z","updated":"2021-08-31T02:17:10.257Z","comments":true,"path":"2021/05/02/源码阅读/vue2/模板怎么变成真实 DOM/","link":"","permalink":"http://yoursite.com/2021/05/02/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%A8%A1%E6%9D%BF%E6%80%8E%E4%B9%88%E5%8F%98%E6%88%90%E7%9C%9F%E5%AE%9E%20DOM/","excerpt":"","text":"前言官方文档有过这样一段描述： Vue.js 的核心是一个允许采用简洁的模板语法来声明式地将数据渲染进 DOM 的系统 其实 Vue 模板语法与 ejs 等模板语言类似，基本思想就是： template + data = dom。那 Vue 是如何来将模板语法结合数据转译成真实 Dom 呢？本章将会来探究这个秘密。 了解过编译和转译的应该知道，它们大致都会经历 parse、transform、generate 三个步骤。不同的是，编译通常来说是高级语言向低级语言的变换，而转译则只是语法层面的转换，Vue 的模板向 DOM 的变化就是转译。除了上述三个步骤之外，最后 DOM 的生成还需要 patch 操作。 开始之前，有必要梳理一下转译过程涉及到的一些重要方法（如下所示）调用及它们之间的关系，做到心中有数，将关注点放在转译步骤上。 12345678910111213141516171819202122232425262728293031323334Vue.prototype.$mount = function ()&#123;&#125;function parse(template, options) &#123;&#125;;function generate (ast,options) &#123;&#125;function createCompilerCreator(baseCompile) &#123; return function createCompiler (baseOptions) &#123; function compile(template, options) &#123; var compiled = baseCompile(template.trim(), finalOptions); return compiled &#125;; return &#123; compile: compile, compileToFunctions: createCompileToFunctionFn(compile) &#125; &#125;&#125;;function createCompileToFunctionFn (compile) &#123; return function compileToFunctions (template, options, vm) &#123; var compiled = compile(template, options); res.render = createFunction(compiled.render, fnGenErrors); return res; &#125; &#125;function baseCompile(template, options) &#123; var ast = parse(template.trim(), options); return &#123; ast: ast, render: code.render, staticRenderFns: code.staticRenderFns &#125;&#125;; 大致的执行顺序及关系是： var createCompiler = createCompilerCreator(baseCompile) var ref$1 = createCompiler(baseOptions); var compileToFunctions = ref$1.compileToFunctions $mount(); var ref = compileToFunctions(template, options) var compiled = compile(template, options) compiled = baseCompile(template.trim(), finalOptions) compiled.ast = parse(template.trim(), options) compiled.render = generate(ast, options).render ref.render = createFunction(compiled.render, fnGenErrors) Vue.$options.render = ref.render mount.call(this, el, hydrating) 转译步骤parse这一步将 template 作为字符串进行特定规则分析转换成 AST。 从上面的梳理结果可以看到，真正的 parse 动作从 parse(template.trim(), options) 开始，所以我们从这里开始。 1234567891011121314function parse(template, options) &#123; // 省略代码... var stack = []; var preserveWhitespace = options.preserveWhitespace !== false; var whitespaceOption = options.whitespace; // root 就是最后的 AST 结果 var root; var currentParent; var inVPre = false; var inPre = false; var warned = false; // 省略代码... parseHTML(template, &#123;&#125;)&#125;; 核心是 parseHTML 方法，简单来说就是通过 while 循环，依据标签作为分隔标识将 template 分隔成多个子字符串进行处理。 因为 template 也是标签，所以选择标签为单位进行对应的 parse 操作；而分隔之后的字符串结构如下图所示，大家一定觉得很眼熟，对，就是多叉树，这个循环过程实际上就是按深度优先原则对多叉树的遍历。 每一个节点就是一个标签、文本字符、空格或者是注释，parseHTML 接受两个参数：template、options，其中 options 拥有 start、end、chars、comment 方法，分别用来处理开始标签、结束标签、文本字符、注释。接下来大致说下整个流程 首先在循环体内部有两大分支，第一大分支处理正常情况（除了 script、style、textarea 标签），第二个分支就是处理特殊情况，我们先看正常情况的处理操作。 在当前给定的字符串中查找第一个 ‘&lt;’ 的下标 如果下标是 0，处理方式如下： 普通注释, ‘–&gt;’ 结尾，如果 options.shouldKeepComment 为 true，则需要保留注释。调用 advance(length) 特殊注释，’]&gt;’ 结尾，调用 advance(length) DOCTYPE 标识，调用 advance(length) 结束标签，调用 advance(length)，parseEndTag 处理结束标签 开始标签，handleStartTag 处理开始标签 advance(length) 的作用就是以 length 为开始点截取 html 剩余部分。 重点看看 handleStartTag 和 parseEndTag。 1234var startTagMatch = parseStartTag();if (startTagMatch) &#123; handleStartTag(startTagMatch);&#125; parseStartTag() 方法返回一个对象： 1234567891011121314let match = &#123; // 一个二维数组，内部每一个数组保存开始标签上的一个属性 // 内数组形如 [\" id=\\\"demo\\\"\", \"id\", \"=\", \"demo\", start: 4, end: 14] // start 为属性开始下标，end 为属性结束下标 attrs: Array, // 标签结束下标 end: Number, // 标签开始下标 start: Number, // 标签名称 tagName: String, // 单标签斜线 unarySlash: String&#125; 弄清楚了 match 的内容，就可以继续去看看 handleStartTag 方法了。我们主要看后半部分的逻辑。 123456789101112131415161718192021222324for (var i = 0; i &lt; l; i++) &#123; var args = match.attrs[i]; var value = args[3] || args[4] || args[5] || ''; var shouldDecodeNewlines = tagName === 'a' &amp;&amp; args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines; attrs[i] = &#123; name: args[1], value: decodeAttr(value, shouldDecodeNewlines) &#125;; if (options.outputSourceRange) &#123; attrs[i].start = args.start + args[0].match(/^\\s*/).length; attrs[i].end = args.end; &#125;&#125;if (!unary) &#123; stack.push(&#123; tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end &#125;); lastTag = tagName;&#125;if (options.start) &#123; options.start(tagName, attrs, unary, match.start, match.end);&#125; 声明一个与 match.attrs 长度相同的数组 attrs，通过遍历 attrs，创建一个新对象，对每一项做如下处理： 将属性名赋值给 name 属性，属性值赋值给 value match.attrs.start 去除空格后赋值个 start，end 赋值给 end最后的 attrs 表现如下： 12345678[ &#123; name: \"id\", value: \"demo\", start: 5, end: 14, &#125;] 上面有声明过 unary，它的作用就是判断当前标签是否是单标签，如果不是单标签，那么就将该标签相关信息用对象包裹，存入 stack 中。 接着，会调用 options.start(tagName, attrs, unary, match.start, match.end), 我们找到 start 方法： 1start: function start (tag, attrs, unary, start$1, end) &#123;&#125; 在源码中可以看到，最开始调用 createASTElement(tag, attrs, currentParent) 创建 AST 对象，后面就是对 element 的一些处理: 添加相关属性、 处理 v-for, v-if, v-once 指令、 是否需要将 element 赋值给 root、 如果不是单标签，将 element 赋值给 currentParent，并且将 element 存入 stack(parse 方法下的 stack)，反之则调用 closeElement 方法结束标签处理操作。 后面的一些处理细节暂不做探究，主要看看 AST 的数据结构。 1234567891011function createASTElement (tag, attrs, parent) &#123; return &#123; type: 1, tag: tag, attrsList: attrs, attrsMap: makeAttrsMap(attrs), rawAttrsMap: &#123;&#125;, parent: parent, children: [] &#125;&#125; parent 与 父标签建立联系，children 可以用来存储多个子标签或子元素。其中 type 的值是1，也就是说标签的类型都是1，那文本或者其他类型呢？我们在源码中找到 options.chars 方法。 12345678910111213if (!inVPre &amp;&amp; text !== ' ' &amp;&amp; (res = parseText(text, delimiters))) &#123; child = &#123; type: 2, expression: res.expression, tokens: res.tokens, text: text &#125;;&#125; else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') &#123; child = &#123; type: 3, text: text &#125;;&#125; 上面代码表示出了 text 字符串最终有可能转换成 type 为2和3的 AST：type 为2的情况（同时满足）： 不处于 v-pre 指令标签下 text !== ‘ ‘ parseText 是判断 text 是否是插值语法 type 为3的情况（满足其一即可）： text !== ‘ ‘ 父标签没有子元素 父标签最后一个子元素的值 !== ‘ ‘ 这里需要说的一点是，type 为3的第三个条件，因为一般换行符都会转换成空格符 ‘ ‘, 为了保证只存在一个换行符，才需要在已经存在子元素的情况下检验最后一个子元素是否是换行符。 通过上面我们知道了 node 元素类型的处理，现在说说模板指令。Vue 模板涉及到各种指令，增加了非常好用的功能，那这里就简单了解一下 v-for, v-if, v-once。这三个指令的处置在 options.start 方法内。开始之前先在 demo 基础上加上一段代码以便调试。 1234567&lt;div id=\"demo\"&gt; &lt;p v-once&gt;测试 v-once&lt;/p&gt; &lt;div v-for=\"record in commits\" v-if=\"commits.length &gt; 0\"&gt; &lt;span&gt;&#123;&#123; record.commit.message &#125;&#125;&lt;/span&gt; &lt;/div&gt; ...&lt;/div&gt; 先来说说对 v-for 的处理： var exp = getAndRemoveAttr(el, ‘v-for’)。从 attrsList 中获取到 v-for 对应的值 ‘record in commits’ var res = parseFor(exp)。将 record 和 commits 分别存入 alias 和 for， 即{alias: record, for: commits} extend(el, res)。将 alias 和 for 属性存入 element 中 v-if： var exp = getAndRemoveAttr(el, ‘v-if’)。从 attrsList 中获取到 v-if 对应的值 ‘commits.length &gt; 0’ 如果 exp 存在 为 el 添加 if 属性，值为 exp addIfCondition(el, {exp: exp, block: el})。 如果 exp 不存在 如果 v-else 存在，为 el 添加 else 属性，值为 true var elseif = getAndRemoveAttr(el, ‘v-else-if’)。 如果 elseif 存在，为 el 添加 elseif 属性，值为 elseif v-once: var once = getAndRemoveAttr(el, ‘v-once’)。 如果 once 存在，为 el 添加 once 属性，值为 true 也就是说，指令的处理其实是将指令对应的属性添加到 AST 对象中。到这里，parse 转换生成的 AST 雏形已经出来了，root 对象一旦确定，后面的子标签对象都会存入 children，而子标签也会存在 children，因此 AST 就是这样一棵树。 transform在明白 template 到 AST 的变化步骤之后，就可以继续探索 AST 是如何生成 render 函数方法。其实这一步主要是将 AST 转换成 render str 函数字符串，然后再通过 new Function(render str) 生成函数方法。由于函数字符串的转换涉及到的情况很多，过程非常复杂，因此这里只是解析 render 字符串形成的原理。 compiled.render = generate(ast, options).render generate 方法如下： 123456var state = new CodegenState(options);var code = ast ? (ast.tag === 'script' ? 'null' : genElement(ast, state)) : '_c(\"div\")';return &#123; render: (\"with(this)&#123;return \" + code + \"&#125;\"), staticRenderFns: state.staticRenderFns&#125; 如果不存在 ast， 那么code 就是 ‘_c(“div”)’，如果存在，则需要判断是否标签名是否是 script，如果不是就走 genElement(options, state) 生成，反之，code 就是 ‘null’。 1234567891011121314151617181920212223242526272829303132333435363738function genElement (el, state) &#123; if (el.parent) &#123; el.pre = el.pre || el.parent.pre; &#125; if (el.staticRoot &amp;&amp; !el.staticProcessed) &#123; return genStatic(el, state) &#125; else if (el.once &amp;&amp; !el.onceProcessed) &#123; return genOnce(el, state) &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el, state) &#125; else if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el, state) &#125; else if (el.tag === 'template' &amp;&amp; !el.slotTarget &amp;&amp; !state.pre) &#123; return genChildren(el, state) || 'void 0' &#125; else if (el.tag === 'slot') &#123; return genSlot(el, state) &#125; else &#123; // component or element var code; if (el.component) &#123; code = genComponent(el.component, el, state); &#125; else &#123; var data; if (!el.plain || (el.pre &amp;&amp; state.maybeComponent(el))) &#123; data = genData(el, state); &#125; var children = el.inlineTemplate ? null : genChildren(el, state, true); code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\"; &#125; // module transforms for (var i = 0; i &lt; state.transforms.length; i++) &#123; code = state.transforms[i](el, code); &#125; return code &#125;&#125; genElement 执行的步骤如下： 遇到 staticRoot、v-once、v-for、v-if、template 标签、slot 标签，先走对应逻辑 如果是 component，则生成 component 的 render 字符串 否则，分两步生成最终的 render 字符串 调用 genData，处理 element 的各种属性：key、ref、pre、component、attrs、props、events、nativeEvents、slots、model，staticClass、staticStyle，返回属性字符串，形如：”{attrs:{“id”:”demo”}}” 调用 genChildren 生成 children 的 render 字符串 code = “_c(‘“ + (el.tag) + “‘“ + (data ? (“,” + data) : ‘’) + (children ? (“,” + children) : ‘’) + “)”; 将 data 与 children 进行拼装 module transform 涉及到的主要方法如下： 123456789101112131415function genNode (node, state) &#123; if (node.type === 1) &#123; return genElement(node, state) &#125; else if (node.type === 3 &amp;&amp; node.isComment) &#123; return genComment(node) &#125; else &#123; return genText(node) &#125;&#125;function genChildren ()&#123; // 省略 var gen = altGenNode || genNode; return (\"[\" + (children.map(function (c) &#123; return gen(c, state); &#125;).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))&#125; 也就是说，在生成 render 字符串时，children 需要用中括号包裹起来，在内部进行遍历，使用 genNode 处理每一项，也就是对不同类型采用不同的处理方法，其中文本和注释的处理很简单，而标签类型依然会重新走 genElement 方法。通过这种递归方式，从上到下调用，从下至上将所有的 AST 对象采取不同的处理，最终会生成如下 render 字符串： 1\"with(this)&#123;return _c('div',&#123;attrs:&#123;\\\"id\\\":\\\"demo\\\"&#125;&#125;,[_c('p',[_v(_s(currentBranch))]),_v(\\\" \\\"),_m(0),_v(\\\" \\\"),_l((commits),function(record)&#123;return (commits.length &gt; 0)?_c('div',[_c('span',[_v(_s(record.commit.message))])]):_e()&#125;),_v(\\\" \\\"),_c('h1',[_v(\\\"Latest Vue.js Commits\\\")]),_v(\\\" \\\"),_l((branches),function(branch)&#123;return [_c('input',&#123;directives:[&#123;name:\\\"model\\\",rawName:\\\"v-model\\\",value:(currentBranch),expression:\\\"currentBranch\\\"&#125;],attrs:&#123;\\\"type\\\":\\\"radio\\\",\\\"id\\\":branch,\\\"name\\\":\\\"branch\\\"&#125;,domProps:&#123;\\\"value\\\":branch,\\\"checked\\\":_q(currentBranch,branch)&#125;,on:&#123;\\\"change\\\":function($event)&#123;currentBranch=branch&#125;&#125;&#125;),_v(\\\" \\\"),_c('label',&#123;attrs:&#123;\\\"for\\\":branch&#125;&#125;,[_v(_s(branch))])]&#125;),_v(\\\" \\\"),_c('p',[_v(\\\"vuejs/vue@\\\"+_s(currentBranch))]),_v(\\\" \\\"),_c('ul',_l((commits),function(record)&#123;return _c('li',[_c('a',&#123;staticClass:\\\"commit\\\",attrs:&#123;\\\"href\\\":record.html_url,\\\"target\\\":\\\"_blank\\\"&#125;&#125;,[_v(_s(record.sha.slice(0, 7)))]),_v(\\\"\\\\n - \\\"),_c('span',&#123;staticClass:\\\"message\\\"&#125;,[_v(_s(_f(\\\"truncate\\\")(record.commit.message)))]),_c('br'),_v(\\\"\\\\n by \\\"),_c('span',&#123;staticClass:\\\"author\\\"&#125;,[_c('a',&#123;attrs:&#123;\\\"href\\\":record.author.html_url,\\\"target\\\":\\\"_blank\\\"&#125;&#125;,[_v(_s(record.commit.author.name))])]),_v(\\\"\\\\n at \\\"),_c('span',&#123;staticClass:\\\"date\\\"&#125;,[_v(_s(_f(\\\"formatDate\\\")(record.commit.author.date)))])])&#125;),0)],2)&#125;\" 字符串中存在的 _c、_v、_s、_f，是创建不同 vnode 的方法，可以在源码中找到，在 renderMixin 中调用了 installRenderHelpers(Vue.prototype)，所以这些方法挂载在了 Vue 上。 1234567891011121314151617181920vm._c = function (a, b, c, d) &#123; return createElement(vm, a, b, c, d, false); &#125;;function installRenderHelpers (target) &#123; target._o = markOnce; target._n = toNumber; target._s = toString; target._l = renderList; target._t = renderSlot; target._q = looseEqual; target._i = looseIndexOf; target._m = renderStatic; target._f = resolveFilter; target._k = checkKeyCodes; target._b = bindObjectProps; target._v = createTextVNode; target._e = createEmptyVNode; target._u = resolveScopedSlots; target._g = bindObjectListeners; target._d = bindDynamicKeys; target._p = prependModifier;&#125; 待所有 AST 处理完成后，render 字符串就生成了, 使用 createFunction(compiled.render, fnGenErrors)，也就是执行 new Function(compiled.render) 将字符串转换成匿名函数，然后将 render 函数赋值给 Vue.$options.render, 这样就完成了 render 函数的创建及挂载工作。 generate上一步我们拿到了 render 函数，那这一步就是了解如何使用这个函数。前言罗列的最后一步是调用 mount 方法，最终指向 mountComponent 方法。 12345678910111213function mountComponent(vm, el, hydrating) &#123; updateComponent = function () &#123; vm._update(vm._render(), hydrating); &#125;; new Watcher(vm, updateComponent, noop, &#123; before: function before () &#123; if (vm._isMounted &amp;&amp; !vm._isDestroyed) &#123; callHook(vm, 'beforeUpdate'); &#125; &#125; &#125;, true /* isRenderWatcher */);&#125; 这里就是创建组件的 Render Watcher。将 updateComponent 设定为 watcher 的 getter，在初始时就会调用 updateCompoennt，触发页面第一次渲染更新。这里需要注意的是，订阅者的 cb 是 noop，因为只执行 updateComponent 就能实现页面的更新（后面会讲到），因此不需要额外的回调函数。 vm._update 方法接受的第一个参是 vnode，也就是说 vm._render() 返回的是一个 vnode，找到 _render 方法，关键的就是三行代码： 123var ref = vm.$options;var render = ref.render;vnode = render.call(vm._renderProxy, vm.$createElement); 这里的 render 方法就是上面说到的匿名函数，美化后如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657(function anonymous() &#123; with(this) &#123; return _c('div', &#123; attrs: &#123; \"id\": \"demo\" &#125; &#125;, [_c('p', [_v(_s(currentBranch))]), _v(\" \"), _m(0), _v(\" \"), _l((commits), function (record) &#123; return (commits.length &gt; 0) ? _c('div', [_c('span', [_v(_s(record.commit.message))])]) : _e() &#125;), _v(\" \"), _c('h1', [_v(\"Latest Vue.js Commits\")]), _v(\" \"), _l((branches), function (branch) &#123; return [_c('input', &#123; directives: [&#123; name: \"model\", rawName: \"v-model\", value: (currentBranch), expression: \"currentBranch\" &#125;], attrs: &#123; \"type\": \"radio\", \"id\": branch, \"name\": \"branch\" &#125;, domProps: &#123; \"value\": branch, \"checked\": _q(currentBranch, branch) &#125;, on: &#123; \"change\": function ($event) &#123; currentBranch = branch &#125; &#125; &#125;), _v(\" \"), _c('label', &#123; attrs: &#123; \"for\": branch &#125; &#125;, [_v(_s(branch))])] &#125;), _v(\" \"), _c('p', [_v(\"vuejs/vue@\" + _s(currentBranch))]), _v(\" \"), _c('ul', _l((commits), function (record) &#123; return _c('li', [_c('a', &#123; staticClass: \"commit\", attrs: &#123; \"href\": record.html_url, \"target\": \"_blank\" &#125; &#125;, [_v(_s(record.sha.slice(0, 7)))]), _v(\"\\n - \"), _c('span', &#123; staticClass: \"message\" &#125;, [_v(_s(_f(\"truncate\")(record.commit.message)))]), _c('br'), _v(\"\\n by \"), _c('span', &#123; staticClass: \"author\" &#125;, [_c('a', &#123; attrs: &#123; \"href\": record.author.html_url, \"target\": \"_blank\" &#125; &#125;, [_v(_s(record.commit.author.name))])]), _v(\"\\n at \"), _c('span', &#123; staticClass: \"date\" &#125;, [_v(_s(_f(\"formatDate\")(record.commit.author.date)))])]) &#125;), 0)], 2) &#125;&#125;) render 方法执行的方式是从下至上，下层执行的结果就是上一层的 children 目前涉及到的几种处置场景如下： 标签，调用 _c，传入标签名、属性、子元素 文本，调用 _v，对涉及到使用变量的部分则需要在内部额外调用 _s 进行处理 v-for，调用 _l，传入需遍历的数组、遍历时执行的方法 v-once，调用 _m v-if 相反情况，调用 _e 过滤标识 |，调用 _f 执行完毕最终会生成这样一个嵌套的对象： 但是有一点需要注意的是，初始时如果不满足条件的不会创建成 vnode，比如，v-if=”commits.length &gt; 0” 才会显示的 div，则没有生成对应的 vnode 存入 父元素的 children 中。 patchvnode 创建完成后，就可以执行 _update 方法了，实际上就是执行 patch 操作，只是初始渲染时不需比较操作，因此初始渲染和后续更新传入的参不一样。在浏览器端就是调用 createPatchFunction({ nodeOps: nodeOps, modules: modules }) 创建的，接下来看看 patch 的魔力吧。注意一点，我们这里只是探究 vnode 是如何变成 dom，不是探究 patch 过程，这两个方向不一样 :)。 12345678910111213141516171819202122232425262728Vue.prototype._update = function (vnode, hydrating) &#123; // initial render vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);&#125;// patchreturn function patch (oldVnode, vnode, hydrating, removeOnly) &#123; // 省略 var isRealElement = isDef(oldVnode.nodeType); if (!isRealElement &amp;&amp; sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly); &#125; else &#123; if (isRealElement) &#123; // 省略 oldVnode = emptyNodeAt(oldVnode); &#125; var oldElm = oldVnode.elm; var parentElm = nodeOps.parentNode(oldElm); // create new node createElm( vnode, insertedVnodeQueue, oldElm._leaveCb ? null : parentElm, nodeOps.nextSibling(oldElm) ); &#125;&#125; 逻辑很清晰，我们传入的是 vm.$el，所以走第二个分支，依据 $el 创建一个空 vnode。紧接着是声明 oldElm 和 parentElm，分别是 #demo 和 body，用作后面方法的入参部分。最后就开始执行创建 elment 步骤了。 createElm 方法里主要是分成三类进行创建，对于标签，使用 createElement，另外还会使用 createChildren 创建子元素对应的 dom，注释使用 createComment，其他的使用 createTextNode。创建结束后执行 insert(parentElm, vnode.elm, refElm), 将创建的 dom 插入到指定的位置。 createElement 其实就是调用 document.createElement(tagName)，createComment 是 document.createComment(text)，同样的，createTextNode 是调用 document.createTextNode(text)。那子元素是怎么创建的呢？我们主要来看看 createChildren 方法。 123456789101112function createChildren (vnode, children, insertedVnodeQueue) &#123; if (Array.isArray(children)) &#123; &#123; checkDuplicateKeys(children); &#125; for (var i = 0; i &lt; children.length; ++i) &#123; createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i); &#125; &#125; else if (isPrimitive(vnode.text)) &#123; nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text))); &#125;&#125; 如果包含多个 child，在检查 children 是否存在重复 key 之后，就会遍历 children，调用 createElm 处理每一个子元素；如果 text 是原生属性，则创建完 textNode 之后，直接 append 到当前位置。 有没有发现，上面说到的只是调用原生创建 dom 的方法，而通过标签生成的 dom 没有我们所赋予的各种属性、指令信息，这样的 dom 是没有灵魂的。所以必须还有一个添加灵魂的步骤。在插入之前有这样的处理： 123if (isDef(data)) &#123; invokeCreateHooks(vnode, insertedVnodeQueue);&#125; vnode 的所有 props、directives、events 等都存储在 data 中，那么这个 invokeCreateHooks 就是给我们的 dom 润色。 12345678910function invokeCreateHooks (vnode, insertedVnodeQueue) &#123; for (var i = 0; i &lt; cbs.create.length; ++i) &#123; cbs.create[i](emptyNode, vnode); &#125; i = vnode.data.hook; if (isDef(i)) &#123; if (isDef(i.create)) &#123; i.create(emptyNode, vnode); &#125; if (isDef(i.insert)) &#123; insertedVnodeQueue.push(vnode); &#125; &#125;&#125; 咋一看是不是觉得摸不着头脑，完全不知道在干什么。关键点是需要弄清楚 cbs.create 是个什么东西。上面说过，我们调用的 patch 方法是通过 createPatchFunction(backend) 方法创建的，这个方法除了返回 patch 和 其他一些方法外，还有对 cbs 做了处理，我将 backend.modules 相关属性整理如下，方便查看： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// 这里只是注明每一个属性它所拥有的方法，方便下面 modules 数组查看var modules = &#123; attrs: &#123; create: updateAttrs, update: updateAttrs &#125;, klass: &#123; create: updateClass, update: updateClass &#125;, events: &#123; create: updateDOMListeners, update: updateDOMListeners &#125;, domProps: &#123; create: updateDOMProps, update: updateDOMProps &#125;, style: &#123; create: updateStyle, update: updateStyle &#125;, transition: inBrowser ? &#123; create: _enter, activate: _enter, remove: function remove$$1 (vnode, rm) &#123; /* istanbul ignore else */ if (vnode.data.show !== true) &#123; leave(vnode, rm); &#125; else &#123; rm(); &#125; &#125; &#125; : &#123;&#125;, ref: &#123; create: function create (_, vnode) &#123; registerRef(vnode); &#125;, update: function update (oldVnode, vnode) &#123; if (oldVnode.data.ref !== vnode.data.ref) &#123; registerRef(oldVnode, true); registerRef(vnode); &#125; &#125;, destroy: function destroy (vnode) &#123; registerRef(vnode, true); &#125; &#125;, directives: &#123; create: updateDirectives, update: updateDirectives, destroy: function unbindDirectives (vnode) &#123; updateDirectives(vnode, emptyNode); &#125; &#125;&#125;var backend = modules: [ attrs, klass, events, domProps, style, transition, ref, directives ]&#125;var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];let i, jconst cbs = &#123;&#125;const &#123; modules, nodeOps &#125; = backendfor (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = [] for (j = 0; j &lt; modules.length; ++j) &#123; if (isDef(modules[j][hooks[i]])) &#123; cbs[hooks[i]].push(modules[j][hooks[i]]) &#125; &#125;&#125; 依据上面的执行逻辑，cbs 就变成下面这样： 1234567cbs = &#123; create: [updateAttrs, updateClass, updateDOMListeners, updateDOMProps, updateStyle, _enter, ref.create, updateDirectives], activate: [_enter], update: [updateAttrs, updateClass, updateDOMListeners, updateDOMProps, updateStyle, ref.update, updateDirectives], remove: [transition.remove], destroy: [ref.destroy, directives.destroy],&#125; 综合以上整理的情况我可以总结如下： 不同的属性拥有针对不同情况的处理方法 attrs、class、domListeners、domProps、style、directives 等属性创建和更新采用的是同一个方法 transition 没有更新方法，但是有进入和销毁方法 指令也有销毁方法 回到上面的 invokeCreateHooks，因为我们这一步是创建初始 dom，所以只需执行 cbs.create 里的方法。那么接下来，我们来看看 cbs.create 里的方法，这里只挑选几个我觉得有意思的做解析（省略不重要代码）。原来的 demo 会做一下改变，以便适应不同的调试场景 updateAttrs12345678910111213141516171819202122var key, cur, old;var elm = vnode.elm;var oldAttrs = oldVnode.data.attrs || &#123;&#125;;var attrs = vnode.data.attrs || &#123;&#125;;for (key in attrs) &#123; cur = attrs[key]; old = oldAttrs[key]; if (old !== cur) &#123; setAttr(elm, key, cur, vnode.data.pre); &#125;&#125;for (key in oldAttrs) &#123; if (isUndef(attrs[key])) &#123; if (isXlink(key)) &#123; elm.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else if (!isEnumeratedAttr(key)) &#123; elm.removeAttribute(key); &#125; &#125;&#125; 第一步，attr 的旧值与新值如果不同，则将值设置成最新的；第二步，一个是 xlink 属性，另一个是无法枚举属性，也就是除了 contenteditable, draggable, spellcheck 之外的属性，这些属性需要被移除 updateClass123&lt;div id=\"demo\"&gt; &lt;p class=\"currentBranchClass\" :class=\"currentBranch\"&gt;&#123;&#123; currentBranch &#125;&#125;&lt;/p&gt;&lt;/div&gt; 123456789101112var data = vnode.datavar cls = genClassForVnode(vnode);var transitionClass = el._transitionClasses;if (isDef(transitionClass)) &#123; cls = concat(cls, stringifyClass(transitionClass));&#125;if (cls !== el._prevClass) &#123; el.setAttribute('class', cls); el._prevClass = cls;&#125; 依据 demo，currentBranch 当前的值是 master，因此 vnode.data = {class: ‘master’, staticClass: “currentBranchClass”}, 最后生成的 cls = ‘currentBranchClass master’。如果存在 transitionClass，则将它合并到 cls 中。最后就是调用原生方法添加 class 属性，并且把 cls 赋值给元素的 _preClass，相当于旧 class，用作下次判断如果新旧 class 相等，则不需要执行添加 class 操作。 updateDOMListeners123456789&lt;div id=\"demo\"&gt; &lt;input type=\"text\" @click=\"testClick\" v-model=\"currentBranch\"&gt;&lt;/div&gt;methods: &#123; testClick() &#123; console.log('yeah, you click it!') &#125;&#125; 123456var on = vnode.data.on || &#123;&#125;;var oldOn = oldVnode.data.on || &#123;&#125;;target = vnode.elm;normalizeEvents(on);updateListeners(on, oldOn, add, remove, createOnceHandler, vnode.context);target = undefined; 因为 v-model 包含有 input 事件，所以这里的 on = {click: testClick, input: f}, 然后是使用 normalizeEvents 处理 type=”range” 这种情况，最后就是更新事件到 dom 上。先来看下这个特殊情况的处理，假如我们把 input 的 type 设置成 range，那么 on = {click: testClick, _r: f}，可以看到 v-model 中的 input 事件被 range 事件覆盖了。所以 normalizeEvents 就是来解决这个问题。 12345if (isDef(on[RANGE_TOKEN])) &#123; var event = isIE ? 'change' : 'input'; on[event] = [].concat(on[RANGE_TOKEN], on[event] || []); delete on[RANGE_TOKEN];&#125; RANGE_TOKEN 即 _r，意思就是，如果是 IE，就使用 range 的 change 事件，否则使用 v-model 的 input 事件。 updateListeners 的入参分别是 当前事件集合、旧事件集合、添加事件方法、移除事件方法、创建一次事件方法、上下文对象。知道了这些，我们继续进入内部探寻，大体上就是分成两个步骤，分别是循环处理新事件和处理旧事件。处理新事件分成三个分支，第一个是处理边界，第二个是不存在旧事件就添加新事件，第三分支是替换新事件。 123456789for (name in on) &#123; // 省略 event = normalizeEvent(name); if (isUndef(cur.fns)) &#123; cur = on[name] = createFnInvoker(cur, vm); &#125; add(event.name, cur, event.capture, event.passive, event.params); // 省略&#125; normalizeEvent(name) 处理事件修饰符，包括 capture、passive 等。接着来看 createFnInvoker(cur, vm) 123456789101112131415function invoker () &#123; var arguments = arguments; var fns = invoker.fns; if (Array.isArray(fns)) &#123; var cloned = fns.slice(); for (var i = 0; i &lt; cloned.length; i++) &#123; invokeWithErrorHandling(cloned[i], null, arguments, vm, \"v-on handler\"); &#125; &#125; else &#123; return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\") &#125;&#125;invoker.fns = fns;return invoker 将 invoker 方法返回，替换了原来绑定的事件方法。fns 是原来的事件方法，它有可能是数组，也可能是单个方法，这决定了走不同的处理分支。但最终都会是执行 invokeWithErrorHandling 方法，传入原事件方法及当前接受到的参数。 12345678910111213function invokeWithErrorHandling (handler, context, args, vm, info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); if (res &amp;&amp; !res._isVue &amp;&amp; isPromise(res) &amp;&amp; !res._handled) &#123; res.catch(function (e) &#123; return handleError(e, vm, info + \" (Promise/async)\"); &#125;); res._handled = true; &#125; &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 这里面除了执行原事件方法以外，还添加了 promise 错误结果处理机制，以及在嵌套调用时可能会引发的多次调用问题，这也是将原事件进行封装的原因之一。 最后就是调用 add 方法添加事件了，内部使用原生 addEventListener, 但是在这之前，会对使用微任务的环境进行一个处理，就是给事件的多次触发添加一个时间，因为异步事件会造成事件重复触发。 updateDirectives常用指令有 v-text, v-html, v-if, v-for, v-else-if, v-else, v-show 等，但是这些都是内置指令，在由 AST 转换成 render 函数的时候就已经被处理，因此 updateDirectives 是专门用来处理自定义指令 1234567891011&lt;div id=\"demo\"&gt; &lt;input v-focus&gt;&lt;/div&gt;directives: &#123; focus: &#123; inserted: function (el) &#123; el.focus() &#125; &#125;&#125;, updateDirectives 实际上是调用 _update 方法： 1234var isCreate = oldVnode === emptyNode;var isDestroy = vnode === emptyNode;var oldDirs = normalizeDirectives(oldVnode.data.directives, oldVnode.context);var newDirs = normalizeDirectives(vnode.data.directives, vnode.context); isCreate 是给 dom 初次绑定指令的标识，isDestroy 则是销毁指令标识。经过 normalizeDirectives 处理之后，newDirs 就变成如下所示 12345678newDirs = &#123; 'v-focus': &#123; def: fn, modifiers: &#123;&#125;, name: 'focus', rawName: 'v-focus' &#125;&#125; 接下来就是对 newDirs 的处理，如果旧指令集中不存在该指令，将 newDirs 存入 dirsWithInsert，否则存入 dirsWithPostpatch。 12var dirsWithInsert = [];var dirsWithPostpatch = []; 123456789101112if (dirsWithInsert.length) &#123; var callInsert = function () &#123; for (var i = 0; i &lt; dirsWithInsert.length; i++) &#123; callHook(dirsWithInsert[i], 'inserted', vnode, oldVnode); &#125; &#125;; if (isCreate) &#123; mergeVNodeHook(vnode, 'insert', callInsert); &#125; else &#123; callInsert(); &#125;&#125; 如果是初次给 dom 绑定指令，使用 mergeVNodeHook 进行 insert 操作。最后一个入参方法是使用 callHook 对每一个新指令进行处理。 1234567891011121314function mergeVNodeHook (def, hookKey, hook) &#123; function wrappedHook () &#123; hook.apply(this, arguments); remove(invoker.fns, wrappedHook); &#125; if (isUndef(oldHook)) &#123; // no existing hook invoker = createFnInvoker([wrappedHook]); &#125; invoker.merged = true; def[hookKey] = invoker;&#125; 这里实际上是对 callInsert 进行了两层封装，第一层是 wrappedHook, 里面执行 callInsert 之外，还做了一个容错处理，这里就不做解析了。第二层就是通用的包装成 invoker。有一点需要注意，那就是封装完成的方法并不是赋值给 vnode[‘insert’]，而是 vnode.data.hook[‘insert’]。为什么呢？在 mergeVNodeHook 中有这样一段代码：def = def.data.hook || (def.data.hook = {}); 讲原因之前需要额外插一个知识点，那就是 JavaScript 中函数传值都是值传递。拿这段代码为例，在执行之前，def 指向的是 vnode，def 只是一个指针，指向 vnode；执行之后，相当于把指针指向了 {}, 那么此时的 def 就是 {}，而 vnode 并不会变成 {}，最后的结果也就变成这样 def = vnode.data.hook = {}。此时 def 和 vnode.data.hook 这两个指针指向了 {}，当为 def 添加属性时，vnode.data.hook 会同步改变，因此 def[‘insert’] = vnode.data.hook[‘insert’] = invoker, 即 vnode.data.hook[‘insert’] = invoker。 到这里，updateDirectives 大概就讲完了，它的主线任务就是给 vnode.data.hook 添加自定义指令对象，包括指令名和指令执行的方法。 dir.def[hook] 即上面包装两层的 invoker。 最后invokeCreateHooks 执行完成后，就会调用 insert(parentElm, vnode.elm, refElm) 挂载 dom。 本文把模板到真实 DOM 的转变分成 parse、transform、generate、patch 四个步骤，前三步骤所做的事跟传统编译步骤不太一样，但也有相同点，这样划分是为了更好的在宏观层面有一个流程记忆，方便理解。每一个步骤都会涉及巨量内容及复杂情况的处理，不可能都涉及到，因此本篇的宗旨是从宏观上理解这些过程。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"响应式系统是如何运作的","slug":"源码阅读/vue2/响应式系统是如何运作的","date":"2021-04-19T16:00:00.000Z","updated":"2021-08-30T02:40:08.519Z","comments":true,"path":"2021/04/20/源码阅读/vue2/响应式系统是如何运作的/","link":"","permalink":"http://yoursite.com/2021/04/20/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E4%BD%9C%E7%9A%84/","excerpt":"","text":"前言作为 Vue 的特色之一，响应式系统原理一直被大家所讨论和学习，网上关于原理解析的文章也是多如牛毛。但别人的始终是别人的，想要变成自己的还得自己动手，真正去理解。 什么是响应式系统官方文档说： 数据模型只是普通的 JavaScript 对象，而当你修改它时，视图也会改变 其实除了视图会改变之后，那些订阅过该属性的对象也会改变 到这里，就可以祭出响应式系统的三驾马车了：Observer、Watcher、Dep。其实响应式系统可以理解为 Observer + ‘发布订阅模式’。 每个组件都有一个 watcehr 实例与之对应，官方定义为 render watcher。watcher 会把在组件渲染过程中用到的属性设置为自身的一个依赖，当这个依赖发生改变时，就会通知 watcehr。 除了 render watcher，还有 user watcher，就是我们在 options 里配置的 watch 对象。它是在组件初始化就完成收集工作的。 开始之前用下面这张图来表示响应式系统的运行流程。 接下来我们会从源码的角度来讲解图中的各部分。 ObserveObserver 就是赋予一个属性一些能力，为属性添加 getter/setter 方法。 12345678910111213141516var Observer = function Observer (value) &#123; this.value = value; this.dep = new Dep(); this.vmCount = 0; def(value, '__ob__', this); if (Array.isArray(value)) &#123; if (hasProto) &#123; protoAugment(value, arrayMethods); &#125; else &#123; copyAugment(value, arrayMethods, arrayKeys); &#125; this.observeArray(value); &#125; else &#123; this.walk(value); &#125;&#125;; 对数组和对象做不一样的处理，对象走 walk 方法，而数组则重新走 Observer，因为里面的属性有可能是对象，需要走 walk 方法 Watcher一个 Watcher 就是一个订阅者，它如果被某个依赖收集器收集起来，就说明它完成了对这个依赖收集器所属对象的订阅工作，那么当这个对象发生改变时，就会通知订阅者去响应这个改变。 12345678910111213141516171819// expOrFn 是 watcher 的 getter 表达式// cb 是依赖对象发生改变时执行的操作var Watcher = function Watcher (vm, expOrFn, cb, options, isRenderWatcher) &#123; // ... this.cb = cb; this.id = ++uid$2; this.active = true; // 是否在创建实例时就执行 getter 的标识 this.dirty = this.lazy; this.deps = []; this.newDeps = []; this.depIds = new _Set(); this.newDepIds = new _Set(); this.expression = expOrFn.toString(); // ... this.value = this.lazy ? undefined : this.get();&#125;; 构造函数本身会初始化一些必要属性， 如 this.cb 是当订阅对象发生改变时所需要调用的方法，而 deps、newDeps 则与依赖收集器相关。下面简单罗列一个 watcher 所拥有的方法。 12345678910111213141516// 触发 getter，重新获取依赖Watcher.prototype.get = function get () &#123;&#125;// 将自身存入 Dep 系统中Watcher.prototype.addDep = function addDep (dep) &#123;&#125;// 将自身从 Dep 系统中移除Watcher.prototype.cleanupDeps = function cleanupDeps () &#123;&#125;// Dep 重新发布后，自身开始更新依赖Watcher.prototype.update = function update () &#123;&#125;// 执行 cb，真正的更新操作，Watcher.prototype.run = function run () &#123;&#125;// 调用 get 方法，只会为惰性 watcher 执行Watcher.prototype.evaluate = function evaluate () &#123;&#125;// 将自身添加到所有的 Dep 系统中Watcher.prototype.depend = function depend () &#123;&#125;// 将自己从所有的 Dep 系统中移除Watcher.prototype.teardown = function teardown () &#123;&#125; Dep每一个 Dep 都会附属于一个对象，用来收集订阅这个对象的 watcher，当这个对象发生改变时，Dep 就会通知订阅者去更新 12345678910111213var Dep = function Dep () &#123; this.id = uid++; // 订阅者集合 this.subs = [];&#125;;// 添加订阅者Dep.prototype.addSub = function addSub (sub) &#123;&#125;// 移除订阅者Dep.prototype.removeSub = function removeSub (sub) &#123;&#125;// watcher 收集 dep Dep.prototype.depend = function depend () &#123;&#125;// 通知订阅者Dep.prototype.notify = function notify () &#123;&#125; 上面对三驾马车做了一个简单的解释，下面将会全面解析响应式系统是如何由这三个系统整合。 响应式系统的运作按照上方的流程图，依据 watcher 的不同，可以分成两类运作方式，这里称为 Render Watcher 和 User Watcher。它们只是依赖收集时机不同而已。但是本篇只解析 User Watcher 的运作方式， Render Watcher 在 模板怎么变成真实DOM 中有讲到，就不重复了，但在文末会有一个简单描述。 依赖收集还是拿官方 demo（路径是：/examples/commits） 来举例，精简之后如下： 123456789101112131415161718192021// html&lt;div id=\"demo\"&gt; &#123;&#123; currentBranch &#125;&#125;&lt;/div&gt;// jsnew Vue(&#123; data: &#123; currentBranch: 'master', &#125;, watch: &#123; currentBranch: 'fetchData' &#125;, mounted () &#123; setTimeout(() =&gt; &#123; this.currentBranch = 'dev' &#125;, 1000) &#125;, methods: &#123; fetchData: function () &#123;&#125; &#125; 声明了一个响应式属性 currentBranch, 并且用 watch 去观察它，响应方法是 fetchData。 依据 “总体结构” 章节的准备工作，我们可以清楚的知道 data 对象的处理位于 initData 方法中，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041function initData (vm: Component) &#123; let data = vm.$options.data data = vm._data = typeof data === 'function' ? getData(data, vm) : data || &#123;&#125; if (!isPlainObject(data)) &#123; data = &#123;&#125; process.env.NODE_ENV !== 'production' &amp;&amp; warn( 'data functions should return an object:\\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm ) &#125; // proxy data on instance const keys = Object.keys(data) const props = vm.$options.props const methods = vm.$options.methods let i = keys.length while (i--) &#123; const key = keys[i] if (process.env.NODE_ENV !== 'production') &#123; if (methods &amp;&amp; hasOwn(methods, key)) &#123; warn( `Method \"$&#123;key&#125;\" has already been defined as a data property.`, vm ) &#125; &#125; if (props &amp;&amp; hasOwn(props, key)) &#123; process.env.NODE_ENV !== 'production' &amp;&amp; warn( `The data property \"$&#123;key&#125;\" is already declared as a prop. ` + `Use prop default value instead.`, vm ) &#125; else if (!isReserved(key)) &#123; proxy(vm, `_data`, key) &#125; &#125; // observe data observe(data, true /* asRootData */)&#125; initData 方法主要做了三件事： 获取真正的 data 对象，因为 options 中的 data 有可能是函数 对于在 methods 和 props 中已经存在的属性，做警告提示 observe data 通过查看 observe 方法，我们可以知道，重点就是这段代码： 1let ob = new Observer(value) 就这样顺藤摸瓜找到了 Observer 构造函数，该构造函数及与自身相关的属性已经在上面列出，其中 walk 是这样的： 123456Observer.prototype.walk = function walk (obj) &#123; var keys = Object.keys(obj); for (var i = 0; i &lt; keys.length; i++) &#123; defineReactive(obj, keys[i]); &#125;&#125;; 对对象的每一个属性都调用 defineReactive 处理 1234567891011121314151617181920212223242526272829303132333435363738function defineReactive (obj, key, val, customSetter, shallow) &#123; var dep = new Dep(); var property = Object.getOwnPropertyDescriptor(obj, key); if (property &amp;&amp; property.configurable === false) &#123; return &#125; // 获取已经定义过的 get/set var getter = property &amp;&amp; property.get; var setter = property &amp;&amp; property.set; if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123; val = obj[key]; &#125; // 这里需要对属性进行二次 observe，可以对对象属性进行 observe var childOb = !shallow &amp;&amp; observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; var value = getter ? getter.call(obj) : val; if (Dep.target) &#123; dep.depend(); if (childOb) &#123; childOb.dep.depend(); if (Array.isArray(value)) &#123; dependArray(value); &#125; &#125; &#125; return value &#125;, set: function reactiveSetter (newVal) &#123; // 省略 &#125; &#125;);&#125; defineReactive 方法做了如下处理： 声明一个 Dep 实例 对传参属性值进行继续进行 observe 处理 使用 Object.defineProperty 为传参属性 key 添加 getter/setter 响应式系统的联动装置就存在于 get 和 set 中，get 属性中有这样一段代码 123if (Dep.target) &#123; dep.depend();&#125; 如果 Dep.target 存在，就调用 dep.depend 方法，那么现在有两个问题： get 的触发时机是什么 Dep.target 是什么 12345678function initState (vm) &#123; if (opts.data) &#123; initData(vm); &#125; if (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123; initWatch(vm, opts.watch); &#125;&#125; 在 initData 处理完之后会调用 initWatch，以下会简略罗列 initWatch 所包含的一些处理 123456function initWatch (vm, watch) &#123; for (var key in watch) &#123; // 省略一些代码 createWatcher(vm, key, handler); &#125;&#125; createWatcher 中有这样的一个处理 return vm.$watch(expOrFn, handler, options) 123456789101112131415161718Vue.prototype.$watch = function (expOrFn, cb, options) &#123; var vm = this; if (isPlainObject(cb)) &#123; return createWatcher(vm, expOrFn, cb, options)0 &#125; options = options || &#123;&#125;; options.user = true; var watcher = new Watcher(vm, expOrFn, cb, options); if (options.immediate) &#123; var info = \"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"; pushTarget(); invokeWithErrorHandling(cb, vm, [watcher.value], vm, info); popTarget(); &#125; return function unwatchFn () &#123; watcher.teardown(); &#125;&#125;; 首先是对 cb 的判断，如果是对象，则重新走 createWatcher, 找到它内部的函数；接着是创建一个 Watcher 实例 继续查看 Watcher 之前，我们先要了解一个重要的机制，那就是每当 Dep 收集时，只能存在一个订阅者，因此下面的一对处理方法的作用就是添加和删除订阅者 123456789function pushTarget (target) &#123; targetStack.push(target); Dep.target = target;&#125;function popTarget () &#123; targetStack.pop(); Dep.target = targetStack[targetStack.length - 1];&#125; 在 Watcher 实例创建时会调用自身的 get 方法，内容如下： 123456789101112131415161718192021Watcher.prototype.get = function get () &#123; pushTarget(this); var value; var vm = this.vm; try &#123; value = this.getter.call(vm, vm); &#125; catch (e) &#123; if (this.user) &#123; handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\")); &#125; else &#123; throw e &#125; &#125; finally &#123; if (this.deep) &#123; traverse(value); &#125; popTarget(); this.cleanupDeps(); &#125; return value&#125;; 大致的执行步骤如下： 将自身作为当前订阅者存入 targetStack 中， 然后调用自身的 getter 方法 将自身从 targetStack 中弹出，并将当前订阅者设为 null 步骤1和3很清晰，但是步骤2中的 getter 方法是什么呢？ getter 的定义存在于 Watcher 构造函数中，上面贴代码时省略掉了 1this.getter = parsePath(expOrFn); 1234567891011121314var bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));function parsePath (path) &#123; if (bailRE.test(path)) &#123; return &#125; var segments = path.split('.'); return function (obj) &#123; for (var i = 0; i &lt; segments.length; i++) &#123; if (!obj) &#123; return &#125; obj = obj[segments[i]]; &#125; return obj &#125;&#125; getter 就是 parsePath 返回的这个方法，它可以获取到类似 a.b.c 的值。expOrFn 是 ‘currentBranch’, 符合格式验证，因此 sements 即 [‘currentBranch’], 当执行 getter 并传入 vm 时，就会执行 obj = obj[segments[i]]，转换之后就是 obj = vm[‘currentBranch’]。 vm[‘currentBranch’] 就是获取 currentBranch 的值，那么就会触发它的 get 方法，所以我们再回到前面定义的 get 方法中。 12345678get: function reactiveGetter () &#123; var value = getter ? getter.call(obj) : val; if (Dep.target) &#123; dep.depend(); // 省略一些代码 &#125; return value&#125;, var value = getter ? getter.call(obj) : val; 因为前面没有为 currentBranch 定义过 getter 方法, 因此 value 就是 val 即 ‘master’ Dep.target 在 pushTarget(this) 时已经存在， 即 currentBranch watcher。 然后执行 dep.depend() 通知 dep 将 watcher 收集起来，最后返回 value 继续回到 Watcher.prototype.get 中在 finally 代码块中执行 popTarget() 清空 targetStack，将当前订阅者设为 null 到这里我们几乎完整走了一遍依赖收集过程，这个过程涉及到了响应式系统的三驾马车。简单梳理一下： 首先 data 中的属性经过 Observer 处理，会获得一对 getter/setter，这是响应式的根基 这个属性在 watch 中也有声明，因此最终的 $watch 方法也会处理到它。这里分为两个步骤，第一是将自身置为当前的 Dep.target, 第二是在获取这个属性的值时触发 getter，进而完成 dep 对 watcher 的收集 依赖触发前面说过，这个响应式系统可以理解为发布订阅模式，上面已经了解了订阅过程，接下来就要去探寻发布过程了。 这个 demo 的功能很简单，1秒之后会将 currentBranch 更改为 dev，所以这时会触发 currentBranch 的 setter 1234567891011121314151617set: function reactiveSetter (newVal) &#123; var value = getter ? getter.call(obj) : val; if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123; return &#125; if (customSetter) &#123; customSetter(); &#125; if (getter &amp;&amp; !setter) &#123; return &#125; if (setter) &#123; setter.call(obj, newVal); &#125; else &#123; val = newVal; &#125; childOb = !shallow &amp;&amp; observe(newVal); dep.notify();&#125; 首先做一个新旧值判断的处理，通过之后将新值也要做 observe 处理，最后就是通知订阅者这个值发生了改变 12345678910Dep.prototype.notify = function notify () &#123; var subs = this.subs.slice(); if (!config.async) &#123; // watcher 更新顺序需要按顺序进行 subs.sort(function (a, b) &#123; return a.id - b.id; &#125;); &#125; for (var i = 0, l = subs.length; i &lt; l; i++) &#123; subs[i].update(); &#125;&#125;; subs 里存放的就有之前收集起来的 watcher，因此 subs[i].update 就相当于 watcher.update。注意的是 subs 包括该组件的 watcher。 123456789Watcher.prototype.update = function update () &#123; if (this.lazy) &#123; this.dirty = true; &#125; else if (this.sync) &#123; this.run(); &#125; else &#123; queueWatcher(this); &#125;&#125;; 因为默认 lazy 和 sync 都为 false，因此这里会走 queueWatcher(this) 12345678910111213141516171819202122232425function queueWatcher (watcher) &#123; var id = watcher.id; if (has[id] == null) &#123; has[id] = true; if (!flushing) &#123; queue.push(watcher); &#125; else &#123; var i = queue.length - 1; while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123; i--; &#125; queue.splice(i + 1, 0, watcher); &#125; // queue the flush if (!waiting) &#123; waiting = true; if (!config.async) &#123; flushSchedulerQueue(); return &#125; nextTick(flushSchedulerQueue); &#125; &#125;&#125; 默认状态下，将新 watcher 存入 queue 中之后，在下一次更新时执行 flushSchedulerQueue 方法 1234567891011121314function flushSchedulerQueue () &#123; // 省略代码 for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; if (watcher.before) &#123; watcher.before(); &#125; id = watcher.id; has[id] = null; watcher.run(); // 省略代码 &#125; // 省略代码&#125; 所有与改变属性相关的 watcher 都存入 queue 之后，遍历 queque，执行 watcher.run() 1234567891011121314151617181920Watcher.prototype.run = function run () &#123; if (this.active) &#123; var value = this.get(); if ( value !== this.value || isObject(value) || this.deep ) &#123; // set new value var oldValue = this.value; this.value = value; if (this.user) &#123; var info = \"callback for watcher \\\"\" + (this.expression) + \"\\\"\"; invokeWithErrorHandling(this.cb, this.vm, [value, oldValue], this.vm, info); &#125; else &#123; this.cb.call(this.vm, value, oldValue); &#125; &#125; &#125;&#125;; run 方法做了两件事： 执行 this.get() 拿到新值赋值给 watcher.value 执行 invokeWithErrorHandling() 触发 cb 执行 其中，$watch 方法中设置 options.user = true，代表这个 wathcer 是 user watcher。因此会执行 invokeWithErrorHandling(); 12345678910function invokeWithErrorHandling (handler,context,args,vm,info) &#123; var res; try &#123; res = args ? handler.apply(context, args) : handler.call(context); // 省略代码 &#125; catch (e) &#123; handleError(e, vm, info); &#125; return res&#125; 这里的 handler 就是属性值改变时调用的处理方法，即 fetchData。至此，就完成了属性更改、dep 通知、watcher 执行回调这一连串动作。 上面说到的 watcher.update 是 currentBranc watch，那当 currentBranch 发生改变的时候，vm watcher 做了什么呢？它只会在 run 方法内执行 this.get() 方法，它的 get 方法是 updateComponent，那么也就是说它会重新渲染页面。 最后以上，我们以 User Watcher 为例，简单梳理了 Vue 响应式系统三驾马车运行的一个过程，简单来讲就是： Observe 为属性添加 getter/setter 创建 User Watcher 实例时使用属性进而触发依赖收集 属性改变时触发 Dep 通知 Watcher 更新并且执行 cb Render Watcehr 的过程是： Observe 为属性添加 getter/setter 创建 Render Watcher 进行页面 init-render Render Function 使用属性进而触发依赖收集 属性改变时触发 Dep 通知 Watcher 更新和进行页面 re-render","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue2-总体结构(二)","slug":"源码阅读/vue2/总体结构(二)","date":"2021-04-09T16:00:00.000Z","updated":"2021-08-17T08:40:09.716Z","comments":true,"path":"2021/04/10/源码阅读/vue2/总体结构(二)/","link":"","permalink":"http://yoursite.com/2021/04/10/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%BA%8C)/","excerpt":"","text":"前言前一小节，我们整理了 Vue 相关的属性，这一小节则通过框架自带的 demo 来梳理一下 Vue 整体的一个运行流程。 正文首先我们找到本节 demo 目录，路径为 ‘/examples/commits’。将 index.html 中 vue 的引用路径改成 ‘‘, 方便调试。 app.js 里调用了 Vue 构造函数，所以从这里开始吧。 12345678910111213new Vue(&#123; el: '#demo', data: &#123; branches: ['master', 'dev'], currentBranch: 'master', commits: null &#125;, created: function () &#123; this.fetchData() &#125;, watch: &#123; currentBranch: 'fetchData' &#125;, new Vue() 之前做了什么Vue 本身会进行一系列的初始化工作 /src/core/instance/index.js 12345initMixin(Vue);stateMixin(Vue);eventsMixin(Vue);lifecycleMixin(Vue);renderMixin(Vue); /src/core/index.js 12345678910111213141516initGlobalAPI(Vue);Object.defineProperty(Vue.prototype, \"$isServer\", &#123; get: isServerRendering,&#125;);Object.defineProperty(Vue.prototype, \"$ssrContext\", &#123; get() &#123; return this.$vnode &amp;&amp; this.$vnode.ssrContext; &#125;,&#125;);Object.defineProperty(Vue, \"FunctionalRenderContext\", &#123; value: FunctionalRenderContext,&#125;);Vue.version = \"__VERSION__\"; /src/core/global-api.js 1234initUse(Vue);initMixin(Vue);initExtend(Vue);initAssetRegisters(Vue); new Vue() 做了什么new Vue() 实际上调用了自身的 _init 方法，从字典可知，_init 方法 在 ‘/src/core/instance/init.js’ 中的 initMixin 方法里。忽略部分代码后是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445let uid = 0;Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this; // a uid vm._uid = uid++; // 这个标识可以避免 vm 被观察系统观察 vm._isVue = true; // 将通过自定义策略合并配置项后的值赋值给 $options vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); if (process.env.NODE_ENV !== \"production\") &#123; // 如果不是生产环境就初始化代理相关操作 initProxy(vm); &#125; else &#123; vm._renderProxy = vm; &#125; vm._self = vm; // 初始化声明周期 initLifecycle(vm); // 初始化事件机制 initEvents(vm); // 初始化渲染相关 initRender(vm); // 调用 beforeCreate 钩子 callHook(vm, \"beforeCreate\"); // 在 data 或 props 被处理前初始化注入 initInjections(vm); // resolve injections before data/props // 初始化对 data 和 props 相关操作 initState(vm); // 在 data 或 props 被处理后初始化注入 initProvide(vm); // resolve provide after data/props // 调用 created 钩子 callHook(vm, \"created\"); // 如果存在 el 属性，则进行挂载操作 if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125;&#125;; 从上可知，_init 方法主要做了如下几件事： 为 Vue 实例添加 $options 属性 初始化相关属性。 在渲染操作相关初始化完成之后和属性注入相关初始化之前调用 beforeCreate 钩子 在依赖相关初始化完成之后和 Dom 挂载之前调用 created 钩子 挂载 Dom options 合并策略我们使用 Vue 构造函数时传入的 options 会经过一系列的合并，合并之后的 options 会被赋值给实例的 $options 属性 12345678910// merge optionsif (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options);&#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm );&#125; 因为动态 options 的合并耗时较长，因此只对主组件采取动态合并的方式。 先看看 resolveConstructorOptions 方法，vm 是 Vue 实例，vm.constructor 指的是 Vue，代码简化后如下所示： 12345var options = Ctor.options;if (Ctor.super) &#123; // ...&#125;return options; 依据字典，我们可以知道，Vue.options 的值可以表示成这样： 123456Vue.options = &#123; components: &#123;&#125;, directives: &#123;&#125;, filters: &#123;&#125;, _base: Vue,&#125;; 示例中 options 并没有指定 super 属性，因此该方法直接 return options 回到 mergeOptions, 第一个参 parent 即 Vue.options, 第二个参 child 是构造函数的入参，第三个是 Vue 实例。 首先是调用 checkComponents(child)，对 components 中声明的名称做格式上的校验，必须符合 html5 标准，并且不能使用内置的 html 标签 12345function checkComponents(options) &#123; for (var key in options.components) &#123; validateComponentName(key); &#125;&#125; 接着是对 props、inject、directives 这些参数进行格式化，最后都形成对象的形式。 下面开始真正的合并。 第一步，将尚未合并过的 child 中的 extend 和 mixins 属性合并到 parent 中。第二步，按顺序将 parent 和 child 的属性存入到声明的空对象 options 中。 需要注意的是在对 child 处理时，只对 parent 中不存在的属性做合并，可以避免对 Vue.options 属性的覆盖 12345for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key); &#125;&#125; 接下来重点看下 mergeField 方法，这个是整个合并策略的核心 1234function mergeField(key) &#123; var strat = strats[key] || defaultStrat; options[key] = strat(parent[key], child[key], vm, key);&#125; 总的来说，strats 就是一个对象，它的属性是一个个用来处理不同类型属性的策略方法。 除了 strats，还有一个默认策略方法 defaultStrat 123var defaultStrat = function (parentVal, childVal) &#123; return childVal === undefined ? parentVal : childVal;&#125;; 逻辑很简单：如果 childVal 存在，返回 childVal，否则返回 parentVal。 以下是 strats 的策略方法： 1、el，propsData12345strats.el = strats.propsData = function (parent, child, vm, key) &#123; // ... // 使用默认策略 return defaultStrat(parent, child);&#125;; 2、data12345678910111213141516strats.data = function (parentVal, childVal, vm) &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== \"function\") &#123; warn( 'The \"data\" option should be a function ' + \"that returns a per-instance value in component \" + \"definitions.\", vm ); return parentVal; &#125; return mergeDataOrFn(parentVal, childVal); &#125; return mergeDataOrFn(parentVal, childVal, vm);&#125;; mergeDataOrFn 返回的方法里会调用 mergeData 方法，我们跳过直接看 mergeData 12345678910111213141516171819202122232425262728293031function mergeData(to, from) &#123; // 如果不存在子项，直接返回父项 if (!from) &#123; return to; &#125; var key, toVal, fromVal; var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from); for (var i = 0; i &lt; keys.length; i++) &#123; key = keys[i]; // 如果属性已经被 oberved， 则直接跳过 if (key === \"__ob__\") &#123; continue; &#125; toVal = to[key]; fromVal = from[key]; // 如果父项没有当前属性，则开启合并(覆盖) if (!hasOwn(to, key)) &#123; set(to, key, fromVal); &#125; else if ( // 如果当前父属性和子属性都为对象且不相等，则递归合并(覆盖) toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; mergeData(toVal, fromVal); &#125; &#125; return to;&#125; 3、声明周期钩子123456789101112131415161718192021222324LIFECYCLE_HOOKS.forEach(function (hook) &#123; strats[hook] = mergeHook;&#125;);function mergeHook(parentVal, childVal) &#123; var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal; return res ? dedupeHooks(res) : res;&#125;function dedupeHooks(hooks) &#123; var res = []; for (var i = 0; i &lt; hooks.length; i++) &#123; if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]); &#125; &#125; return res;&#125; mergeHook 中 parentVal 和 childVal 处理后 res 情况如下： 如果 childVal 存在 如果 parentVal 存在，将 childVal 合并进 parentVal 中 如果 parentVal 不存在，保证 childVal 为数组或处于数组中 如果 childVal 不存在，则返回 parentVal res 可能存在重复的 hook，所以 dedupeHooks 坐了一个去重mergeHook 最后返回的值就是一个包含合并后生命周期钩子的数组 4、components, directives, filters123ASSET_TYPES.forEach(function (type) &#123; strats[type + \"s\"] = mergeAssets;&#125;); 这三类都采用 mergeAssets 方法 123456789function mergeAssets(parentVal, childVal, vm, key) &#123; var res = Object.create(parentVal || null); if (childVal) &#123; assertObjectType(key, childVal, vm); return extend(res, childVal); &#125; else &#123; return res; &#125;&#125; 只有 childVal 存在时，才会执行合并(覆盖)操作，否则只返回 parentVal 原型链下级对象 5、watch12345678910111213141516171819202122232425strats.watch = function (parentVal, childVal, vm, key) &#123; // ... if (!childVal) &#123; return Object.create(parentVal || null); &#125; // ... if (!parentVal) &#123; return childVal; &#125; var ret = &#123;&#125;; extend(ret, parentVal); for (var key in childVal) &#123; var parent = ret[key]; var child = childVal[key]; if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent]; &#125; ret[key] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; &#125; return ret;&#125;; watch 合并后的对象 ret 的值是数组，保证每一个 key 可以包含多个 watcher，而且 watcher 不能被覆盖，因此这里不会有去重操作 6、props，methods，inject、computed1234567891011121314151617181920strats.props =strats.methods =strats.inject =strats.computed = function (parentVal, childVal, vm, key) &#123; // ... // 如果 parentVal 不存在，直接返回 childVal if (!parentVal) &#123; return childVal; &#125; var ret = Object.create(null); // 将 parentVal 的属性存入 ret 中 extend(ret, parentVal); // 如果 childVal 存在，将 childVal 的属性存入 ret 中 if (childVal) &#123; extend(ret, childVal); &#125; // 返回 ret return ret; &#125;; 7、provide 采用 mergeDataOrFn最后以上，我们梳理了在使用 Vue 时，它自身都做了哪些工作。并且着重解析了 options 中属性合并策略，简单总结一下： 1、el、propsData 如果 child 不存在，返回 parent，否则返回 child 2、data、provide 如果 child 不存在，返回 parent 如果 parent 存在，遍历 child 的属性， 如果 parent 不存在该属性，则将属性赋予 parent 如果 parent 存在该属性，并且 parentVal 与 childVal 同为对象且不相等，则递归合并 parentVal 与 childVal 3、components, directives, filters如果 child 存在，合并 child 属性至新对象中，否则返回空对象 4、props，methods，inject，computed 如果 parent 不存在，返回 child 如果 parent 存在或 child 存在，将各自的属性赋予返回的新对象中 5、watch 和 LIFECYCLE_HOOKS相同点：如果 parent 和 child 存在，保证它们都是数组形式，将 child 并入 到 parent 中不同点：LIFECYCLE_HOOKS 最后的结果需要去重，而 watch 不用","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"Vue2-总体结构(一)","slug":"源码阅读/vue2/总体结构(一)","date":"2021-04-07T16:00:00.000Z","updated":"2021-08-17T08:39:46.388Z","comments":true,"path":"2021/04/08/源码阅读/vue2/总体结构(一)/","link":"","permalink":"http://yoursite.com/2021/04/08/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%B8%80)/","excerpt":"","text":"问题为什么要读 VueVue 是目前项目正在使用的框架，阅读学习源码能让我更好的使用框架所提供的功能，也可以解答使用过程中所产生的困惑。有人可能会问，Vue2 相关的源码解析文章在网上一大堆，何必要自己去写呢？我只想说，纸上得来终觉浅，绝知此事要躬行。通过看别人的文章确实能在短期去记住，但是时间久了就会忘了，而如果是自己根据问题疑惑去调试 demo，然后去理解原理，最后总结成文章表达出来，那种记忆是最深的。 Vue3 已经出来了，为什么依然读 Vue2原因一是很久以前就读过一点点 Vue2 的源码，理解了基本的原理，但是后来没有坚持去深入，也就荒废了，心里多少还是有点不甘。因此这次相当于从新来过，也是准备出一个系列，既是读源码的记录整理，也是日后问题查询之处。原因二是虽然新版本的语法形式与旧版不同，但最核心的思想是没变的，吃透旧版之后，有机会也会去读读 Vue3，而这也是必须的。活到老，学到老。 简介源码基于 version 2.6.14 of Vue 本系列暂分为8章，当前章节主要是对后续章节做辅助准备。初次阅读源码时，我就时常陷入各种属性方法名之中，我不知道这个属性是在哪儿声明的，它的作用是什么。虽然说读源码最忌讳深入细枝末节，但无穷的属性让我很恐惧，所以本章会理清楚整体的一个逻辑走向，而第一部分主要是罗列跟 Vue 相关的属性和方法。 正文入口Vue 这种框架核心文件都是在 src 文件里，但是入口在 package.json 中可以找到。 1\"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev\" 通过上述指令，打开 scripts/config.js 123456789101112131415161718192021const aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125;const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs-dev': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.dev.js'), format: 'cjs', env: 'development', banner &#125;, ...&#125; 这里是配置入口文件的路径。aliases 对象即 12345678910module.exports = &#123; vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), sfc: resolve('src/sfc')&#125; 结合上面两部分代码可以知道，入口在 ‘src/platforms/web/entry-runtime.js’ 中, 即 1import Vue from './runtime/index' 继续打开 src/platforms/web/runtime/index 123456789101112131415161718192021// 这里指明了 Vue 的来源import Vue from 'core/index'// 如下为 Vue 添加了相关属性，Vue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElement// 只有浏览器环境才需要 patch 方法Vue.prototype.__patch__ = inBrowser ? patch : noop// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 从上可知， Vue 其实来源于我们之前说的 src 文件中，并且这里为 Vue 原型上添加了 $mount 和 patch 方法。 核心从这里开始将会沿着寻找 Vue 构造函数的源头，走马观花式的记录与 Vue 相关的属性及方法。 /src/core/index.js 123456Vue.prototype.$isServer = isServerRendering;Vue.prototype.$isServer = this.$vnode &amp;&amp; this.$vnode.ssrContext;Vue.FunctionalRenderContext = &#123; value: FunctionalRenderContext&#125;;Vue.version = '__VERSION__'; /src/core/global-api/index.js =&gt; initGlobalAPI(Vue) 123456789101112131415161718192021222324Vue.config = configDef;Vue.util = &#123; warn, extend, mergeOptions, defineReactive&#125;;Vue.set = set;Vue.delete = del;Vue.nextTick = nextTick;Vue.observable = obj =&gt; &#123; observe(obj) return obj&#125;Vue.options = Object.create(null)Vue.options.components = Object.create(null);Vue.options.directives = Object.create(null)Vue.options.filters = Object.create(null)Vue.options._base = Vue// extend(Vue.options.components, builtInComponents) builtInComponents 即 KeepAlive Vue.options.components.KeepAlive = KeepAlive /src/core/global-api/use.js =&gt; initUse(Vue) 1Vue.use = function () &#123;&#125; /src/core/global-api/mixin.js =&gt; initMixin(Vue) 1Vue.mixin = function () &#123;&#125; /src/core/global-api/extend.js =&gt; initExtend(Vue) 12Vue.cid = 0Vue.extend = function () &#123;&#125; /src/core/global-api/assets.js =&gt; initAssetRegisters(Vue) 123Vue.components = function () &#123;&#125;Vue.directives = function () &#123;&#125;Vue.filters = function () &#123;&#125; /src/core/instance/index.js 123456789&lt;!-- Vue 构造函数 --&gt;function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; /src/core/instance/init.js =&gt; initMixin(Vue) 12345678910Vue.prototype._init = function () &#123;&#125;vm._uid = uid++vm._isVue = truevm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm)vm._renderProxy = vmvm._self = vm /src/core/instance/lifecycle.js =&gt; initLifecycle(Vue) 123456789101112vm.$parent = parentvm.$root = parent ? parent.$root : vm vm.$children = []vm.$refs = &#123;&#125; vm._watcher = nullvm._inactive = nullvm._directInactive = falsevm._isMounted = falsevm._isDestroyed = falsevm._isBeingDestroyed = false /src/core/instance/events.js =&gt; initEvents(Vue) 12vm._events = Object.create(null)vm._hasHookEvent = false /src/core/instance/render.js =&gt; initRender(Vue) 123456789vm._vnode = null // the root of the child treevm._staticTrees = null // v-once cached treesvm.$vnode = vm.$options._parentVnodevm.$slots = resolveSlots(options._renderChildren, renderContext)vm.$scopedSlots = emptyObjectvm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)vm.$attrs = vm.$vnode.data.attrs || emptyObjectvm.$listeners = vm.$options._parentListeners || emptyObject /src/core/instance/state.js =&gt; initState(Vue) 1vm._watchers = [] /src/core/instance/state.js =&gt; initProps() 12vm._props = &#123;&#125;vm.$options._propKeys = [] /src/core/instance/state.js =&gt; initData() 1vm._data = vm.$options.data.call(vm) || vm.$options.data /src/core/instance/inject.js =&gt; initProvide() 1vm._provided = vm.$options.provide.call(vm) || vm.$options.provide /src/core/instance/state.js =&gt; stateMixin() 12345678910111213Vue.prototype.$data = &#123; get() &#123; return this._data &#125;&#125;Vue.prototype.$props = &#123; get() &#123; return this._props &#125;&#125;Vue.prototype.$set = setVue.prototype.$delete = delVue.prototype.$watch = function ()&#123;&#125; /src/core/instance/events.js =&gt; eventsMixin(Vue) 1234Vue.prototype.$on = function () &#123;&#125;Vue.prototype.$once = function () &#123;&#125;Vue.prototype.$off = function () &#123;&#125;Vue.prototype.$emit = function () &#123;&#125; /src/core/instance/lifecycle.js =&gt; lifecycleMixin(Vue) 123Vue.prototype._update = function () &#123;&#125;Vue.prototype.$forceUpdate = function () &#123;&#125;Vue.prototype.$destroy = function () &#123;&#125; /src/core/instance/render.js =&gt; renderMixin(Vue) 1234Vue.prototype.$nextTick = function (fn: Function) &#123; return nextTick(fn, this)&#125;Vue.prototype._render = function () &#123;&#125; 最后到这里，我们就大致整理出了在初始化 Vue 时会声明的相关属性，在后面的源码阅读过程中会起到一个字典的作用。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"axios-总体结构","slug":"源码阅读/axios/总体结构","date":"2020-10-11T16:00:00.000Z","updated":"2021-08-17T06:04:10.558Z","comments":true,"path":"2020/10/12/源码阅读/axios/总体结构/","link":"","permalink":"http://yoursite.com/2020/10/12/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/","excerpt":"","text":"本文基于 axios 版本 0.21.1 入口在根目录下找到 index.js，里面只有一句代码，将 axios 进行导出。 1module.exports = require('./lib/axios'); 找到 lib 下的 axios.js 文件 首先引入了相关文件 12345678910// 工具函数库var utils = require('./utils');// bind 方法，返回 function wrapvar bind = require('./helpers/bind');// Axios 构造函数var Axios = require('./core/Axios');// 合并参数var mergeConfig = require('./core/mergeConfig');// 默认设置和属性var defaults = require('./defaults'); 创建 axios 实例的方法 12345678910function createInstance (defaultConfig) &#123; // 创建 Axios 实例 var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); utils.extend(instance, Axios.prototype, context); utils.extend(instance, context); return instance;&#125; ​bind 方法代码如下： 123456789function bind (fn, thisArg) &#123; return function wrap () &#123; var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) &#123; args[i] = arguments[i]; &#125; return fn.apply(thisArg, args); &#125;;&#125; bind 方法的逻辑很简单，就是返回 一个wrap 函数，函数内部会使用 context 调用 Axios.prototype.request。bind执行完后就将 Axios.prototype 和 context 的属性赋值给 wrap 函数。 在该文件后续部分我们可以看到以下两行代码： 123// ...var axios = createInstance(defaults);module.exports = axios; 执行 createInstance 方法返回的 instance 赋值给了 axios，那么 axios 的值就是 wrap 函数，这也就是为什么我们使用 axios 时，既可以调用它的方法，也可以直接执行它的原因。 到这里，我们明白了 axios 是什么以及如何创建它的实例。 构造函数前面的处理将 Axios 相关属性赋予给了 wrap 函数，那到底是哪些属性呢？该小节将会详细了解下构造函数 Axios。 文件位于 axios/core/Axios 首先引入所需依赖，大概知道是干什么的就行。 123456// 对请求路径进行一些格式化var buildURL = require('../helpers/buildURL');// 拦截器构造函数var InterceptorManager = require('./InterceptorManager');// 发起 request 请求var dispatchRequest = require('./dispatchRequest'); 接着往下看 12345678function Axios (instanceConfig) &#123; this.defaults = instanceConfig; // 拦截器对象 this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager() &#125;;&#125; 在创建实例时可接收一个配置参数 将接收的配置赋值给自身的 defaults 属性 拥有一个 拦截器对象，该对象包括请求拦截器和相应拦截器 拦截器实例是在创建 Axios 实例时才会创建 拦截器在日常使用中，拦截器的配置是最重要的一部分。我们通过上方路径找到拦截器构造函数文件。 ​ 构造函数拥有一个 handlers 数组，用来存储拦截器。 123function InterceptorManager () &#123; this.handlers = []; &#125; ​然后给构造函数原型添加方法函数 使用 use 方法添加一个新的拦截器， 123456789InterceptorManager.prototype.use = function use (fulfilled, rejected, options) &#123; this.handlers.push(&#123; fulfilled: fulfilled, rejected: rejected, synchronous: options ? options.synchronous : false, runWhen: options ? options.runWhen : null &#125;); return this.handlers.length - 1;&#125;; 每个拦截器包括四个属性： fulfilled：一个方法，在请求或相应被 then 处理前执行 rejected：一个方法，在请求或相应被 reject 处理前执行 synchronous：请求拦截器是否采用同步执行机制 runwhen：表明请求拦截器什么情况下执行。默认为 null，也可以是一个函数。 use 方法返回当前拦截器在拦截器数组中的位置下标 使用 eject 方法清除一个拦截器。参数 id 就是拦截器在数组中的下标。 123456InterceptorManager.prototype.eject = function eject (id) &#123; if (this.handlers[id]) &#123; // 将下标为 id 处的拦截器置为 null this.handlers[id] = null; &#125;&#125; 使用 forEach 方法执行符合条件的拦截器 12345678InterceptorManager.prototype.forEach = function forEach (fn) &#123; // 遍历拦截器存储数组，执行 fn 时会过滤掉数组中被置为 null 的值。 utils.forEach(this.handlers, function forEachHandler (h) &#123; if (h !== null) &#123; fn(h); &#125; &#125;);&#125; 挂载方法构造函数内部添加完属性后，紧接着就是在构造函数原型上添加相应方法： 123456789101112131415161718192021222324// 为 Axios 原型挂载 request 和 getUri 方法Axios.prototype.request = function request (config) &#123;...&#125;Axios.prototype.getUri = function getUri (config) &#123;...&#125;// 为 Axios 原型挂载支持的 methodutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData (method) &#123; Axios.prototype[method] = function (url, config) &#123; return this.request(mergeConfig(config || &#123;&#125;, &#123; method: method, url: url, // 使用这些 method时，有可能不会传 data 属性，所以使用默认的 data data: (config || &#123;&#125;).data &#125;)); &#125;;&#125;);utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData (method) &#123; Axios.prototype[method] = function (url, data, config) &#123; return this.request(mergeConfig(config || &#123;&#125;, &#123; method: method, url: url, data: data &#125;)); &#125;;&#125;) 其中包括 HTTP 请求同名的方法 。这些方法会被代理给原型的 request 方法，Axios 将支持的请求的 methods 按照是否需要默认 data 属性分为两类，现在来看看 request 方法的实现。 request 首先是基本参数的一个默认设置以及合并 12345678910111213141516171819// 兼容 axios('example/url'[, config]) 这种传参方式if (typeof config === 'string') &#123; config = arguments[1] || &#123;&#125;; config.url = arguments[0];&#125; else &#123; config = config || &#123;&#125;;&#125;// 合并 configconfig = mergeConfig(this.defaults, config);// 设置 config.method， 默认小写，默认 get 方法if (config.method) &#123; config.method = config.method.toLowerCase();&#125; else if (this.defaults.method) &#123; config.method = this.defaults.method.toLowerCase();&#125; else &#123; config.method = 'get';&#125; 对拦截器队列的处理 1234567891011121314151617181920212223// 请求拦截器队列var requestInterceptorChain = [];// 请求拦截器是否同步执行var synchronousRequestInterceptors = true;this.interceptors.request.forEach(function unshiftRequestInterceptors (interceptor) &#123; if (typeof interceptor.runWhen === 'function' &amp;&amp; interceptor.runWhen(config) === false) &#123; return; &#125; // 因为 interceptor.synchronous 默认为 false，所以 synchronousRequestInterceptors 默认为 false， synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous; // 每个拦截器由执行成功和执行失败处理方法组成 requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);&#125;);// 响应拦截器链var responseInterceptorChain = [];this.interceptors.response.forEach(function pushResponseInterceptors (interceptor) &#123; responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);&#125;); 请求拦截器 执行机制的处理 ​ 请求拦截器 执行机制由上面的 synchronousRequestInterceptors 决定，分为 异步和同步两种。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var promise;// 异步执行if (!synchronousRequestInterceptors) &#123; // 调用处理方法队列 var chain = [dispatchRequest, undefined]; // 将请求拦截器处理方法和响应拦截器处理方法分别放入队列前后 Array.prototype.unshift.apply(chain, requestInterceptorChain); chain.concat(responseInterceptorChain); promise = Promise.resolve(config); // 将包含了请求拦截器的 chain 交给 promise 来处理 while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift()); &#125; return promise;&#125;// 同步执行var newConfig = config;// 先一次性执行完请求拦截器while (requestInterceptorChain.length) &#123; var onFulfilled = requestInterceptorChain.shift(); var onRejected = requestInterceptorChain.shift(); try &#123; newConfig = onFulfilled(newConfig); &#125; catch (error) &#123; onRejected(error); break; &#125;&#125;try &#123; // 再异步执行 dispatchRequest（如 XHR）， promise = dispatchRequest(newConfig);&#125; catch (error) &#123; return Promise.reject(error);&#125;// 最后异步执行响应拦截器while (responseInterceptorChain.length) &#123; promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());&#125;return promise; 对拦截器处理的总结： 存在三个 chain：请求拦截器 requestInterceptorChain 、响应拦截器 responseInterceptorChain、真正的 request 调用 originChain 拦截器以成对的形式存在，放入对应的拦截器 chain 中 请求拦截器对依次插入到 chain 头；相应拦截器对依次插入到 chain 尾 请求拦截器可以同步执行也可以异步执行： 如果是异步执行，则会将requestInterceptorChain 插入到 originChain 队头，将 responseInterceptorChain 插入到 originChain 队尾；然后对 originChain 内的元素放入 promise.then 中执行 如果是同步执行，则会将 requestInterceptorChain 内的元素以迭代的方式执行完毕，然后执行 originChain 内的 request，最后将 responseInterceptorChain 内的元素放入 promise.then 中执行 最后通过一张图来理解请求拦截器处理不同的机制","categories":[{"name":"Axios","slug":"Axios","permalink":"http://yoursite.com/categories/Axios/"}],"tags":[{"name":"Axios","slug":"Axios","permalink":"http://yoursite.com/tags/Axios/"}]},{"title":"弄懂 event loop","slug":"JavaScript 异步编程/弄懂 event loop","date":"2020-10-02T16:00:00.000Z","updated":"2021-08-26T06:32:57.240Z","comments":true,"path":"2020/10/03/JavaScript 异步编程/弄懂 event loop/","link":"","permalink":"http://yoursite.com/2020/10/03/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/","excerpt":"","text":"什么是 event loop简单来说，event loop 就是 JavaScript 宿主处理事件执行的一种机制。 js 以前是专门用来处理浏览器交互的，比如说 DOM 点击事件等，因此被设计成单线程，所谓单线程，就是同一时间只能处理一件事情，这也就保证了页面中一次只能处理一个事件，避免造成交互混乱的问题。 开始之前，需要明确的是 JavaScript引擎是单线程的，但是 js 运行环境是多线程。因为浏览器是多线程的，除了 js 引擎线程，还包括 GUI 渲染线程、定时器触发线程、HTTP 请求线程以及 DOM 事件触发线程；node也可以使用 child_process 创建多个子线程。 现在有事件 A 和 B，如下： 123456789101112const A = function A() &#123; setTimeout(() =&gt; &#123; console.log('i am A'); &#125;, 2000)&#125;const B = function B() &#123; console.log('i am B');&#125;A();B(); 按照单线程的要求，需要等到 A 执行完毕，才会执行 B，那么打印顺序会是如下所示： 12console.log('i am A');console.log('i am B'); 但实际上的顺序是： 12console.log('i am B');console.log('i am A'); 这就是 event loop 机制在起作用，因为 console.log(‘i am B’) 是同步任务，而 setTimeout 是异步任务，同步任务执行完才会去执行异步任务 宏任务和微任务 什么是宏任务和微任务？ 这里有几个概念容易混淆，那就是同步任务和异步任务，宏任务和微任务。js 的代码执行遵循在代码块内从上往下执行的规则，同步任务会依次执行；而异步任务则会分为宏任务和微任务，比如 setTimeout 的第一个参数是宏任务，promise.then 中注册的方法是微任务，会按照宏任务和微任务的执行规则进行执行。 宏任务和微任务有哪些？ js 执行的宿主环境有浏览器和 Node, 所以我们通过宿主环境的不同来整理这些异步任务： 宏任务 浏览器 node setTimeout √ √ setInterval √ √ setImmediate x √ I/O √ √ requestAnimationFrame √ x 微任务 浏览器 node mutationObserver √ x promise √ √ process.nextTick x √ 宏任务和微任务的执行顺序 要点一：一个宏任务里可能会包含多个微任务 123456789101112new Promise((resolve, reject) =&gt; &#123; console.log('我是 promise 里的 同步任务') resolve('success')&#125;).then(res =&gt; &#123; console.log('我是微任务1')&#125;).then(res =&gt; &#123; console.log('我是微任务2')&#125;)setTimeout(() =&gt; &#123; console.log('我是 setTimeout 里的 宏任务')&#125;) 我们来分析下这段代码里的宏任务和微任务有哪些：宏任务：setTimeout 的回调微任务：两个 then 方法的回调 要点二：宏任务是一个一个执行的，而微任务是批量执行的，当前批次微任务没有完成之前，下一个宏任务不会执行 因此执行顺序是: 遇到 promise，参数里面的代码是同步的，所有会先执行 console.log(‘我是 promise 里的 同步任务’) 执行两个 then 方法的回调 执行 setTimeout 的回调 即： 1234// console.log('我是 promise 里的 同步任务')// console.log('我是微任务1')// console.log('我是微任务2')// console.log('我是 setTimeout 里的 宏任务') 浏览器下的 event loop 如图所示，代码执行步骤如下： js 在执行代码时，会将代码放入执行栈中，遇到同步任务，会依次执行；遇到如 DOM 点击事件、ajax 以及 定时器等异步任务，浏览器会交给其他辅线程调用 WebApis 进行处理。 如果 WebApis 处理的异步任务有了结果，就会将该任务推入到回调队列（callback queue）中，回调队列分为宏任务队列和微任务队列。 一旦执行栈内（stack）的任务执行完成，就会将回调队列里的任务放入执行栈中执行，顺序如下： 如果微任务队列中存在任务，则一次性执行所有微任务 将宏任务队列的第一个任务放入执行栈中执行 以上步骤的循环就是浏览器中的 event loop。 看一个简单例子感受下： 1234567891011setTimeout(function callback1()&#123;console.log(3)&#125;)Promise.resolve('success').then(function callback2()&#123;console.log(1);return 1&#125;).then(function callback3()&#123;console.log(2);return 2&#125;)console.log('start')// start// 1// 2// 3 遇到 setTimeout，等待时间到达后将 callback1 放入宏任务队列 遇到 promise.then，等待时间到达后将 callback2 与 callback3 按顺序放入微任务队列 执行同步任务 console.log。 执行完同步任务，将微任务队列里的任务一次性执行 微任务执行完之后，执行宏任务队列的第一个任务 node 下的 event loop123456789101112131415161718 ┌───────────────────────────┐ ┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 如上图所示，node 中的 event loop 分为6个循环阶段，当 node.js 启动的时候，会初始化 event loop timers： 这个阶段执行 setTimeout 和 setInterval 的回调函数 pending callbacks：在下一个循环中执行 I/O 回调函数 idle, prepare：只在 node 内部触发 poll：获取新的 I/O 事件，在适当的时候阻塞在这里 check：执行 setImmediate 的回调函数 close callbacks：执行关闭事件的回调函数，如 socket.on(‘close’, … ) 下面主要对 timers、poll、check 三个阶段进行解析： 一、timerstimers 阶段的回调函数可能并不会按照设定的时间延迟去执行，因为 event loop 初始化或者其他阶段回调函数的长时间执行会延迟它们的执行。 1234567891011121314151617181920const fs = require('fs');function someAsyncOperation(callback) &#123; // 假设读取文件需耗时 95ms fs.readFile('./a.txt', callback)&#125;cosnt timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);&#125;, 100)someAsyncOperation(() =&gt; &#123; const startCallbackTime = Date.now(); while (Date.now() - startCallbackTime &lt; 10) &#123; // do something &#125;&#125;) 上方示例在 node 里的大致执行步骤如下： timer 阶段：因为需要延迟 100ms，所以当前没有 callback 需要执行，进入 pending callback 阶段 pending callback阶段：没有 I/O 回调需要执行，进入 idle， idle 忽略 poll 阶段：因为此时有 I/O 操作，因此会阻塞在这里，等待95ms至文件读取结束，然后将 callback 放入队列进行执行，耗时10ms。调用结束后，当前队列为空，检查 timers，发现设定时间为95ms，当前运行时间超时了，因此进入 timer 阶段执行回调，所以会打印出”105ms has passed since I was scheduled” 二、pollpoll 阶段主要有两个功能： 1.计算它应该阻塞和轮询 I/O 多长时间 2.处理该阶段事件 当 event loop 进入 poll 阶段并且未设定定时器，会出现下面中的某个情况： 如果 poll 的队列不为空，那么就会遍历队列，并异步执行完所有回调函数，或者执行耗时达到系统设定的最大时间 如果 poll 队列为空，那以下情况中的一个会出现： 如果代码设定了 setImmediate 方法，event loop 会结束 poll 阶段，进入 check 阶段去执行 check 队列 如果没有设定 setImmediate 方法，就会阻塞在 poll 阶段，直到有 poll callback 添加到队列中，然后立刻执行。 如果 event loop 进入 poll 阶段并且设定了定时器： 一旦 poll 队列处于空闲状态，event loop 会查看 timers 里的回调函数，如果至少有一个回调函数的时间到了，event loop 会按循环顺序进入 timers 阶段去执行这些回调函数。 按循环顺序说的是 event loop 不会直接进入 timers 阶段，而是要先进入 check、close callback 之后，再进入 timers 阶段。 三、check 这个阶段用来存放 setImmediate 回调函数，如果代码中设定了，那么 event loop 不会阻塞等待在 poll 阶段，而是会进入 check 阶段。 当 poll 阶段结束，进入check 阶段后，会调用 libuv api 去执行回调函数 四、API 比较 setTimeout 和 setImmediate setTimeout 设定一个任务在等待指定时间后去执行 setImmediate 在 poll 阶段完成后立即去调用它设定的代码 它们回调函数执行的顺序依据它们执行的方式会有不同：如果它们的执行不在 I/O 操作里，那么顺序时不定的，如果在 I/O 中，永远都是 setImmediate 最先执行 process.nextTick 在技术上来说，nextTick 不属于 event loop 的一部分，凡是放进 nextTick 队列的回调函数会在下一次 event loop 循环开始前执行。需要注意的是，正是因为这个特性，如果递归调用 nextTick，会导致下一次 event loop 无法开始。 node 中宏任务和微任务因为 node 中的 宏任务分处于不同的阶段，并且微任务中的 process.nextTick 都是先于其它微任务执行，所以可以理解为 有4个宏任务队列以及2个微任务队列。 这里为了便于理解，借用一张图： 这里的宏任务和微任务流程模型与浏览器的相同，区别在于： node 中的宏任务队列执行顺序取决于 event loop 所处的阶段 微任务中，process.nextTick 独处一个队列，比其他微任务要早执行 最后event loop 相当于一个总指挥，负责 js 任务的协调与调度。 参考文献 https://juejin.cn/post/6844903670291628046#heading-5","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"Event Loop","slug":"Event-Loop","permalink":"http://yoursite.com/tags/Event-Loop/"}]},{"title":"浅析 generator 与 async 原理","slug":"JavaScript 异步编程/浅析 generator 与 async 原理","date":"2020-08-24T16:00:00.000Z","updated":"2021-08-26T08:39:36.899Z","comments":true,"path":"2020/08/25/JavaScript 异步编程/浅析 generator 与 async 原理/","link":"","permalink":"http://yoursite.com/2020/08/25/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/","excerpt":"","text":"前言geneartor 和 async 都是 js 处理异步操作发展历程的产物，它们让异步编程越来越像同步编程。但是由于采用新的语法、关键字，它们是如何做到“类同步”操作的，我们不得而知，因此这篇文章将会窥探内部的秘密。 下面将借助 babel 本地编译示例代码来进行分析。 准备步骤 一、全局安装 regenerator 1npm i regenerator -g 二、编译 generator ​ 命令加上 –include-runtime，可以得到完整的编译代码 1regenerator --include-runtime test.js &gt; test-fill.js test-fill.js 就是编译后的代码文件。 解析 generator现在有如下代码： 123456789function* genFn() &#123; let x = yield 2; let y = yield x * 2; return y;&#125;let gen = genFn();gen.next() // &#123;value: 2, done: false&#125;gen.next() // &#123;value: NaN, done: false&#125;gen.next() // &#123;value: undefined, done: true&#125; 调用 genFn 并不会直接执行，而是会返回一个 generator 对象，每次调用它的 next 方法会执行一个 yield 语句，并返回当前的值及状态。 这是编译后的代码： 12345678910111213141516171819202122232425262728var _marked = /*#__PURE__*/regeneratorRuntime.mark(genFn);function genFn () &#123; return regeneratorRuntime.wrap(function genFn$ (_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return 1; case 2: _context.next = 4; return 2; case 4: _context.next = 6; return 3; case 6: case \"end\": return _context.stop(); &#125; &#125; &#125;, _marked);&#125;var g = genFn();console.log(g.next());console.log(g.next());console.log(g.next());console.log(g.next()); 可以看到 genFn 被改写了，调用 regeneratorRuntime.wrap 方法创建，其中传给 wrap 方法的 genFn$ 函数，里面的逻辑很简单，是一个永远都会执行的迭代，里面 switch 中的 case 是原代码中 yield 关键字所在的行数，genFn$ 的参数 _context 记录了原代码的执行上下文内容，每次调用 next 方法，实际上就会调用 genFn$，然后执行对应的逻辑。 大致的流程弄清楚之后，再来看看 regeneratorRuntime。 wrap 方法第二个参是 mark(genFn) 的值， mark 方法如下： 1234567891011121314151617181920212223var $Symbol = typeof Symbol === \"function\" ? Symbol : &#123;&#125;;var iteratorSymbol = $Symbol.iterator || \"@@iterator\";var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";function GeneratorFunctionPrototype () &#123; &#125;var IteratorPrototype = &#123;&#125;;IteratorPrototype[iteratorSymbol] = function () &#123; return this;&#125;;GeneratorFunctionPrototype.prototype = Object.create(IteratorPrototype);exports.mark = function (genFun) &#123; if (Object.setPrototypeOf) &#123; Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); &#125; else &#123; genFun.__proto__ = GeneratorFunctionPrototype; define(genFun, toStringTagSymbol, \"GeneratorFunction\"); &#125; genFun.prototype = Object.create(Gp); return genFun;&#125;; IteratorPrototype 对象添加 Symbol.iterator属性，使得 IteratorPrototype 拥有 Iterator 接口 GeneratorFunctionPrototype 函数的原型指向 IteratorPrototype ，所以 GeneratorFunctionPrototype 也拥有 Iterator 接口 genFun 的 proto 指向 GeneratorFunctionPrototype ，同理 genFun 拥有 Iterator 接口 mark 返回 genFun 也就是说 mark 方法返回一个拥有 Iterator 接口 genFun。现在看下 wrap 方法。 12345678910111213141516171819function wrap (innerFn, outerFn, self, tryLocsList) &#123; // 确保 protoGenerator 拥有 Itrator 接口 var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); // context 即 genFn$ 的参数 _context var context = new Context(tryLocsList || []); // ._invoke 方法整合了 next、throw 和 return 方法 generator._invoke = makeInvokeMethod(innerFn, self, context); return generator;&#125;// _invoke 即内部的 invokefunction makeInvokeMethod (innerFn, self, context) &#123; return function invoke (method, arg) &#123; // ... &#125;;&#125; 先看看 _invoke 在哪儿调用 123456789101112var Gp = GeneratorFunctionPrototype.prototype = Generator.prototypedefineIteratorMethods(Gp);// 为 Generator 添加 prototype 添加 next、throw、return 方法// 并且这些方法都会调用 _invoke 方法function defineIteratorMethods (prototype) &#123; [\"next\", \"throw\", \"return\"].forEach(function (method) &#123; define(prototype, method, function (arg) &#123; return this._invoke(method, arg); &#125;); &#125;);&#125; 这些弄明白之后，可以简单理一下编译后代码的执行步骤： var g = genFn(); genFn() 返回 generator 对象，拥有 _invoke 方法 g 拥有 _invoke g.next(); g 的 next 方法会调用 _invoke 方法 g.next() ==&gt; g._invoke(); 到这里就可以去看看 invoke 是如何实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 四种状态：开始、执行中、暂停执行、结束var GenStateSuspendedStart = \"suspendedStart\";var GenStateExecuting = \"executing\";var GenStateSuspendedYield = \"suspendedYield\";var GenStateCompleted = \"completed\";// generator 方法执行的状态var state = GenStateSuspendedStart;return function invoke (method, arg) &#123; // 方法体内的语句执行过程中不允许继续执行 if (state === GenStateExecuting) &#123; throw new Error(\"Generator is already running\"); &#125; if (state === GenStateCompleted) &#123; if (method === \"throw\") &#123; throw arg; &#125; &#125; context.method = method; context.arg = arg; while (true) &#123; // 省略容错逻辑 state = GenStateExecuting; // fn.call(obj, arg) // fn 即 genFn$，arg 即为 context //function tryCatch (fn, obj, arg) &#123; // try &#123; // return &#123; type: \"normal\", arg: fn.call(obj, arg) &#125;; // &#125; catch (err) &#123; // return &#123; type: \"throw\", arg: err &#125;; // &#125; //&#125; // 在这里调用 genFn$ 方法 var record = tryCatch(innerFn, self, context); if (record.type === \"normal\") &#123; // 执行 genFn$ 成功会走如下逻辑 // 如果语句执行完毕则结束执行，否则暂停执行 state = context.done ? GenStateCompleted : GenStateSuspendedYield; // 返回执行 yield 的结果 return &#123; value: record.arg, done: context.done &#125;; &#125; else if (record.type === \"throw\") &#123; // 遇到错误则将方法改为 throw，进入下一个循环执行容错逻辑 state = GenStateCompleted; context.method = \"throw\"; context.arg = record.arg; &#125; &#125;&#125;; invoke 通过调用的方法进行不同的操作。遇到 throw 直接 throw 错误；遇到 return 会去 complete generator；遇到 next，就会调用 genFn$ 方法，最终返回一个 value 和 done 属性的对象。 解析 async对于 async 函数，依然使用上面的方法进行编译处理。async 编译后的代码与 generator 编译后的 regeneratorRuntime 对象是一样的，因此我们只需要关注不同点就可以了。 编译前 12345678910111213141516const p = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2) &#125;, 1000)&#125;)async function asyncFn() &#123; let a = await p(); let b = await 1; let c = await 1; console.log(a) console.log(b) console.log(c)&#125;asyncFn();// 2 1 1 编译后 1234567891011121314151617181920212223242526272829303132333435363738var p = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(2); &#125;, 1000); &#125;);&#125;;function asyncFn () &#123; var a, b, c; return regeneratorRuntime.async(function asyncFn$ (_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return regeneratorRuntime.awrap(p()); case 2: a = _context.sent; _context.next = 5; return regeneratorRuntime.awrap(1); case 5: b = _context.sent; _context.next = 8; return regeneratorRuntime.awrap(1); case 8: c = _context.sent; console.log(a); console.log(b); console.log(c); case 12: case \"end\": return _context.stop(); &#125; &#125; &#125;, null, null, null, Promise);&#125;asyncFn(); 与 generator 编译之后的代码基本相同，不同的是 调用的是 regeneratorRuntime.async 方法，接收4个参，其中最后一个是 Promise 内部方法 return regeneratorRuntime.awrap, 即将 await xx 改为 regeneratorRuntime.awrap(xx) 按照顺序，先来看看 async 方法。 12345678910111213141516exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) &#123; // 确保 PromiseImpl 是 Promise if (PromiseImpl === void 0) PromiseImpl = Promise; var iter = new AsyncIterator( // wrap 方法返回一个 generator 对象 wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl ); // iter.next() 是一个 promise 对象 return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) &#123; return result.done ? result.value : iter.next(); &#125;);&#125;; new AsyncIterator 内部做了些什么工作呢？简化之后就很明了。 123456789101112131415function AsyncIterator (generator, PromiseImpl) &#123; function invoke (method, arg, resolve, reject) &#123;&#125; function enqueue (method, arg) &#123; function callInvokeWithMethodAndArg () &#123; // 返回 promise 实例 return new PromiseImpl(function (resolve, reject) &#123; invoke(method, arg, resolve, reject); &#125;); &#125; var previousPromise; return previousPromise = callInvokeWithMethodAndArg(); &#125; this._invoke = enqueue;&#125; defineIteratorMethods 方法将 next(还有 throw、return) 方法代理给了 _invoke，所以 iter.next() 会调用_invoke，即 enqueue，而 enqueue 返回一个 promise 实例，因此可以调用 then 方法。 123iter.next().then(function (result) &#123; return result.done ? result.value : iter.next();&#125;) 这段是控制 await 顺序执行的开始和结束 首先执行 iter.next()，相当于执行 enqueue，进而执行 invoke。 12345678910111213141516171819202122232425function invoke (method, arg, resolve, reject) &#123; var record = tryCatch(generator[method], generator, arg); if (record.type === \"throw\") &#123; reject(record.arg); &#125; else &#123; var result = record.arg; var value = result.value; if (value &amp;&amp; typeof value === \"object\" &amp;&amp; hasOwn.call(value, \"__await\")) &#123; return PromiseImpl.resolve(value.__await).then(function (value) &#123; invoke(\"next\", value, resolve, reject); &#125;, function (err) &#123; invoke(\"throw\", err, resolve, reject); &#125;); &#125; return PromiseImpl.resolve(value).then(function (unwrapped) &#123; result.value = unwrapped; resolve(result); &#125;, function (error) &#123; return invoke(\"throw\", error, resolve, reject); &#125;); &#125;&#125; 执行步骤如下： var record = tryCatch(generator[method], generator, arg); 因为 generator[method] 代理给了 _invoke。因此会执行 return { type: “normal”, arg: fn.call(obj, arg) };所以这里的_invoke 是 generator 的 _invoke，而不是 iter 的_invoke。 接下来执行 _invoke 的步骤与 generator 函数一样，执行被包裹的函数，最终会返回 {value: xx, done: xx} 对象，但不一样的是，如果函数体没有执行完毕之前，value 是一个对象，有一个 __await 属性。 如果 tryCatch 执行失败，则直接 reject。 如果执行成功： 如果函数体内的 await 还未执行结束，则会将 record.value.__await 值当作参数，递归调用 invoke 方法 如果函数体执行完毕，此时的 value 是 undefined，将 record 用异步的方式返回，就会执行 iter.next() 的 then 方法内的回调，这里就是直接执行 return result.value。 因此 async 默认返回 undefined。 到这里，我们就简单理解了 generator 和 async 函数内部的工作原理。其中，async 是在 generator 的基础上工作的，它使用递归方式取代多个 next 方法调用。 奉上一张编译后代码中方法调用的简图以作参考。 实现一个简版 async通过上面的分析，我们可以知道，async 就是一个不需要手动执行 next 方法的 generator，明白了这点就好动手了。 先上一个示例 1234567891011121314151617181920212223242526272829303132function fakeReadFile (filename, duration) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(filename) resolve(filename) &#125;, duration) &#125;)&#125;function* genFn () &#123; yield fakeReadFile('a.txt', 5000); yield fakeReadFile('b.txt', 3000); yield 3; yield 4; yield 5;&#125;let g = genFn();console.log(g.next())console.log(g.next())console.log(g.next())console.log(g.next())console.log(g.next())console.log(g.next())// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;// &#123; value: 3, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: 5, done: false &#125;// &#123; value: undefined, done: true &#125;// b.txt 3秒后输出// a.txt 5秒后输出 如上例所示，在实现 async 有2个问题需要解决： 如何保证异步代码按调用顺序去执行（异步代码默认使用 promise 包裹） 如何自动调用 next 先来实现自动调用，首先想到的是声明一个方法，在里面去执行 next 方法，然后递归调用。 1234567891011121314151617181920212223242526272829303132function asyncFn (genFn) &#123; function invokeNext (generator) &#123; // 在这里执行 next 方法 let result = generator.next(); // 如果调用结束就不再继续调用 if (result.done === true) &#123; return; &#125; invokeNext(generator) &#125; // 获取遍历器对象 let g = genFn.call(null); invokeNext(g)&#125;// 测试一下function* genFn_ () &#123; yield 1; yield 2; yield 3; yield 4; yield 5;&#125;// 无异步代码可以按顺序执行// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 3, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: 5, done: false &#125;// &#123; value: undefined, done: true &#125;// 对于前面异步代码的执行就会出先问题 js 处理异步操作有多种方式，除了 generator 和 async，我们还有 promise，所以考虑用 promise 来管理每个 next 的调用顺序，事情就变得简单了，完整代码如下： 1234567891011121314151617181920212223242526function asyncFn (genFn) &#123; function invokeNext (generator) &#123; return new Promise((resolve, reject) =&gt; &#123; let value = generator.next(); resolve(value) &#125;).then((result) =&gt; &#123; console.log(result); if (result.done === true) &#123; return; &#125; // 如果是 promise 对象，则需要在 then 方法回调里去调用下一个 next if (result.value instanceof Promise) &#123; result.value.then(() =&gt; &#123; invokeNext(generator) &#125;) &#125; else &#123; invokeNext(generator) &#125; &#125;, err =&gt; &#123; reject(err); &#125;) &#125; const g = genFn.call(null); invokeNext(g)&#125;","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"Generator","slug":"Generator","permalink":"http://yoursite.com/tags/Generator/"},{"name":"Async","slug":"Async","permalink":"http://yoursite.com/tags/Async/"}]},{"title":"跟着规范实现一个功能完备的Promise","slug":"JavaScript 异步编程/跟着规范实现一个功能完备的Promise","date":"2020-08-17T16:00:00.000Z","updated":"2021-08-26T06:32:36.930Z","comments":true,"path":"2020/08/18/JavaScript 异步编程/跟着规范实现一个功能完备的Promise/","link":"","permalink":"http://yoursite.com/2020/08/18/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/","excerpt":"","text":"一直以来，对于 promise，只知道如何使用，其内部的运作机制却不得而知。本着知其然，知其所以然（为了让自己用得安心）的理念，决定跟着规范去了解底层的原理，并手写一个功能完备的 MyPromise. 术语 promise 是一个对象或者函数，拥有 then 方法 thenable 可以理解为一个拥有 then 方法的对象或函数 value 是一个合法的 JavaScript值 reason 用来表示 promise 拒绝的原因 特点 promise 初始状态为 pending，可以转变成 fulfilled 或者 rejected 如果状态是 fulfilled，则不能转变为 rejected 或者 pending。rejected 同理。 实现下面开始尝试第一版： 平时都是通过 new 来创建一个 promise 实例： 1234const p = new Promise((resolve, reject) =&gt; &#123; // do something resolve('xxx')&#125;) 于是首先创建一个 promise 构造函数，接收一个方法 executor 作为参数, 在内部直接执行，并且传入两个方法以供使用者使用。 123456function MyPromise(executor) &#123; const resolve = () =&gt; &#123;&#125; const reject = () =&gt; &#123;&#125; executor(resolve, reject);&#125; 如果调用 resolve 方法，会将 Promise实例 状态转变成 fulfilled，如果调用 reject 方法，则会将 Promise 实例状态转变成 rejected。所以接下来给 MyPromise 构造函数添加相应属性，并实现 resolve 和 reject。 12345678910111213141516171819202122function MyPromise(executor) &#123; this.status = 'pending'; this.value = null; this.reason = null; const resolve = (value) =&gt; &#123; // 只有处于 pending 状态，才能发生状态改变 if (this.status === 'pending') &#123; this.status = 'fulfilled'; this.value = value; &#125; &#125; const reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; this.reason = reason; &#125; &#125; executor(resolve, reject);&#125; 构造函数建造完毕，现在来处理最主要的部分 then 方法，这也是规范给出详细标准的一部分。 123456789101112131415// 可以接收两个方法作为参数, 在内部可以根据 MyPromise 实例的状态进行相应的操作MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; &#125; if (this.status === 'fulfilled') &#123; &#125; if (this.status === 'rejected') &#123; &#125;&#125; 当 then 执行的时候，如果 status 是 fulfilled 或者 rejected 状态，可以直接执行 onFulfilled 或者 onRejected 方法，但如果依然还是 pending，需要将这些执行操作放入等待区，也就是存入到回调队列中，如下： 123456789101112131415161718MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; this.onFulfilledStack.push(() =&gt; &#123; onFulfilled(this.value); &#125;) this.onRejectedStack.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; if (this.status === 'fulfilled') &#123; onFulfilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason) &#125;&#125; 那么现在，待执行栈已经存在了状态改变的回调，需要在合适的时机去执行，所以需要完善 resolve 和 reject 方法。一旦状态改变，则将带执行栈中的回调全部执行。 12345678910111213141516const resolve = (value) =&gt; &#123; this.status = 'fulfilled'; this.value = value; // 执行回调 while (this.onFulfilledStack.length &gt; 0) &#123; this.onFulfilledStack.shift()(this.value); &#125;&#125;const reject = (reason) =&gt; &#123; this.status = 'rejected'; this.reason = reason; // 执行回调 while (this.onRejectedStack.length &gt; 0) &#123; this.onRejectedStack.shift()(this.reason); &#125;&#125; 我们都知道then 方法必须返回一个 promise，因此需要对 then 方法进一步改造： 123456MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; // ... return new Promise((resolve, reject) =&gt; &#123; &#125;)&#125; 到这里就要思考一下，then 方法为什么要返回一个 promise？ 原因是每一个 promise 都会有一个 then 方法，而如果 then 方法也返回一个 promise，那么这个 then 也会有一个 then 方法，于是可以像下方代码一样链式调用 ： 123new MyPromise((resolve, reject) =&gt; &#123; resolve('success')&#125;).then().then() 但还有个原因。我们不仅可以像上方一样 resolve 一个基本值，也可以 resolve 一个 promise，如下方例子： 1234567new MyPromise((resolve, reject) =&gt; &#123; resolve(new MyPromise((_resolve, _reject) =&gt; &#123; setTimeout(() =&gt; &#123; _resolve('success') &#125;, 2000) &#125;))&#125;).then().then() 因为被 resolve 的 promise 的状态是尚未改变的，因此可以将这个 promise 放进 then 返回的这个 promise 内去等待状态改变，所以这一步我们将 then 方法内原先的处理逻辑挪到这个返回的 promise 内部。 1234567891011121314151617181920212223MyPromsise.prototype.then = function(onFulfilled, onRejected) &#123; let _promise = null; return _promise = new MyPromise((resolve, reject) =&gt; &#123; // 因为 onFulfilled(this.value) 和 onRejected(this.reason) 可能返回一个 thenable，因此需要将下方代码移入新 promise内部去执行 if (this.status === 'pending') &#123; this.onFulfilledStack.push(() =&gt; &#123; onFulfilled(this.value); &#125;) this.onRejectedStack.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; if (this.status === 'fulfilled') &#123; onFulfilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason) &#125; &#125;) &#125; 有个问题，我们在内部直接调用 onFulfilled 和 onRejected，但却没有对这两个方法类型进行错误处理，也就是必须保证它们是 function。 123456MyPromsise.prototype.then = function(onFulfilled, onRejected) &#123; // 设置默认的回调方法（需原样返回传进来的值或者抛出同样的值），可以保证 promise 结果能够透传 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123; throw reason &#125; // ...&#125; 这里有一个处理，如果 onFulfilled 和 onRejected 不是 function，那么就将它们赋值成方法，并且将接收到的值进行相应处理：如果是 onFulfilled，直接将值 return，如果是 onRejected, 主动抛出一个错误。这也就实现了 promise 值的透传 12345new MyPromise((resolve, reject) =&gt; &#123; resolve('success')&#125;).then().then((value) =&gt; &#123; console.log(value) // success&#125;) 目前为止，MyPromise 已经具备了可实例化，可执行同步任务的功能。但还无法执行异步任务。 规范2.2.4： onFulfilled or onRejected must not be called until the execution context stack contains only platform code。 意思是：onFulfilled 和 onRejected 方法需要异步执行。 接下来对 then 方法进行进一步完善, 将它们的执行丢到异步环境中 1234567891011121314151617181920212223242526272829MyPromsise.prototype.then = function(onFulfilled, onRejected) &#123; // ... let _promise = null; return _promise = new MyPromise((resolve, reject) =&gt; &#123; if (this.status === 'pending') &#123; setTimeout(() =&gt; &#123; this.onFulfilledStack.push(() =&gt; &#123; onFulfilled(this.value); &#125;) this.onRejectedStack.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125;) &#125; if (this.status === 'fulfilled') &#123; setTimeout(() =&gt; &#123; onFulfilled(this.value); &#125;) &#125; if (this.status === 'rejected') &#123; setTimeout(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; &#125;) &#125; 规范2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x) 意思是： 对 onFulfilled 或者 onRejected 返回的值 x 进行 resolvePromise 操作，即需要将 x 当作一个 thenable 来对待，then 返回的 promise 的 状态需要 x 的状态来决定。 这里需要注意： resolvePromise 需要 promise2（即 then 返回的 promise） 和 x 这两个参，但是 promise2 的状态需要它自身 resolve 和 reject 去改变，因此将 resolve 和 reject 也带上。 改动如下： 12345678910111213141516171819202122232425262728if (this.status === 'pending') &#123; this.onFulfilledStack.push(() =&gt; &#123; setTimeout(() =&gt; &#123; let x = onFulfilled(this.value); resolvePromise(_promise, x, resolve, reject) &#125;) &#125;) this.onRejectedStack.push(() =&gt; &#123; setTimeout(() =&gt; &#123; let x = onRejected(this.reason); resolvePromise(_promise, x, resolve, reject) &#125;) &#125;)&#125;if (this.status === 'fulfilled') &#123; setTimeout(() =&gt; &#123; let x = onFulfilled(this.value); resolvePromise(_promise, x, resolve, reject) &#125;)&#125;if (this.status === 'rejected') &#123; setTimeout(() =&gt; &#123; let x = onRejected(this.reason); resolvePromise(_promise, x, resolve, reject) &#125;)&#125; 接下来就是实现 resolvePromise 方法了。 按照规范 2.3 The Promise Resolution Procedure，一步步实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function resolvePromise(_promise, x, resolve, reject)&#123; // 2.3.1 如果 _promise 和 x 是同一个对象，reject TypeError if (x === _promise) &#123; return reject(new TypeError(`$&#123;x&#125; should no refer to the same object with MyPromise`)) &#125; // 当 x 是对象或者函数时： // 判断 x.then 方法中 onFulfilled 回调或者 onRejecetd 回调是否执行过 // 因为规范规定：其中每一个回调只能执行一次 // 当其中某项执行过，就将 hasCalled 置为 true let hasCalled = false; if (x instanceof MyPromsie) &#123; // 如果状态没有改变，则需要调用 then 方法，然后在内部还需要对以后的返回值进行 resolvePromise if (x.status === 'pending') &#123; x.then(y =&gt; &#123; resolvePromise(_promise, y, resolve, reject) &#125;, err =&gt; &#123; resolvePromise(_promise, err, resolve, reject) &#125;) &#125; else &#123; // 如果状态已经改变，那么 x 就会有一个正常值，假设为 z // 执行 x.then(resolve, reject)，会直接调用 resolve(z) 或者 reject(z) ： // 2.3.2.2 &amp;&amp; 2.3.2.3 x.then(resolve, reject); &#125; &#125; else if (Object.prototype.toString.call(x) === '[object Object]' || typeof x === 'function') &#123; // x 是对象或者函数 try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call(x, y =&gt; &#123; if (hasCalled) &#123; return &#125; hasCalled = true; resolvePromise(_promise, y, resolve, reject) &#125;, err =&gt; &#123; if (hasCalled) &#123; return &#125; hasCalled = true; reject(err); &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch(err) &#123; // 2.3.3.3.4.1 // if resolvePromise or rejectPromise have been called, ignore it. if (!hasCalled) &#123; reject(err) &#125; &#125; &#125; else &#123; // 2.3.4 resolve(x); &#125;&#125; 如果能通过 promiseA+ 测试，说明该版本的 Promise 符合规范，但是还缺少常用的功能，继续完善： MyPromise.resolve 接收一个值，在内部创建一个新的实例，将状态交给新实例去处理 12345MyPromise.prototype.resolve = function(value) &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(value) &#125;)&#125; MyPromise.catch 接收一个方法，只会在 rejected 状态下执行 123MyPromise.prototype.catch = function (callback) &#123; return this.then(null, callback);&#125; MyPromise.finally 接收一个方法，不论 fulfilled 或者 rejected 都会执行 123MyPromise.prototype.finally = function (callback) &#123; return this.then(callback, callback);&#125; MyPromise.all 接收一个数组，只有所有项的状态为 fulfilled，最终结果才为 fulfilled，如果有一个 rejected，那么结果就是 rejected 123456789101112131415161718MyPromise.prototype.all = function (promiseArr) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let result = []; let resolveCount = 0; promiseArr.forEach((currentPromise, index) =&gt; &#123; currentPromise.then(value =&gt; &#123; result[index] = value; resolveCount++; if (resolveCount === promiseArr.length) &#123; resolve(result); &#125; &#125;, err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; MyPromise.race 接收一个数组，结果由第一个状态改变的 thenable 决定 1234567891011MyPromise.prototype.race = function (promiseArr) &#123; return new MyPromise((resolve, reject) =&gt; &#123; promiseArr.forEach((currentPromise, index) =&gt; &#123; currentPromise.then(value =&gt; &#123; resolve(value); &#125;, err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; MyPromise.allSettled 接收一个数组，只有等到所有项的状态都改变了，不论是 fulfilled 还是 rejected，都只会变成 fulfilled 123456789101112131415161718MyPromise.prototype.allSettled = function(promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; let resultArr = []; promiseArr.forEach(currentPromise =&gt; &#123; currentPromise.then(value =&gt; &#123; resultArr.push(&#123;status: 'fulfilled', value: value&#125;); if (resultArr.length === promiseArr.length) &#123; resolve(resultArr); &#125; &#125;, err =&gt; &#123; resultArr.push(&#123;status: 'rejected', reason: err&#125;); if (resultArr.length === promiseArr.length) &#123; resolve(resultArr); &#125; &#125;) &#125;) &#125;)&#125; MyPromise.any 接收一个数组，如果其中有一项的状态为 fulfilled， 那么结果就是 fulfilled，否则如果所有都是 rejected，那结果就是 rejected， 并且 reanson 是 ‘AggregateError: All promises were rejected’ 123456789101112131415MyPromise.prototype.any = function(promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; let rejectCount = 0; promiseArr.forEach(currentPromise =&gt; &#123; currentPromise.then(value =&gt; &#123; resolve(value); &#125;, err =&gt; &#123; rejectCount ++; if (rejectCount === promiseArr.length) &#123; reject('AggregateError: All promises were rejected'); &#125; &#125;) &#125;) &#125;)&#125; 测试方法： #安装 promises-aplus-tests 1npm i promises-aplus-tests -g #在代码里加上这段 12345678MyPromise.deferred = function () &#123; const defer = &#123;&#125;; defer.promise = new MyPromise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125; 最后1promises-aplus-tests promise.js 有一点需要注意：我在实现 promise 内部异步执行时采用的是 setTimeout，而 promise 的 then 方法是一个微任务这与实际有出入。不过用于理解其中的异步理念已经足够了。追求完美的同学可自行实现不同的版本。 完整代码地址：https://github.com/yuwengCipher/MyPromise","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"}]},{"title":"说说 js 的异步处理机制","slug":"JavaScript 异步编程/说说 js 的异步处理机制","date":"2020-06-12T16:00:00.000Z","updated":"2021-08-26T06:33:14.835Z","comments":true,"path":"2020/06/13/JavaScript 异步编程/说说 js 的异步处理机制/","link":"","permalink":"http://yoursite.com/2020/06/13/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"什么是异步在 JavaScript 中和生活中都会有异步任务的存在，而异步的产生是有前提条件的，那就是这个任务可以被拆解成两部分。 举个简单的例子。周末我想喝点排骨汤，把所有步骤都准备好后开火炖。正常来说，这锅汤需要3小时才能煲好，很显然我不会傻傻守在这儿等它3小时，因为我还有别的事要做，比如说看电视，嗑瓜子等等。而是3小时后汤煲好了，我才回去盛起来喝。 所以这个喝汤任务由两个步骤组成：煲汤 + 喝汤；这个喝汤步骤就是异步的 设计成异步的原因从上面可以知道，如果我傻傻的在锅前等3个小时，那么我看电视、嗑瓜子等事情就得向后延3小时，到最后我这一天做不了什么，所以傻等3小时完全是浪费时间。 js 是单线程，同一时间只能做一件事，长时间的等待势必会造成资源的浪费 异步实现方案 回调函数 回调函数在 js 代码里随处可见，如给 DOM 添加点击事件 12345let d = document.getElementId('test');d.addEventListener('click', function callback(e) &#123; // do something&#125;)// callback 就是回调函数 node 里去读取一份文件 123fs.readFile('./test.text', function callback(err, data)&#123; // do something&#125;) 但是有时候的需求会比较复杂，加入多个任务存在依赖性，就会写出如下代码： 1234567fs.readFile('./test.text', function callback(err, data)&#123; fs.readFile('./test1.text', function callback1(err, data)&#123; fs.readFile('./test2.text', function callback2(err, data)&#123; // ... &#125;) &#125;)&#125;) 深层嵌套让我们很是绝望！ promise 幸运的是后来有了 promise，带我们逃离了“回调地狱”，来到新世界： 1234567891011121314151617new Promise((resolve, reject) =&gt; &#123; fs.readFile('./test.text', function callback(err, data)&#123; resolve(data); &#125;)&#125;).then(data =&gt; &#123; fs.readFile('./test.text1', function callback1(err, data1)&#123; // do something resolve(data1); &#125;)&#125;).then(data =&gt; &#123; fs.readFile('./test.text1', function callback2(err, data2)&#123; // do something resolve(data2); &#125;)&#125;) 这样写之后是不是看起来清爽了，瞬间头也不晕了，promise 让流程执行的过程更清晰！ 但是你一定见过这样的代码： 123456789101112131415161718new Promise((resolve, reject) =&gt; &#123; fs.readFile('./test.text', function callback(err, data)&#123; resolve(data); &#125;)&#125;).then(data =&gt; &#123; // do something&#125;).then(data =&gt; &#123; // do something&#125;).then(data =&gt; &#123; // do something&#125;).then(data =&gt; &#123; // do something&#125;)... 真的是链式调用一时爽，一直链式调用… 就有点难受了。 promise 抑制了回调地狱的横向扩张，却发现自己的纵向扩张也很厉害。 generator generator 函数与普通的函数不同，函数内的代码可以分段执行，也就是说可以暂停执行，凡是需要暂停的地方用 yield 关键字注明。具体用法参考阮老师文章的介绍 http://www.ruanyifeng.com/blog/2015/04/generator.html 123456789function* genFn() &#123; let x = yield 2; let y = yield x * 2; return y;&#125;let gen = genFn();gen.next() // &#123;value: 2, done: false&#125;gen.next() // &#123;value: NaN, done: false&#125;gen.next() // &#123;value: undefined, done: true&#125; 于是对于上面依次读取文件的例子可以改写成如下形式： 12345678910111213141516171819202122// 模拟文件请求function fakeReadFile(filename, duration) &#123; setTimeout(() =&gt; &#123; console.log(filename) // 这里需要主动调用迭代器对象的 next 方法 gen.next(filename) &#125;, duration)&#125;function* genFn() &#123; // 顺序请求三个文件，期望的是顺序打印出结果 yield fakeReadFile('a.txt', 5000); yield fakeReadFile('b.txt', 3000); yield fakeReadFile('c.txt', 1000);&#125;const gen = genFn();gen.next();// a.txt 5秒后打印// b.txt 8秒后打印// c.txt 9秒后打印 虽然获取文件所需时长 a &gt; b &gt; c, 但是打印的结果却是 a，b，c，也就是说在 generator 函数内，yield 是按上到下执行的，使得代码执行顺序更清晰明了。 可以看到我需要在文件请求完成之后手动调用 next 方法，因此在实际工作中，我们通常需要将 generator 函数包裹在一个函数内： 12345678910111213141516171819function callGen() &#123; function* genFn() &#123; yield fakeReadFile('a.txt', 5000, gen); yield fakeReadFile('b.txt', 3000, gen); yield fakeReadFile('c.txt', 1000, gen); &#125; const gen = genFn(); gen.next();&#125;function fakeReadFile(filename, duration, g) &#123; setTimeout(() =&gt; &#123; console.log(filename) // 这里需要主动调用迭代器对象的 next 方法 g.next(filename) &#125;, duration)&#125;callGen(); 总的来说，generator 函数改善了 promise 的 then “链条”过长的缺点，但是需要额外创建一个函数来包装。 async await 作为 ES7 提出的 async 函数，在 generator 基础上进行优化，是目前 js 处理异步操作的最优解决方案，让异步处理代码可读性更强，流程控制更方便。 我们按照 async 方法的用法来继续优化上面的例子： 123456789101112131415161718192021222324function fakeReadFile(filename, duration, g) &#123; // 因为 await 关键字后面需要接收一个 promise return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(filename) &#125;, duration) &#125;)&#125;async function asyncFn() &#123; let a = await fakeReadFile('a.txt', 5000); let b = await fakeReadFile('b.txt', 3000); let c = await fakeReadFile('c.txt', 1000); console.log(a) console.log(b) console.log(c)&#125;asyncFn();// 9秒后一次性打印// a.txt // b.txt // c.txt 需要注意的是如果 await 后面表达式里包含异步操作但返回的不是 promise，那么就就不会等待到结果返回，比如这样修改： 123456789101112131415161718192021222324252627function fakeReadFile(filename, duration, g) &#123; if (filename === 'a.txt') &#123; setTimeout(() =&gt; &#123; return filename &#125;, duration) &#125; else &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(filename) &#125;, duration) &#125;) &#125;&#125;async function asyncFn() &#123; let a = await fakeReadFile('a.txt', 5000); console.log(a) let b = await fakeReadFile('b.txt', 3000); let c = await fakeReadFile('c.txt', 1000); console.log(b) console.log(c)&#125;asyncFn();// undefined 立刻输出// b.txt 4秒之后输出// c.txt 4秒之后输出 也就是说第一个 await 没有阻塞 console.log(a) 的执行。因此 async 对 await 后面的表达式又两种处理方式： 12341. promise async 会执行表达式并等待有返回值才会继续往下执行代码2. 非 promise async 执行表达式并立刻获取返回值，如果没有则为 undefined 最后js 处理异步的方法经历了 回调函数、promise、generator、async 这四个阶段，每一种新方法都是对前方法的改善，主要处理的点有两点： 可读性更强 流程控制更清晰","categories":[{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"异步处理","slug":"异步处理","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"}]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Axios","slug":"Axios","permalink":"http://yoursite.com/categories/Axios/"},{"name":"JS","slug":"JS","permalink":"http://yoursite.com/categories/JS/"}],"tags":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"Axios","slug":"Axios","permalink":"http://yoursite.com/tags/Axios/"},{"name":"Event Loop","slug":"Event-Loop","permalink":"http://yoursite.com/tags/Event-Loop/"},{"name":"Generator","slug":"Generator","permalink":"http://yoursite.com/tags/Generator/"},{"name":"Async","slug":"Async","permalink":"http://yoursite.com/tags/Async/"},{"name":"Promise","slug":"Promise","permalink":"http://yoursite.com/tags/Promise/"},{"name":"异步处理","slug":"异步处理","permalink":"http://yoursite.com/tags/%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86/"}]}