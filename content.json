{"meta":{"title":"Cipher","subtitle":"","description":"","author":"cipher","url":"http://yoursite.com","root":"/"},"pages":[{"title":"about","date":"2020-05-16T01:28:06.000Z","updated":"2020-05-16T01:29:30.109Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-05-16T01:28:06.000Z","updated":"2021-04-29T23:45:42.072Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"README","slug":"README","date":"2021-06-28T02:59:24.420Z","updated":"2021-06-28T03:17:22.782Z","comments":true,"path":"2021/06/28/README/","link":"","permalink":"http://yoursite.com/2021/06/28/README/","excerpt":"","text":"这是我的 blog 源码可以访问 https://djacipher.cn/","categories":[],"tags":[]},{"title":"带着问题读源码/vue2/总体结构(二)","slug":"带着问题读源码/vue2/总体结构(二)","date":"2021-06-25T07:36:49.902Z","updated":"2021-07-01T01:48:24.651Z","comments":true,"path":"2021/06/25/带着问题读源码/vue2/总体结构(二)/","link":"","permalink":"http://yoursite.com/2021/06/25/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%BA%8C)/","excerpt":"","text":"前言前一小节，我们整理了 Vue 相关的属性，这一小节则通过框架自带的 demo 来梳理一下 Vue 整体的一个运行流程。 正文首先我们找到本节 demo 目录，路径为 ‘/examples/commits’。将 index.html 中 vue 的引用路径改成 ‘‘, 方便调试。 app.js 里调用了 Vue 构造函数，所以从这里开始吧。 12345678910111213new Vue(&#123; el: '#demo', data: &#123; branches: ['master', 'dev'], currentBranch: 'master', commits: null &#125;, created: function () &#123; this.fetchData() &#125;, watch: &#123; currentBranch: 'fetchData' &#125;, new Vue() 之前做了什么Vue 本身会进行一系列的初始化工作 /src/core/instance/index.js 12345initMixin(Vue);stateMixin(Vue);eventsMixin(Vue);lifecycleMixin(Vue);renderMixin(Vue); /src/core/index.js 12345678910111213141516initGlobalAPI(Vue);Object.defineProperty(Vue.prototype, \"$isServer\", &#123; get: isServerRendering,&#125;);Object.defineProperty(Vue.prototype, \"$ssrContext\", &#123; get() &#123; return this.$vnode &amp;&amp; this.$vnode.ssrContext; &#125;,&#125;);Object.defineProperty(Vue, \"FunctionalRenderContext\", &#123; value: FunctionalRenderContext,&#125;);Vue.version = \"__VERSION__\"; /src/core/global-api.js 1234initUse(Vue);initMixin(Vue);initExtend(Vue);initAssetRegisters(Vue); new Vue() 做了什么new Vue() 实际上调用了自身的 _init 方法，从字典可知， _init 方法 在 ‘/src/core/instance/init.js’ 中的 initMixin 方法里。忽略部分代码后是这样的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445let uid = 0;Vue.prototype._init = function (options?: Object) &#123; const vm: Component = this; // a uid vm._uid = uid++; // 这个标识可以避免 vm 被观察系统观察 vm._isVue = true; // 将通过自定义策略合并配置项后的值赋值给 $options vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm ); if (process.env.NODE_ENV !== \"production\") &#123; // 如果不是生产环境就初始化代理相关操作 initProxy(vm); &#125; else &#123; vm._renderProxy = vm; &#125; vm._self = vm; // 初始化声明周期 initLifecycle(vm); // 初始化事件机制 initEvents(vm); // 初始化渲染相关 initRender(vm); // 调用 beforeCreate 钩子 callHook(vm, \"beforeCreate\"); // 在 data 或 props 被处理前初始化注入 initInjections(vm); // resolve injections before data/props // 初始化对 data 和 props 相关操作 initState(vm); // 在 data 或 props 被处理后初始化注入 initProvide(vm); // resolve provide after data/props // 调用 created 钩子 callHook(vm, \"created\"); // 如果存在 el 属性，则进行挂载操作 if (vm.$options.el) &#123; vm.$mount(vm.$options.el); &#125;&#125;; 从上可知，_init 方法主要做了如下几件事： 为 Vue 实例添加 $options 属性 初始化相关属性。 在渲染操作相关初始化完成之后和属性注入相关初始化之前调用 beforeCreate 钩子 在依赖相关初始化完成之后和 Dom 挂载之前调用 created 钩子 挂载 Dom options 合并策略我们使用 Vue 构造函数时传入的 options 会经过一系列的合并，合并之后的 options 会被赋值给实例的 $options 属性 12345678910// merge optionsif (options &amp;&amp; options._isComponent) &#123; initInternalComponent(vm, options);&#125; else &#123; vm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm );&#125; 因为动态 options 的合并耗时较长，因此只对外部组件采取动态合并的方式。 先看看 resolveConstructorOptions 方法，vm 是 Vue 实例，vm.constructor 指的是 Vue，代码简化后如下所示： 12345var options = Ctor.options;if (Ctor.super) &#123; // ...&#125;return options; 依据字典，我们可以知道，Vue.options 的值可以表示成这样： 123456Vue.options = &#123; components: &#123;&#125;, directives: &#123;&#125;, filters: &#123;&#125;, _base: Vue,&#125;; 示例中 options 并没有指定 super 属性，因此该方法直接 return options 回到 mergeOptions, 一个参 parent 即 Vue.options, 第二个参 child 是构造函数的入参，第三个是 Vue 实例。 首先是调用 checkComponents(child)，对 components 中声明的名称做格式上的校验，必须符合 html5 标准，并且不能使用内置的 html 标签 12345function checkComponents(options) &#123; for (var key in options.components) &#123; validateComponentName(key); &#125;&#125; 接着是对 props、inject、directives 这些参数进行格式化，最后都形成对象的形式。 下面开始真正的合并。 第一步，将尚未合并过的 child 中的 extend 和 mixins 属性合并到 parent 中。第二步，按顺序将 parent 和 child 的属性存入到声明的空对象 options 中。 需要注意的是在对 child 处理时，只对 parent 中不存在的属性做合并，可以避免对 Vue.options 属性的覆盖 12345for (key in child) &#123; if (!hasOwn(parent, key)) &#123; mergeField(key); &#125;&#125; 接下来重点看下 mergeField 方法，这个是整个合并策略的核心 1234function mergeField(key) &#123; var strat = strats[key] || defaultStrat; options[key] = strat(parent[key], child[key], vm, key);&#125; 总的来说，strats 就是一个对象，它的属性是一个个用来处理不同类型属性的策略方法。 除了 strats，还有一个默认策略方法 defaultStrat 123var defaultStrat = function (parentVal, childVal) &#123; return childVal === undefined ? parentVal : childVal;&#125;; 逻辑很简单：如果 childVal 存在，返回 childVal，否则返回 parentVal。 以下是 strats 的策略方法： 1、el，propsData12345strats.el = strats.propsData = function (parent, child, vm, key) &#123; // ... // 使用默认策略 return defaultStrat(parent, child);&#125;; 2、data12345678910111213141516strats.data = function (parentVal, childVal, vm) &#123; if (!vm) &#123; if (childVal &amp;&amp; typeof childVal !== \"function\") &#123; warn( 'The \"data\" option should be a function ' + \"that returns a per-instance value in component \" + \"definitions.\", vm ); return parentVal; &#125; return mergeDataOrFn(parentVal, childVal); &#125; return mergeDataOrFn(parentVal, childVal, vm);&#125;; mergeDataOrFn 返回的方法里会调用 mergeData 方法，我们跳过直接看 mergeData 12345678910111213141516171819202122232425262728293031function mergeData(to, from) &#123; // 如果不存在子项，直接返回父项 if (!from) &#123; return to; &#125; var key, toVal, fromVal; var keys = hasSymbol ? Reflect.ownKeys(from) : Object.keys(from); for (var i = 0; i &lt; keys.length; i++) &#123; key = keys[i]; // 如果属性已经被 oberved， 则直接跳过 if (key === \"__ob__\") &#123; continue; &#125; toVal = to[key]; fromVal = from[key]; // 如果父项没有当前属性，则开启合并(覆盖) if (!hasOwn(to, key)) &#123; set(to, key, fromVal); &#125; else if ( // 如果当前父属性和子属性都为对象且不相等，则递归合并(覆盖) toVal !== fromVal &amp;&amp; isPlainObject(toVal) &amp;&amp; isPlainObject(fromVal) ) &#123; mergeData(toVal, fromVal); &#125; &#125; return to;&#125; 3、声明周期钩子123456789101112131415161718192021222324LIFECYCLE_HOOKS.forEach(function (hook) &#123; strats[hook] = mergeHook;&#125;);function mergeHook(parentVal, childVal) &#123; var res = childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal; return res ? dedupeHooks(res) : res;&#125;function dedupeHooks(hooks) &#123; var res = []; for (var i = 0; i &lt; hooks.length; i++) &#123; if (res.indexOf(hooks[i]) === -1) &#123; res.push(hooks[i]); &#125; &#125; return res;&#125; mergeHook 中 parentVal 和 childVal 处理后 res 情况如下： childVal 存在 parentVal 存在，将 childVal 合并进 parentVal 中 parentVal 不存在，保证 childVal 为数组或处于数组中 childVal 不存在，则返回 parentVal res 可能存在重复的 hook，所以 dedupeHooks 坐了一个去重mergeHook 最后返回的值就是一个包含合并后生命周期钩子的数组 4、components, directives, filters123ASSET_TYPES.forEach(function (type) &#123; strats[type + \"s\"] = mergeAssets;&#125;); 这三类都采用 mergeAssets 方法 123456789function mergeAssets(parentVal, childVal, vm, key) &#123; var res = Object.create(parentVal || null); if (childVal) &#123; assertObjectType(key, childVal, vm); return extend(res, childVal); &#125; else &#123; return res; &#125;&#125; 只有 childVal 存在时，才会执行合并(覆盖)操作，否则只返回 parentVal 原型链下级对象 5、watch12345678910111213141516171819202122232425strats.watch = function (parentVal, childVal, vm, key) &#123; // ... if (!childVal) &#123; return Object.create(parentVal || null); &#125; // ... if (!parentVal) &#123; return childVal; &#125; var ret = &#123;&#125;; extend(ret, parentVal); for (var key$1 in childVal) &#123; var parent = ret[key$1]; var child = childVal[key$1]; if (parent &amp;&amp; !Array.isArray(parent)) &#123; parent = [parent]; &#125; ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child]; &#125; return ret;&#125;; watch 合并后的对象 ret 的值是数组，保证每一个 key 可以包含多个 watcher，而且 watcher 不能被覆盖，因此这里不会有去重操作 6、props，methods，inject1234567891011121314151617181920strats.props =strats.methods =strats.inject =strats.computed = function (parentVal, childVal, vm, key) &#123; // ... // 如果 parentVal 不存在，直接返回 childVal if (!parentVal) &#123; return childVal; &#125; var ret = Object.create(null); // 将 parentVal 的属性存入 ret 中 extend(ret, parentVal); // 如果 childVal 存在，将 childVal 的属性存入 ret 中 if (childVal) &#123; extend(ret, childVal); &#125; // 返回 ret return ret; &#125;; 7、provide 采用 mergeDataOrFn结语以上，我们梳理了在使用 Vue 时，它自身都做了哪些工作。并且着重解析了 options 合并策略，简单总结一下： 1、el、propsData 如果 child 不存在，返回 parent，否则返回 child 2、data、provide 如果 child 不存在，返回 parent 如果 parent 存在，遍历 child 的属性， 如果 parent 不存在该属性，则将属性赋予 parent 如果 parent 存在该属性，并且 parentVal 与 childVal 同为对象不相等，则递归合并 parentVal 与 childVal 3、components, directives, filters如果 child 存在，合并 child 属性，否则返回空对象 4、props，methods，inject 如果 parent 不存在，返回 child 如果 parent 存在或 child 存在，将各自的属性赋予返回的对象中 5、watch 和 LIFECYCLE_HOOKS相同点：如果 parent 和 child 存在，保证它们都是数组形式，将 child 并入 到 parent 中不同点：LIFECYCLE_HOOKS 最后的结果需要去重，而 watch 不用","categories":[],"tags":[]},{"title":"http 协议笔记/一个简单的网络请求过程","slug":"http 协议笔记/一个简单的网络请求过程","date":"2021-04-30T02:21:53.263Z","updated":"2021-06-29T02:23:56.761Z","comments":true,"path":"2021/04/30/http 协议笔记/一个简单的网络请求过程/","link":"","permalink":"http://yoursite.com/2021/04/30/http%20%E5%8D%8F%E8%AE%AE%E7%AC%94%E8%AE%B0/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"带着问题读源码/vue2/compiler","slug":"带着问题读源码/vue2/compiler","date":"2021-04-30T02:21:53.256Z","updated":"2021-06-29T02:46:29.781Z","comments":true,"path":"2021/04/30/带着问题读源码/vue2/compiler/","link":"","permalink":"http://yoursite.com/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/compiler/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"带着问题读源码/vue2/总体结构(一)","slug":"带着问题读源码/vue2/总体结构(一)","date":"2021-04-30T02:21:53.256Z","updated":"2021-07-01T01:40:15.293Z","comments":true,"path":"2021/04/30/带着问题读源码/vue2/总体结构(一)/","link":"","permalink":"http://yoursite.com/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/vue2/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84(%E4%B8%80)/","excerpt":"","text":"问题为什么要读 VueVue 是目前项目正在使用的框架，阅读学习源码能让我更好的使用框架所提供的功能，也可以解答使用过程中所产生的困惑。有人可能会问，Vue2 相关的源码解析文章在网上一大堆，何必要自己去写呢？我只想说，纸上得来终觉浅，绝知此事要躬行。 Vue3 已经出来了，为什么依然读 Vue2原因一是很久以前就读过 Vue2 的源码，理解了基本的原理，但是后来没有坚持去深入，也就荒废了，心里多少还是有点不甘。因此这次相当于从新来过，也是准备出一个系列，既是读源码的记录整理，也是日后问题查询之处。原因二是虽然新版本的语法形式与旧版不同，但最核心的思想是没变的，吃透旧版之后，有机会也会去读读 Vue3，而这也是必须的。活到老，学到老。 简介源码基于 version 2.6.14 of Vue 本系列暂分为8章，当前章节主要是对后续章节做辅助准备。初次阅读源码时，我就时常陷入各种属性方法名之中，我不知道这个属性是在哪儿声明的，它的作用是什么。虽然说读源码最忌讳深入细枝末节，但无穷的属性让我很恐惧，所以本章会理清楚整体的一个逻辑走向，而第一部分主要是罗列跟 Vue 相关的属性和方法。 正文入口Vue 这种框架核心文件都是在 src 文件里，但是入口在 package.json 中可以找到。 1\"dev\": \"rollup -w -c scripts/config.js --environment TARGET:web-full-dev\" 通过上述指令，打开 scripts/config.js 123456789101112131415161718192021const aliases = require('./alias')const resolve = p =&gt; &#123; const base = p.split('/')[0] if (aliases[base]) &#123; return path.resolve(aliases[base], p.slice(base.length + 1)) &#125; else &#123; return path.resolve(__dirname, '../', p) &#125;&#125;const builds = &#123; // Runtime only (CommonJS). Used by bundlers e.g. Webpack &amp; Browserify 'web-runtime-cjs-dev': &#123; entry: resolve('web/entry-runtime.js'), dest: resolve('dist/vue.runtime.common.dev.js'), format: 'cjs', env: 'development', banner &#125;, ...&#125; aliases 对象即 12345678910module.exports = &#123; vue: resolve('src/platforms/web/entry-runtime-with-compiler'), compiler: resolve('src/compiler'), core: resolve('src/core'), shared: resolve('src/shared'), web: resolve('src/platforms/web'), weex: resolve('src/platforms/weex'), server: resolve('src/server'), sfc: resolve('src/sfc')&#125; 结合上面两部分代码可以知道，入口在 ‘src/platforms/web/entry-runtime.js’ 中, 即 1import Vue from './runtime/index' 继续打开 src/platforms/web/runtime/index 1234567891011121314151617181920// 这里指明了 Vue 的来源import Vue from 'core/index'// 如下为 Vue 添加了相关属性，Vue.config.mustUseProp = mustUsePropVue.config.isReservedTag = isReservedTagVue.config.isReservedAttr = isReservedAttrVue.config.getTagNamespace = getTagNamespaceVue.config.isUnknownElement = isUnknownElementVue.prototype.__patch__ = inBrowser ? patch : noop// public mount methodVue.prototype.$mount = function ( el?: string | Element, hydrating?: boolean): Component &#123; el = el &amp;&amp; inBrowser ? query(el) : undefined return mountComponent(this, el, hydrating)&#125; 从上可知， Vue 其实来源于我们之前说的 src 文件中，并且为 Vue 原型上添加了 $mount 和 patch 方法。 核心从这里开始将会沿着寻找 Vue 构造函数的源头，走马观花式的记录与 Vue 相关的属性及方法。 /src/core/index.js 123456Vue.prototype.$isServer = isServerRendering;Vue.prototype.$isServer = this.$vnode &amp;&amp; this.$vnode.ssrContext;Vue.FunctionalRenderContext = &#123; value: FunctionalRenderContext&#125;;Vue.version = '__VERSION__'; /src/core/global-api/index.js =&gt; initGlobalAPI(Vue) 123456789101112131415161718192021222324Vue.config = configDef;Vue.util = &#123; warn, extend, mergeOptions, defineReactive&#125;;Vue.set = set;Vue.delete = del;Vue.nextTick = nextTick;Vue.observable = obj =&gt; &#123; observe(obj) return obj&#125;Vue.options = Object.create(null)Vue.options.components = Object.create(null);Vue.options.directives = Object.create(null)Vue.options.filters = Object.create(null)Vue.options._base = Vue// extend(Vue.options.components, builtInComponents) builtInComponents 即 KeepAlive Vue.options.components.KeepAlive = KeepAlive /src/core/global-api/use.js =&gt; initUse(Vue) 1Vue.use = function () &#123;&#125; /src/core/global-api/mixin.js =&gt; initMixin(Vue) 1Vue.mixin = function () &#123;&#125; /src/core/global-api/extend.js =&gt; initExtend(Vue) 12Vue.cid = 0Vue.extend = function () &#123;&#125; /src/core/global-api/assets.js =&gt; initAssetRegisters(Vue) 123Vue.components = function () &#123;&#125;Vue.directives = function () &#123;&#125;Vue.filters = function () &#123;&#125; /src/core/instance/index.js 123456789&lt;!-- Vue 构造函数 --&gt;function Vue (options) &#123; if (process.env.NODE_ENV !== 'production' &amp;&amp; !(this instanceof Vue) ) &#123; warn('Vue is a constructor and should be called with the `new` keyword') &#125; this._init(options)&#125; /src/core/instance/init.js =&gt; initMixin(Vue) 12345678910Vue.prototype._init = function () &#123;&#125;vm._uid = uid++vm._isVue = truevm.$options = mergeOptions( resolveConstructorOptions(vm.constructor), options || &#123;&#125;, vm)vm._renderProxy = vmvm._self = vm /src/core/instance/lifecycle.js =&gt; initLifecycle(Vue) 123456789101112vm.$parent = parentvm.$root = parent ? parent.$root : vm vm.$children = []vm.$refs = &#123;&#125; vm._watcher = nullvm._inactive = nullvm._directInactive = falsevm._isMounted = falsevm._isDestroyed = falsevm._isBeingDestroyed = false /src/core/instance/events.js =&gt; initEvents(Vue) 12vm._events = Object.create(null)vm._hasHookEvent = false /src/core/instance/render.js =&gt; initRender(Vue) 123456789vm._vnode = null // the root of the child treevm._staticTrees = null // v-once cached treesvm.$vnode = vm.$options._parentVnodevm.$slots = resolveSlots(options._renderChildren, renderContext)vm.$scopedSlots = emptyObjectvm._c = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, false)vm.$createElement = (a, b, c, d) =&gt; createElement(vm, a, b, c, d, true)vm.$attrs = vm.$vnode.data.attrs || emptyObjectvm.$listeners = vm.$options._parentListeners || emptyObject /src/core/instance/state.js =&gt; initState(Vue) 1vm._watchers = [] /src/core/instance/state.js =&gt; initProps() 12vm._props = &#123;&#125;vm.$options._propKeys = [] /src/core/instance/state.js =&gt; initData() 1vm._data = vm.$options.data.call(vm) || vm.$options.data /src/core/instance/inject.js =&gt; initProvide() 1vm._provided = vm.$options.provide.call(vm) || vm.$options.provide /src/core/instance/state.js =&gt; stateMixin() 12345678910111213Vue.prototype.$data = &#123; get() &#123; return this._data &#125;&#125;Vue.prototype.$props = &#123; get() &#123; return this._props &#125;&#125;Vue.prototype.$set = setVue.prototype.$delete = delVue.prototype.$watch = function ()&#123;&#125; /src/core/instance/events.js =&gt; eventsMixin(Vue) 1234Vue.prototype.$on = function () &#123;&#125;Vue.prototype.$once = function () &#123;&#125;Vue.prototype.$off = function () &#123;&#125;Vue.prototype.$emit = function () &#123;&#125; /src/core/instance/lifecycle.js =&gt; lifecycleMixin(Vue) 123Vue.prototype._update = function () &#123;&#125;Vue.prototype.$forceUpdate = function () &#123;&#125;Vue.prototype.$destroy = function () &#123;&#125; /src/core/instance/render.js =&gt; renderMixin(Vue) 1234Vue.prototype.$nextTick = function (fn: Function) &#123; return nextTick(fn, this)&#125;Vue.prototype._render = function () &#123;&#125; 结语到这里，我们就大致整理出了在初始化 Vue 时会声明的相关属性，在后面的源码阅读过程中会起到一个字典的作用。","categories":[],"tags":[]},{"title":"带着问题读源码/axios/总体结构","slug":"带着问题读源码/axios/总体结构","date":"2021-04-30T02:21:53.236Z","updated":"2021-07-01T01:17:25.341Z","comments":true,"path":"2021/04/30/带着问题读源码/axios/总体结构/","link":"","permalink":"http://yoursite.com/2021/04/30/%E5%B8%A6%E7%9D%80%E9%97%AE%E9%A2%98%E8%AF%BB%E6%BA%90%E7%A0%81/axios/%E6%80%BB%E4%BD%93%E7%BB%93%E6%9E%84/","excerpt":"","text":"本文基于 axios 版本 0.21.1 入口在根目录下找到 index.js，里面只有一句代码，将 axios 进行导出。 1module.exports = require('./lib/axios'); 找到 lib 下的 axios.js 文件 首先引入了相关文件 12345678910// 工具函数库var utils = require('./utils');// bind 方法，返回 function wrapvar bind = require('./helpers/bind');// Axios 构造函数var Axios = require('./core/Axios');// 合并参数var mergeConfig = require('./core/mergeConfig');// 默认设置和属性var defaults = require('./defaults'); 创建 axios 实例的方法 12345678910function createInstance (defaultConfig) &#123; // 创建 Axios 实例 var context = new Axios(defaultConfig); var instance = bind(Axios.prototype.request, context); utils.extend(instance, Axios.prototype, context); utils.extend(instance, context); return instance;&#125; ​bind 方法代码如下： 123456789function bind (fn, thisArg) &#123; return function wrap () &#123; var args = new Array(arguments.length); for (var i = 0; i &lt; args.length; i++) &#123; args[i] = arguments[i]; &#125; return fn.apply(thisArg, args); &#125;;&#125; bind 方法的逻辑很简单，就是返回 一个wrap 函数，函数内部会使用 context 调用 Axios.prototype.request。bind执行完后就将 Axios.prototype 和 context 的属性赋值给 wrap 函数。 在该文件后续部分我们可以看到以下两行代码： 123// ...var axios = createInstance(defaults);module.exports = axios; 执行 createInstance 方法返回的 instance 赋值给了 axios，那么 axios 的值就是 wrap 函数，这也就是为什么我们使用 axios 时，既可以调用它的方法，也可以直接执行它的原因。 到这里，我们明白了 axios 是什么以及如何创建它的实例。 构造函数前面的处理将 Axios 相关属性赋予给了 wrap 函数，那到底是哪些属性呢？该小节将会详细了解下构造函数 Axios。 文件位于 axios/core/Axios 首先引入所需依赖，大概知道是干什么的就行。 123456// 对请求路径进行一些格式化var buildURL = require('../helpers/buildURL');// 拦截器构造函数var InterceptorManager = require('./InterceptorManager');// 发起 request 请求var dispatchRequest = require('./dispatchRequest'); 接着往下看 12345678function Axios (instanceConfig) &#123; this.defaults = instanceConfig; // 拦截器对象 this.interceptors = &#123; request: new InterceptorManager(), response: new InterceptorManager() &#125;;&#125; 在创建实例时可接收一个配置参数 将接收的配置赋值给自身的 defaults 属性 拥有一个 拦截器对象，该对象包括请求拦截器和相应拦截器 拦截器实例是在创建 Axios 实例时才会创建 拦截器在日常使用中，拦截器的配置是最重要的一部分。我们通过上方路径找到拦截器构造函数文件。 ​ 构造函数拥有一个 handlers 数组，用来存储拦截器。 123function InterceptorManager () &#123; this.handlers = []; &#125; ​然后给构造函数原型添加方法函数 使用 use 方法添加一个新的拦截器， 123456789InterceptorManager.prototype.use = function use (fulfilled, rejected, options) &#123; this.handlers.push(&#123; fulfilled: fulfilled, rejected: rejected, synchronous: options ? options.synchronous : false, runWhen: options ? options.runWhen : null &#125;); return this.handlers.length - 1;&#125;; 每个拦截器包括四个属性： fulfilled：一个方法，在请求或相应被 then 处理前执行 rejected：一个方法，在请求或相应被 reject 处理前执行 synchronous：请求拦截器是否采用同步执行机制 runwhen：表明请求拦截器什么情况下执行。默认为 null，也可以是一个函数。 use 方法返回当前拦截器在拦截器数组中的位置下标 使用 eject 方法清除一个拦截器。参数 id 就是拦截器在数组中的下标。 123456InterceptorManager.prototype.eject = function eject (id) &#123; if (this.handlers[id]) &#123; // 将下标为 id 处的拦截器置为 null this.handlers[id] = null; &#125;&#125; 使用 forEach 方法执行符合条件的拦截器 12345678InterceptorManager.prototype.forEach = function forEach (fn) &#123; // 遍历拦截器存储数组，执行 fn 时会过滤掉数组中被置为 null 的值。 utils.forEach(this.handlers, function forEachHandler (h) &#123; if (h !== null) &#123; fn(h); &#125; &#125;);&#125; 挂载方法构造函数内部添加完属性后，紧接着就是在构造函数原型上添加相应方法： 123456789101112131415161718192021222324// 为 Axios 原型挂载 request 和 getUri 方法Axios.prototype.request = function request (config) &#123;...&#125;Axios.prototype.getUri = function getUri (config) &#123;...&#125;// 为 Axios 原型挂载支持的 methodutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData (method) &#123; Axios.prototype[method] = function (url, config) &#123; return this.request(mergeConfig(config || &#123;&#125;, &#123; method: method, url: url, // 使用这些 method时，有可能不会传 data 属性，所以使用默认的 data data: (config || &#123;&#125;).data &#125;)); &#125;;&#125;);utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData (method) &#123; Axios.prototype[method] = function (url, data, config) &#123; return this.request(mergeConfig(config || &#123;&#125;, &#123; method: method, url: url, data: data &#125;)); &#125;;&#125;) 其中包括 HTTP 请求同名的方法 。这些方法会被代理给原型的 request 方法，Axios 将支持的请求的 methods 按照是否需要默认 data 属性分为两类，现在来看看 request 方法的实现。 request 首先是基本参数的一个默认设置以及合并 12345678910111213141516171819// 兼容 axios('example/url'[, config]) 这种传参方式if (typeof config === 'string') &#123; config = arguments[1] || &#123;&#125;; config.url = arguments[0];&#125; else &#123; config = config || &#123;&#125;;&#125;// 合并 configconfig = mergeConfig(this.defaults, config);// 设置 config.method， 默认小写，默认 get 方法if (config.method) &#123; config.method = config.method.toLowerCase();&#125; else if (this.defaults.method) &#123; config.method = this.defaults.method.toLowerCase();&#125; else &#123; config.method = 'get';&#125; 对拦截器队列的处理 1234567891011121314151617181920212223// 请求拦截器队列var requestInterceptorChain = [];// 请求拦截器是否同步执行var synchronousRequestInterceptors = true;this.interceptors.request.forEach(function unshiftRequestInterceptors (interceptor) &#123; if (typeof interceptor.runWhen === 'function' &amp;&amp; interceptor.runWhen(config) === false) &#123; return; &#125; // 因为 interceptor.synchronous 默认为 false，所以 synchronousRequestInterceptors 默认为 false， synchronousRequestInterceptors = synchronousRequestInterceptors &amp;&amp; interceptor.synchronous; // 每个拦截器由执行成功和执行失败处理方法组成 requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);&#125;);// 响应拦截器链var responseInterceptorChain = [];this.interceptors.response.forEach(function pushResponseInterceptors (interceptor) &#123; responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);&#125;); 请求拦截器 执行机制的处理 ​ 请求拦截器 执行机制由上面的 synchronousRequestInterceptors 决定，分为 异步和同步两种。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var promise;// 异步执行if (!synchronousRequestInterceptors) &#123; // 调用处理方法队列 var chain = [dispatchRequest, undefined]; // 将请求拦截器处理方法和响应拦截器处理方法分别放入队列前后 Array.prototype.unshift.apply(chain, requestInterceptorChain); chain.concat(responseInterceptorChain); promise = Promise.resolve(config); // 将包含了请求拦截器的 chain 交给 promise 来处理 while (chain.length) &#123; promise = promise.then(chain.shift(), chain.shift()); &#125; return promise;&#125;// 同步执行var newConfig = config;// 先一次性执行完请求拦截器while (requestInterceptorChain.length) &#123; var onFulfilled = requestInterceptorChain.shift(); var onRejected = requestInterceptorChain.shift(); try &#123; newConfig = onFulfilled(newConfig); &#125; catch (error) &#123; onRejected(error); break; &#125;&#125;try &#123; // 再异步执行 dispatchRequest（如 XHR）， promise = dispatchRequest(newConfig);&#125; catch (error) &#123; return Promise.reject(error);&#125;// 最后异步执行响应拦截器while (responseInterceptorChain.length) &#123; promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());&#125;return promise; 对拦截器处理的总结： 存在三个 chain：请求拦截器 requestInterceptorChain 、响应拦截器 responseInterceptorChain、真正的 request 调用 originChain 拦截器以成对的形式存在，放入对应的拦截器 chain 中 请求拦截器对依次插入到 chain 头；相应拦截器对依次插入到 chain 尾 请求拦截器可以同步执行也可以异步执行： 如果是异步执行，则会将requestInterceptorChain 插入到 originChain 队头，将 responseInterceptorChain 插入到 originChain 队尾；然后对 originChain 内的元素放入 promise.then 中执行 如果是同步执行，则会将 requestInterceptorChain 内的元素以迭代的方式执行完毕，然后执行 originChain 内的 request，最后将 responseInterceptorChain 内的元素放入 promise.then 中执行 最后通过一张图来理解请求拦截器处理不同的机制","categories":[],"tags":[]},{"title":"JavaScript 异步编程/跟着规范实现一个功能完备的Promise","slug":"JavaScript 异步编程/跟着规范实现一个功能完备的Promise","date":"2021-04-30T02:21:53.183Z","updated":"2021-07-01T01:15:16.974Z","comments":true,"path":"2021/04/30/JavaScript 异步编程/跟着规范实现一个功能完备的Promise/","link":"","permalink":"http://yoursite.com/2021/04/30/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%B7%9F%E7%9D%80%E8%A7%84%E8%8C%83%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8A%9F%E8%83%BD%E5%AE%8C%E5%A4%87%E7%9A%84Promise/","excerpt":"","text":"一直以来，对于 promise，只知道如何使用，其内部的运作机制却不得而知。本着知其然，知其所以然（为了让自己用得安心）的理念，决定跟着规范去了解底层的原理，并手写一个功能完备的 MyPromise. 术语 promise 是一个对象或者函数，拥有 then 方法 thenable 可以理解为一个拥有 then 方法的对象或函数 value 是一个合法的 JavaScript值 reason 用来表示 promise 拒绝的原因 特点 promise 初始状态为 pending，可以转变成 fulfilled 或者 rejected 如果状态是 fulfilled，则不能转变为 rejected 或者 pending。rejected 同理。 实现下面开始尝试第一版： 平时都是通过 new 来创建一个 promise 实例： 1234const p = new Promise((resolve, reject) =&gt; &#123; // do something resolve('xxx')&#125;) 于是首先创建一个 promise 构造函数，接收一个方法 executor 作为参数, 在内部直接执行，并且传入两个方法以供使用者使用。 123456function MyPromise(executor) &#123; const resolve = () =&gt; &#123;&#125; const reject = () =&gt; &#123;&#125; executor(resolve, reject);&#125; 如果调用 resolve 方法，会将 Promise实例 状态转变成 fulfilled，如果调用 reject 方法，则会将 Promise 实例状态转变成 rejected。所以接下来给 MyPromise 构造函数添加相应属性，并实现 resolve 和 reject。 12345678910111213141516171819202122function MyPromise(executor) &#123; this.status = 'pending'; this.value = null; this.reason = null; const resolve = (value) =&gt; &#123; // 只有处于 pending 状态，才能发生状态改变 if (this.status === 'pending') &#123; this.status = 'fulfilled'; this.value = value; &#125; &#125; const reject = (reason) =&gt; &#123; if (this.status === 'pending') &#123; this.status = 'rejected'; this.reason = reason; &#125; &#125; executor(resolve, reject);&#125; 构造函数建造完毕，现在来处理最主要的部分 then 方法，这也是规范给出详细标准的一部分。 123456789101112131415// 可以接收两个方法作为参数, 在内部可以根据 MyPromise 实例的状态进行相应的操作MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; &#125; if (this.status === 'fulfilled') &#123; &#125; if (this.status === 'rejected') &#123; &#125;&#125; 当 then 执行的时候，如果 status 是 fulfilled 或者 rejected 状态，可以直接执行 onFulfilled 或者 onRejected 方法，但如果依然还是 pending，需要将这些执行操作放入等待区，也就是存入到回调队列中，如下： 123456789101112131415161718MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; if (this.status === 'pending') &#123; this.onFulfilledStack.push(() =&gt; &#123; onFulfilled(this.value); &#125;) this.onRejectedStack.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; if (this.status === 'fulfilled') &#123; onFulfilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason) &#125;&#125; 那么现在，待执行栈已经存在了状态改变的回调，需要在合适的时机去执行，所以需要完善 resolve 和 reject 方法。一旦状态改变，则将带执行栈中的回调全部执行。 12345678910111213141516const resolve = (value) =&gt; &#123; this.status = 'fulfilled'; this.value = value; // 执行回调 while (this.onFulfilledStack.length &gt; 0) &#123; this.onFulfilledStack.shift()(this.value); &#125;&#125;const reject = (reason) =&gt; &#123; this.status = 'rejected'; this.reason = reason; // 执行回调 while (this.onRejectedStack.length &gt; 0) &#123; this.onRejectedStack.shift()(this.reason); &#125;&#125; 我们都知道then 方法必须返回一个 promise，因此需要对 then 方法进一步改造： 123456MyPromise.prototype.then = function(onFulfilled, onRejected) &#123; // ... return new Promise((resolve, reject) =&gt; &#123; &#125;)&#125; 到这里就要思考一下，then 方法为什么要返回一个 promise？ 原因是每一个 promise 都会有一个 then 方法，而如果 then 方法也返回一个 promise，那么这个 then 也会有一个 then 方法，于是可以像下方代码一样链式调用 ： 123new MyPromise((resolve, reject) =&gt; &#123; resolve('success')&#125;).then().then() 但还有个原因。我们不仅可以像上方一样 resolve 一个基本值，也可以 resolve 一个 promise，如下方例子： 1234567new MyPromise((resolve, reject) =&gt; &#123; resolve(new MyPromise((_resolve, _reject) =&gt; &#123; setTimeout(() =&gt; &#123; _resolve('success') &#125;, 2000) &#125;))&#125;).then().then() 因为被 resolve 的 promise 的状态是尚未改变的，因此可以将这个 promise 放进 then 返回的这个 promise 内去等待状态改变，所以这一步我们将 then 方法内原先的处理逻辑挪到这个返回的 promise 内部。 1234567891011121314151617181920212223MyPromsise.prototype.then = function(onFulfilled, onRejected) &#123; let _promise = null; return _promise = new MyPromise((resolve, reject) =&gt; &#123; // 因为 onFulfilled(this.value) 和 onRejected(this.reason) 可能返回一个 thenable，因此需要将下方代码移入新 promise内部去执行 if (this.status === 'pending') &#123; this.onFulfilledStack.push(() =&gt; &#123; onFulfilled(this.value); &#125;) this.onRejectedStack.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; if (this.status === 'fulfilled') &#123; onFulfilled(this.value); &#125; if (this.status === 'rejected') &#123; onRejected(this.reason) &#125; &#125;) &#125; 有个问题，我们在内部直接调用 onFulfilled 和 onRejected，但却没有对这两个方法类型进行错误处理，也就是必须保证它们是 function。 123456MyPromsise.prototype.then = function(onFulfilled, onRejected) &#123; // 设置默认的回调方法（需原样返回传进来的值或者抛出同样的值），可以保证 promise 结果能够透传 onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value =&gt; value; onRejected = typeof onRejected === 'function' ? onRejected : reason =&gt; &#123; throw reason &#125; // ...&#125; 这里有一个处理，如果 onFulfilled 和 onRejected 不是 function，那么就将它们赋值成方法，并且将接收到的值进行相应处理：如果是 onFulfilled，直接将值 return，如果是 onRejected, 主动抛出一个错误。这也就实现了 promise 值的透传 12345new MyPromise((resolve, reject) =&gt; &#123; resolve('success')&#125;).then().then((value) =&gt; &#123; console.log(value) // success&#125;) 目前为止，MyPromise 已经具备了可实例化，可执行同步任务的功能。但还无法执行异步任务。 规范2.2.4： onFulfilled or onRejected must not be called until the execution context stack contains only platform code。 意思是：onFulfilled 和 onRejected 方法需要异步执行。 接下来对 then 方法进行进一步完善, 将它们的执行丢到异步环境中 1234567891011121314151617181920212223242526272829MyPromsise.prototype.then = function(onFulfilled, onRejected) &#123; // ... let _promise = null; return _promise = new MyPromise((resolve, reject) =&gt; &#123; if (this.status === 'pending') &#123; setTimeout(() =&gt; &#123; this.onFulfilledStack.push(() =&gt; &#123; onFulfilled(this.value); &#125;) this.onRejectedStack.push(() =&gt; &#123; onRejected(this.reason) &#125;) &#125;) &#125; if (this.status === 'fulfilled') &#123; setTimeout(() =&gt; &#123; onFulfilled(this.value); &#125;) &#125; if (this.status === 'rejected') &#123; setTimeout(() =&gt; &#123; onRejected(this.reason) &#125;) &#125; &#125;) &#125; 规范2.2.7.1 If either onFulfilled or onRejected returns a value x, run the Promise Resolution Procedure [[Resolve]](promise2, x) 意思是： 对 onFulfilled 或者 onRejected 返回的值 x 进行 resolvePromise 操作，即需要将 x 当作一个 thenable 来对待，then 返回的 promise 的 状态需要 x 的状态来决定。 这里需要注意： resolvePromise 需要 promise2（即 then 返回的 promise） 和 x 这两个参，但是 promise2 的状态需要它自身 resolve 和 reject 去改变，因此将 resolve 和 reject 也带上。 改动如下： 12345678910111213141516171819202122232425262728if (this.status === 'pending') &#123; this.onFulfilledStack.push(() =&gt; &#123; setTimeout(() =&gt; &#123; let x = onFulfilled(this.value); resolvePromise(_promise, x, resolve, reject) &#125;) &#125;) this.onRejectedStack.push(() =&gt; &#123; setTimeout(() =&gt; &#123; let x = onRejected(this.reason); resolvePromise(_promise, x, resolve, reject) &#125;) &#125;)&#125;if (this.status === 'fulfilled') &#123; setTimeout(() =&gt; &#123; let x = onFulfilled(this.value); resolvePromise(_promise, x, resolve, reject) &#125;)&#125;if (this.status === 'rejected') &#123; setTimeout(() =&gt; &#123; let x = onRejected(this.reason); resolvePromise(_promise, x, resolve, reject) &#125;)&#125; 接下来就是实现 resolvePromise 方法了。 按照规范 2.3 The Promise Resolution Procedure，一步步实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455function resolvePromise(_promise, x, resolve, reject)&#123; // 2.3.1 如果 _promise 和 x 是同一个对象，reject TypeError if (x === _promise) &#123; return reject(new TypeError(`$&#123;x&#125; should no refer to the same object with MyPromise`)) &#125; // 当 x 是对象或者函数时： // 判断 x.then 方法中 onFulfilled 回调或者 onRejecetd 回调是否执行过 // 因为规范规定：其中每一个回调只能执行一次 // 当其中某项执行过，就将 hasCalled 置为 true let hasCalled = false; if (x instanceof MyPromsie) &#123; // 如果状态没有改变，则需要调用 then 方法，然后在内部还需要对以后的返回值进行 resolvePromise if (x.status === 'pending') &#123; x.then(y =&gt; &#123; resolvePromise(_promise, y, resolve, reject) &#125;, err =&gt; &#123; resolvePromise(_promise, err, resolve, reject) &#125;) &#125; else &#123; // 如果状态已经改变，那么 x 就会有一个正常值，假设为 z // 执行 x.then(resolve, reject)，会直接调用 resolve(z) 或者 reject(z) ： // 2.3.2.2 &amp;&amp; 2.3.2.3 x.then(resolve, reject); &#125; &#125; else if (Object.prototype.toString.call(x) === '[object Object]' || typeof x === 'function') &#123; // x 是对象或者函数 try &#123; let then = x.then; if (typeof then === 'function') &#123; then.call(x, y =&gt; &#123; if (hasCalled) &#123; return &#125; hasCalled = true; resolvePromise(_promise, y, resolve, reject) &#125;, err =&gt; &#123; if (hasCalled) &#123; return &#125; hasCalled = true; reject(err); &#125;) &#125; else &#123; resolve(x) &#125; &#125; catch(err) &#123; // 2.3.3.3.4.1 // if resolvePromise or rejectPromise have been called, ignore it. if (!hasCalled) &#123; reject(err) &#125; &#125; &#125; else &#123; // 2.3.4 resolve(x); &#125;&#125; 如果能通过 promiseA+ 测试，说明该版本的 Promise 符合规范，但是还缺少常用的功能，继续完善： MyPromise.resolve 接收一个值，在内部创建一个新的实例，将状态交给新实例去处理 12345MyPromise.prototype.resolve = function(value) &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(value) &#125;)&#125; MyPromise.catch 接收一个方法，只会在 rejected 状态下执行 123MyPromise.prototype.catch = function (callback) &#123; return this.then(null, callback);&#125; MyPromise.finally 接收一个方法，不论 fulfilled 或者 rejected 都会执行 123MyPromise.prototype.finally = function (callback) &#123; return this.then(callback, callback);&#125; MyPromise.all 接收一个数组，只有所有项的状态为 fulfilled，最终结果才为 fulfilled，如果有一个 rejected，那么结果就是 rejected 123456789101112131415161718MyPromise.prototype.all = function (promiseArr) &#123; return new MyPromise((resolve, reject) =&gt; &#123; let result = []; let resolveCount = 0; promiseArr.forEach((currentPromise, index) =&gt; &#123; currentPromise.then(value =&gt; &#123; result[index] = value; resolveCount++; if (resolveCount === promiseArr.length) &#123; resolve(result); &#125; &#125;, err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; MyPromise.race 接收一个数组，结果由第一个状态改变的 thenable 决定 1234567891011MyPromise.prototype.race = function (promiseArr) &#123; return new MyPromise((resolve, reject) =&gt; &#123; promiseArr.forEach((currentPromise, index) =&gt; &#123; currentPromise.then(value =&gt; &#123; resolve(value); &#125;, err =&gt; &#123; reject(err) &#125;) &#125;) &#125;)&#125; MyPromise.allSettled 接收一个数组，只有等到所有项的状态都改变了，不论是 fulfilled 还是 rejected，都只会变成 fulfilled 123456789101112131415161718MyPromise.prototype.allSettled = function(promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; let resultArr = []; promiseArr.forEach(currentPromise =&gt; &#123; currentPromise.then(value =&gt; &#123; resultArr.push(&#123;status: 'fulfilled', value: value&#125;); if (resultArr.length === promiseArr.length) &#123; resolve(resultArr); &#125; &#125;, err =&gt; &#123; resultArr.push(&#123;status: 'rejected', reason: err&#125;); if (resultArr.length === promiseArr.length) &#123; resolve(resultArr); &#125; &#125;) &#125;) &#125;)&#125; MyPromise.any 接收一个数组，如果其中有一项的状态为 fulfilled， 那么结果就是 fulfilled，否则如果所有都是 rejected，那结果就是 rejected， 并且 reanson 是 ‘AggregateError: All promises were rejected’ 123456789101112131415MyPromise.prototype.any = function(promiseArr) &#123; return new Promise((resolve, reject) =&gt; &#123; let rejectCount = 0; promiseArr.forEach(currentPromise =&gt; &#123; currentPromise.then(value =&gt; &#123; resolve(value); &#125;, err =&gt; &#123; rejectCount ++; if (rejectCount === promiseArr.length) &#123; reject('AggregateError: All promises were rejected'); &#125; &#125;) &#125;) &#125;)&#125; 测试方法： #安装 promises-aplus-tests 1npm i promises-aplus-tests -g #在代码里加上这段 12345678MyPromise.deferred = function () &#123; const defer = &#123;&#125;; defer.promise = new MyPromise((resolve, reject) =&gt; &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer;&#125; #最后 1promises-aplus-tests promise.js 有一点需要注意：我在实现 promise 内部异步执行时采用的是 setTimeout，而 promise 的 then 方法是一个微任务这与实际有出入。不过用于理解其中的异步理念已经足够了。追求完美的同学可自行实现不同的版本。 完整代码地址：https://github.com/yuwengCipher/MyPromise","categories":[],"tags":[]},{"title":"JavaScript 异步编程/说说 js 的异步处理机制","slug":"JavaScript 异步编程/说说 js 的异步处理机制","date":"2021-04-30T02:21:53.152Z","updated":"2021-07-01T01:15:16.973Z","comments":true,"path":"2021/04/30/JavaScript 异步编程/说说 js 的异步处理机制/","link":"","permalink":"http://yoursite.com/2021/04/30/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E8%AF%B4%E8%AF%B4%20js%20%E7%9A%84%E5%BC%82%E6%AD%A5%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/","excerpt":"","text":"什么是异步在 JavaScript 中和生活中都会有异步任务的存在，而异步的产生是有前提条件的，那就是这个任务可以被拆解成两部分。 举个简单的例子。周末我想喝点排骨汤，把所有步骤都准备好后开火炖。正常来说，这锅汤需要3小时才能煲好，很显然我不会傻傻守在这儿等它3小时，因为我还有别的事要做，比如说看电视，嗑瓜子等等。而是3小时后汤煲好了，我才回去盛起来喝。 所以这个喝汤任务由两个步骤组成：煲汤 + 喝汤；这个喝汤步骤就是异步的 设计成异步的原因从上面可以知道，如果我傻傻的在锅前等3个小时，那么我看电视、嗑瓜子等事情就得向后延3小时，到最后我这一天做不了什么，所以傻等3小时完全是浪费时间。 js 是单线程，同一时间只能做一件事，长时间的等待势必会造成资源的浪费 异步实现方案 回调函数 回调函数在 js 代码里随处可见，如给 DOM 添加点击事件 12345let d = document.getElementId('test');d.addEventListener('click', function callback(e) &#123; // do something&#125;)// callback 就是回调函数 node 里去读取一份文件 123fs.readFile('./test.text', function callback(err, data)&#123; // do something&#125;) 但是有时候的需求会比较复杂，加入多个任务存在依赖性，就会写出如下代码： 1234567fs.readFile('./test.text', function callback(err, data)&#123; fs.readFile('./test1.text', function callback1(err, data)&#123; fs.readFile('./test2.text', function callback2(err, data)&#123; // ... &#125;) &#125;)&#125;) 深层嵌套让我们很是绝望！ promise 幸运的是后来有了 promise，带我们逃离了“回调地狱”，来到新世界： 1234567891011121314151617new Promise((resolve, reject) =&gt; &#123; fs.readFile('./test.text', function callback(err, data)&#123; resolve(data); &#125;)&#125;).then(data =&gt; &#123; fs.readFile('./test.text1', function callback1(err, data1)&#123; // do something resolve(data1); &#125;)&#125;).then(data =&gt; &#123; fs.readFile('./test.text1', function callback2(err, data2)&#123; // do something resolve(data2); &#125;)&#125;) 这样写之后是不是看起来清爽了，瞬间头也不晕了，promise 让流程执行的过程更清晰！ 但是你一定见过这样的代码： 123456789101112131415161718new Promise((resolve, reject) =&gt; &#123; fs.readFile('./test.text', function callback(err, data)&#123; resolve(data); &#125;)&#125;).then(data =&gt; &#123; // do something&#125;).then(data =&gt; &#123; // do something&#125;).then(data =&gt; &#123; // do something&#125;).then(data =&gt; &#123; // do something&#125;)... 真的是链式调用一时爽，一直链式调用… 就有点难受了。 promise 抑制了回调地狱的横向扩张，却发现自己的纵向扩张也很厉害。 generator generator 函数与普通的函数不同，函数内的代码可以分段执行，也就是说可以暂停执行，凡是需要暂停的地方用 yield 关键字注明。具体用法参考阮老师文章的介绍 http://www.ruanyifeng.com/blog/2015/04/generator.html 123456789function* genFn() &#123; let x = yield 2; let y = yield x * 2; return y;&#125;let gen = genFn();gen.next() // &#123;value: 2, done: false&#125;gen.next() // &#123;value: NaN, done: false&#125;gen.next() // &#123;value: undefined, done: true&#125; 于是对于上面依次读取文件的例子可以改写成如下形式： 12345678910111213141516171819202122// 模拟文件请求function fakeReadFile(filename, duration) &#123; setTimeout(() =&gt; &#123; console.log(filename) // 这里需要主动调用迭代器对象的 next 方法 gen.next(filename) &#125;, duration)&#125;function* genFn() &#123; // 顺序请求三个文件，期望的是顺序打印出结果 yield fakeReadFile('a.txt', 5000); yield fakeReadFile('b.txt', 3000); yield fakeReadFile('c.txt', 1000);&#125;const gen = genFn();gen.next();// a.txt 5秒后打印// b.txt 8秒后打印// c.txt 9秒后打印 虽然获取文件所需时长 a &gt; b &gt; c, 但是打印的结果却是 a，b，c，也就是说在 generator 函数内，yield 是按上到下执行的，使得代码执行顺序更清晰明了。 可以看到我需要在文件请求完成之后手动调用 next 方法，因此在实际工作中，我们通常需要将 generator 函数包裹在一个函数内： 12345678910111213141516171819function callGen() &#123; function* genFn() &#123; yield fakeReadFile('a.txt', 5000, gen); yield fakeReadFile('b.txt', 3000, gen); yield fakeReadFile('c.txt', 1000, gen); &#125; const gen = genFn(); gen.next();&#125;function fakeReadFile(filename, duration, g) &#123; setTimeout(() =&gt; &#123; console.log(filename) // 这里需要主动调用迭代器对象的 next 方法 g.next(filename) &#125;, duration)&#125;callGen(); 总的来说，generator 函数改善了 promise 的 then “链条”过长的缺点，但是需要额外创建一个函数来包装。 async await 作为 ES7 提出的 async 函数，在 generator 基础上进行优化，是目前 js 处理异步操作的最优解决方案，让异步处理代码可读性更强，流程控制更方便。 我们按照 async 方法的用法来继续优化上面的例子： 123456789101112131415161718192021222324function fakeReadFile(filename, duration, g) &#123; // 因为 await 关键字后面需要接收一个 promise return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(filename) &#125;, duration) &#125;)&#125;async function asyncFn() &#123; let a = await fakeReadFile('a.txt', 5000); let b = await fakeReadFile('b.txt', 3000); let c = await fakeReadFile('c.txt', 1000); console.log(a) console.log(b) console.log(c)&#125;asyncFn();// 9秒后一次性打印// a.txt // b.txt // c.txt 需要注意的是如果 await 后面表达式里包含异步操作但返回的不是 promise，那么就就不会等待到结果返回，比如这样修改： 123456789101112131415161718192021222324252627function fakeReadFile(filename, duration, g) &#123; if (filename === 'a.txt') &#123; setTimeout(() =&gt; &#123; return filename &#125;, duration) &#125; else &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(filename) &#125;, duration) &#125;) &#125;&#125;async function asyncFn() &#123; let a = await fakeReadFile('a.txt', 5000); console.log(a) let b = await fakeReadFile('b.txt', 3000); let c = await fakeReadFile('c.txt', 1000); console.log(b) console.log(c)&#125;asyncFn();// undefined 立刻输出// b.txt 4秒之后输出// c.txt 4秒之后输出 也就是说第一个 await 没有阻塞 console.log(a) 的执行。因此 async 对 await 后面的表达式又两种处理方式： 12341. promise async 会执行表达式并等待有返回值才会继续往下执行代码2. 非 promise async 执行表达式并立刻获取返回值，如果没有则为 undefined 总结js 处理异步的方法经历了 回调函数、promise、generator、async 这四个阶段，每一种新方法都是对前方法的改善，主要处理的点有两点： 可读性更强 流程控制更清晰","categories":[],"tags":[]},{"title":"JavaScript 异步编程/浅析 generator 与 async 原理","slug":"JavaScript 异步编程/浅析 generator 与 async 原理","date":"2021-04-30T02:21:53.138Z","updated":"2021-07-01T01:15:16.973Z","comments":true,"path":"2021/04/30/JavaScript 异步编程/浅析 generator 与 async 原理/","link":"","permalink":"http://yoursite.com/2021/04/30/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E6%B5%85%E6%9E%90%20generator%20%E4%B8%8E%20async%20%E5%8E%9F%E7%90%86/","excerpt":"","text":"序言geneartor 和 async 都是 js 处理异步操作发展历程的产物，它们让异步编程越来越像同步编程。但是由于采用新的语法、关键字，它们是如何做到“类同步”操作的，我们不得而知，因此这篇文章将会窥探内部的秘密。 下面将借助 babel 本地编译示例代码来进行分析。 准备步骤 一、全局安装 regenerator 1npm i regenerator -g 二、编译 generator ​ 命令加上 –include-runtime，可以得到完整的编译代码 1regenerator --include-runtime test.js &gt; test-fill.js test-fill.js 就是编译后的代码文件。 解析 generator现在有如下代码： 123456789function* genFn() &#123; let x = yield 2; let y = yield x * 2; return y;&#125;let gen = genFn();gen.next() // &#123;value: 2, done: false&#125;gen.next() // &#123;value: NaN, done: false&#125;gen.next() // &#123;value: undefined, done: true&#125; 调用 genFn 并不会直接执行，而是会返回一个 generator 对象，每次调用它的 next 方法会执行一个 yield 语句，并返回当前的值及状态。 这是编译后的代码： 12345678910111213141516171819202122232425262728var _marked = /*#__PURE__*/regeneratorRuntime.mark(genFn);function genFn () &#123; return regeneratorRuntime.wrap(function genFn$ (_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return 1; case 2: _context.next = 4; return 2; case 4: _context.next = 6; return 3; case 6: case \"end\": return _context.stop(); &#125; &#125; &#125;, _marked);&#125;var g = genFn();console.log(g.next());console.log(g.next());console.log(g.next());console.log(g.next()); 可以看到 genFn 被改写了，调用 regeneratorRuntime.wrap 方法创建，其中传给 wrap 方法的 genFn$ 函数，里面的逻辑很简单，是一个永远都会执行的迭代，里面 switch 中的 case 是原代码中 yield 关键字所在的行数，genFn$ 的参数 _context 记录了原代码的执行上下文内容，每次调用 next 方法，实际上就会调用 genFn$，然后执行对应的逻辑。 大致的流程弄清楚之后，再来看看 regeneratorRuntime。 wrap 方法第二个参是 mark(genFn) 的值， mark 方法如下： 1234567891011121314151617181920212223var $Symbol = typeof Symbol === \"function\" ? Symbol : &#123;&#125;;var iteratorSymbol = $Symbol.iterator || \"@@iterator\";var toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";function GeneratorFunctionPrototype () &#123; &#125;var IteratorPrototype = &#123;&#125;;IteratorPrototype[iteratorSymbol] = function () &#123; return this;&#125;;GeneratorFunctionPrototype.prototype = Object.create(IteratorPrototype);exports.mark = function (genFun) &#123; if (Object.setPrototypeOf) &#123; Object.setPrototypeOf(genFun, GeneratorFunctionPrototype); &#125; else &#123; genFun.__proto__ = GeneratorFunctionPrototype; define(genFun, toStringTagSymbol, \"GeneratorFunction\"); &#125; genFun.prototype = Object.create(Gp); return genFun;&#125;; IteratorPrototype 对象添加 Symbol.iterator属性，使得 IteratorPrototype 拥有 Iterator 接口 GeneratorFunctionPrototype 函数的原型指向 IteratorPrototype ，所以 GeneratorFunctionPrototype 也拥有 Iterator 接口 genFun 的 proto 指向 GeneratorFunctionPrototype ，同理 genFun 拥有 Iterator 接口 mark 返回 genFun 也就是说 mark 方法返回一个拥有 Iterator 接口 genFun。现在看下 wrap 方法。 12345678910111213141516171819function wrap (innerFn, outerFn, self, tryLocsList) &#123; // 确保 protoGenerator 拥有 Itrator 接口 var protoGenerator = outerFn &amp;&amp; outerFn.prototype instanceof Generator ? outerFn : Generator; var generator = Object.create(protoGenerator.prototype); // context 即 genFn$ 的参数 _context var context = new Context(tryLocsList || []); // ._invoke 方法整合了 next、throw 和 return 方法 generator._invoke = makeInvokeMethod(innerFn, self, context); return generator;&#125;// _invoke 即内部的 invokefunction makeInvokeMethod (innerFn, self, context) &#123; return function invoke (method, arg) &#123; // ... &#125;;&#125; 先看看 _invoke 在哪儿调用 123456789101112var Gp = GeneratorFunctionPrototype.prototype = Generator.prototypedefineIteratorMethods(Gp);// 为 Generator 添加 prototype 添加 next、throw、return 方法// 并且这些方法都会调用 _invoke 方法function defineIteratorMethods (prototype) &#123; [\"next\", \"throw\", \"return\"].forEach(function (method) &#123; define(prototype, method, function (arg) &#123; return this._invoke(method, arg); &#125;); &#125;);&#125; 这些弄明白之后，可以简单理一下编译后代码的执行步骤： var g = genFn(); genFn() 返回 generator 对象，拥有 _invoke 方法 g 拥有 _invoke g.next(); g 的 next 方法会调用 _invoke 方法 g.next() ==&gt; g._invoke(); 到这里就可以去看看 invoke 是如何实现的 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 四种状态：开始、执行中、暂停执行、结束var GenStateSuspendedStart = \"suspendedStart\";var GenStateExecuting = \"executing\";var GenStateSuspendedYield = \"suspendedYield\";var GenStateCompleted = \"completed\";// generator 方法执行的状态var state = GenStateSuspendedStart;return function invoke (method, arg) &#123; // 方法体内的语句执行过程中不允许继续执行 if (state === GenStateExecuting) &#123; throw new Error(\"Generator is already running\"); &#125; if (state === GenStateCompleted) &#123; if (method === \"throw\") &#123; throw arg; &#125; &#125; context.method = method; context.arg = arg; while (true) &#123; // 省略容错逻辑 state = GenStateExecuting; // fn.call(obj, arg) // fn 即 genFn$，arg 即为 context //function tryCatch (fn, obj, arg) &#123; // try &#123; // return &#123; type: \"normal\", arg: fn.call(obj, arg) &#125;; // &#125; catch (err) &#123; // return &#123; type: \"throw\", arg: err &#125;; // &#125; //&#125; // 在这里调用 genFn$ 方法 var record = tryCatch(innerFn, self, context); if (record.type === \"normal\") &#123; // 执行 genFn$ 成功会走如下逻辑 // 如果语句执行完毕则结束执行，否则暂停执行 state = context.done ? GenStateCompleted : GenStateSuspendedYield; // 返回执行 yield 的结果 return &#123; value: record.arg, done: context.done &#125;; &#125; else if (record.type === \"throw\") &#123; // 遇到错误则将方法改为 throw，进入下一个循环执行容错逻辑 state = GenStateCompleted; context.method = \"throw\"; context.arg = record.arg; &#125; &#125;&#125;; invoke 通过调用的方法进行不同的操作。遇到 throw 直接 throw 错误；遇到 return 会去 complete generator；遇到 next，就会调用 genFn$ 方法，最终返回一个 value 和 done 属性的对象。 解析 async对于 async 函数，依然使用上面的方法进行编译处理。async 编译后的代码与 generator 编译后的 regeneratorRuntime 对象是一样的，因此我们只需要关注不同点就可以了。 编译前 12345678910111213141516const p = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(2) &#125;, 1000)&#125;)async function asyncFn() &#123; let a = await p(); let b = await 1; let c = await 1; console.log(a) console.log(b) console.log(c)&#125;asyncFn();// 2 1 1 编译后 1234567891011121314151617181920212223242526272829303132333435363738var p = function () &#123; return new Promise(function (resolve, reject) &#123; setTimeout(function () &#123; resolve(2); &#125;, 1000); &#125;);&#125;;function asyncFn () &#123; var a, b, c; return regeneratorRuntime.async(function asyncFn$ (_context) &#123; while (1) &#123; switch (_context.prev = _context.next) &#123; case 0: _context.next = 2; return regeneratorRuntime.awrap(p()); case 2: a = _context.sent; _context.next = 5; return regeneratorRuntime.awrap(1); case 5: b = _context.sent; _context.next = 8; return regeneratorRuntime.awrap(1); case 8: c = _context.sent; console.log(a); console.log(b); console.log(c); case 12: case \"end\": return _context.stop(); &#125; &#125; &#125;, null, null, null, Promise);&#125;asyncFn(); 与 generator 编译之后的代码基本相同，不同的是 调用的是 regeneratorRuntime.async 方法，接收4个参，其中最后一个是 Promise 内部方法 return regeneratorRuntime.awrap, 即将 await xx 改为 regeneratorRuntime.awrap(xx) 按照顺序，先来看看 async 方法。 12345678910111213141516exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) &#123; // 确保 PromiseImpl 是 Promise if (PromiseImpl === void 0) PromiseImpl = Promise; var iter = new AsyncIterator( // wrap 方法返回一个 generator 对象 wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl ); // iter.next() 是一个 promise 对象 return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) &#123; return result.done ? result.value : iter.next(); &#125;);&#125;; new AsyncIterator 内部做了些什么工作呢？简化之后就很明了。 123456789101112131415function AsyncIterator (generator, PromiseImpl) &#123; function invoke (method, arg, resolve, reject) &#123;&#125; function enqueue (method, arg) &#123; function callInvokeWithMethodAndArg () &#123; // 返回 promise 实例 return new PromiseImpl(function (resolve, reject) &#123; invoke(method, arg, resolve, reject); &#125;); &#125; var previousPromise; return previousPromise = callInvokeWithMethodAndArg(); &#125; this._invoke = enqueue;&#125; defineIteratorMethods 方法将 next(还有 throw、return) 方法代理给了 _invoke，所以 iter.next() 会调用_invoke，即 enqueue，而 enqueue 返回一个 promise 实例，因此可以调用 then 方法。 123iter.next().then(function (result) &#123; return result.done ? result.value : iter.next();&#125;) 这段是控制 await 顺序执行的开始和结束 首先执行 iter.next()，相当于执行 enqueue，进而执行 invoke。 12345678910111213141516171819202122232425function invoke (method, arg, resolve, reject) &#123; var record = tryCatch(generator[method], generator, arg); if (record.type === \"throw\") &#123; reject(record.arg); &#125; else &#123; var result = record.arg; var value = result.value; if (value &amp;&amp; typeof value === \"object\" &amp;&amp; hasOwn.call(value, \"__await\")) &#123; return PromiseImpl.resolve(value.__await).then(function (value) &#123; invoke(\"next\", value, resolve, reject); &#125;, function (err) &#123; invoke(\"throw\", err, resolve, reject); &#125;); &#125; return PromiseImpl.resolve(value).then(function (unwrapped) &#123; result.value = unwrapped; resolve(result); &#125;, function (error) &#123; return invoke(\"throw\", error, resolve, reject); &#125;); &#125;&#125; 执行步骤如下： var record = tryCatch(generator[method], generator, arg); 因为 generator[method] 代理给了 _invoke。因此会执行 return { type: “normal”, arg: fn.call(obj, arg) };所以这里的_invoke 是 generator 的 _invoke，而不是 iter 的_invoke。 接下来执行 _invoke 的步骤与 generator 函数一样，执行被包裹的函数，最终会返回 {value: xx, done: xx} 对象，但不一样的是，如果函数体没有执行完毕之前，value 是一个对象，有一个 __await 属性。 如果 tryCatch 执行失败，则直接 reject。 如果执行成功： 如果函数体内的 await 还未执行结束，则会将 record.value.__await 值当作参数，递归调用 invoke 方法 如果函数体执行完毕，此时的 value 是 undefined，将 record 用异步的方式返回，就会执行 iter.next() 的 then 方法内的回调，这里就是直接执行 return result.value。 因此 async 默认返回 undefined。 到这里，我们就简单理解了 generator 和 async 函数内部的工作原理。其中，async 是在 generator 的基础上工作的，它使用递归方式取代多个 next 方法调用。 奉上一张编译后代码中方法调用的简图以作参考。 实现一个简版 async通过上面的分析，我们可以知道，async 就是一个不需要手动执行 next 方法的 generator，明白了这点就好动手了。 先上一个示例 1234567891011121314151617181920212223242526272829303132function fakeReadFile (filename, duration) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(filename) resolve(filename) &#125;, duration) &#125;)&#125;function* genFn () &#123; yield fakeReadFile('a.txt', 5000); yield fakeReadFile('b.txt', 3000); yield 3; yield 4; yield 5;&#125;let g = genFn();console.log(g.next())console.log(g.next())console.log(g.next())console.log(g.next())console.log(g.next())console.log(g.next())// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;// &#123; value: Promise &#123; &lt;pending&gt; &#125;, done: false &#125;// &#123; value: 3, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: 5, done: false &#125;// &#123; value: undefined, done: true &#125;// b.txt 3秒后输出// a.txt 5秒后输出 如上例所示，在实现 async 有2个问题需要解决： 如何保证异步代码按调用顺序去执行（异步代码默认使用 promise 包裹） 如何自动调用 next 先来实现自动调用，首先想到的是声明一个方法，在里面去执行 next 方法，然后递归调用。 1234567891011121314151617181920212223242526272829303132function asyncFn (genFn) &#123; function invokeNext (generator) &#123; // 在这里执行 next 方法 let result = generator.next(); // 如果调用结束就不再继续调用 if (result.done === true) &#123; return; &#125; invokeNext(generator) &#125; // 获取遍历器对象 let g = genFn.call(null); invokeNext(g)&#125;// 测试一下function* genFn_ () &#123; yield 1; yield 2; yield 3; yield 4; yield 5;&#125;// 无异步代码可以按顺序执行// &#123; value: 1, done: false &#125;// &#123; value: 2, done: false &#125;// &#123; value: 3, done: false &#125;// &#123; value: 4, done: false &#125;// &#123; value: 5, done: false &#125;// &#123; value: undefined, done: true &#125;// 对于前面异步代码的执行就会出先问题 js 处理异步操作有多种方式，除了 generator 和 async，我们还有 promise，所以考虑用 promise 来管理每个 next 的调用顺序，事情就变得简单了，完整代码如下： 1234567891011121314151617181920212223242526function asyncFn (genFn) &#123; function invokeNext (generator) &#123; return new Promise((resolve, reject) =&gt; &#123; let value = generator.next(); resolve(value) &#125;).then((result) =&gt; &#123; console.log(result); if (result.done === true) &#123; return; &#125; // 如果是 promise 对象，则需要在 then 方法回调里去调用下一个 next if (result.value instanceof Promise) &#123; result.value.then(() =&gt; &#123; invokeNext(generator) &#125;) &#125; else &#123; invokeNext(generator) &#125; &#125;, err =&gt; &#123; reject(err); &#125;) &#125; const g = genFn.call(null); invokeNext(g)&#125;","categories":[],"tags":[]},{"title":"JavaScript 异步编程/弄懂 event loop","slug":"JavaScript 异步编程/弄懂 event loop","date":"2021-04-30T02:21:53.137Z","updated":"2021-07-01T01:15:16.972Z","comments":true,"path":"2021/04/30/JavaScript 异步编程/弄懂 event loop/","link":"","permalink":"http://yoursite.com/2021/04/30/JavaScript%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/%E5%BC%84%E6%87%82%20event%20loop/","excerpt":"","text":"什么是 event loop简单来说，event loop 就是 JavaScript 宿主处理事件执行的一种机制。 js 以前是专门用来处理浏览器交互的，比如说 DOM 点击事件等，因此被设计成单线程，所谓单线程，就是同一时间只能处理一件事情，这也就保证了页面中一次只能处理一个事件，避免造成交互混乱的问题。 开始之前，需要明确的是 JavaScript引擎是单线程的，但是 js 运行环境是多线程。因为浏览器是多线程的，除了 js 引擎线程，还包括 GUI 渲染线程、定时器触发线程、HTTP 请求线程以及 DOM 事件触发线程；node也可以使用 child_process 创建多个子线程。 现在有事件 A 和 B，如下： 123456789101112const A = function A() &#123; setTimeout(() =&gt; &#123; console.log('i am A'); &#125;, 2000)&#125;const B = function B() &#123; console.log('i am B');&#125;A();B(); 按照单线程的要求，需要等到 A 执行完毕，才会执行 B，那么打印顺序会是如下所示： 12console.log('i am A');console.log('i am B'); 但实际上的顺序是： 12console.log('i am B');console.log('i am A'); 这就是 event loop 机制在起作用，因为 console.log(‘i am B’) 是同步任务，而 setTimeout 是异步任务，同步任务执行完才会去执行异步任务 宏任务和微任务 什么是宏任务和微任务？ 这里有几个概念容易混淆，那就是同步任务和异步任务，宏任务和微任务。js 的代码执行遵循在代码块内从上往下执行的规则，同步任务会依次执行；而异步任务则会分为宏任务和微任务，比如 setTimeout 的第一个参数是宏任务，promise.then 中注册的方法是微任务，会按照宏任务和微任务的执行规则进行执行。 宏任务和微任务有哪些？ js 执行的宿主环境有浏览器和 Node, 所以我们通过宿主环境的不同来整理这些异步任务： 宏任务 浏览器 node setTimeout √ √ setInterval √ √ setImmediate x √ I/O √ √ requestAnimationFrame √ x 微任务 浏览器 node mutationObserver √ x promise √ √ process.nextTick x √ 宏任务和微任务的执行顺序 要点一：一个宏任务里可能会包含多个微任务 123456789101112new Promise((resolve, reject) =&gt; &#123; console.log('我是 promise 里的 同步任务') resolve('success')&#125;).then(res =&gt; &#123; console.log('我是微任务1')&#125;).then(res =&gt; &#123; console.log('我是微任务2')&#125;)setTimeout(() =&gt; &#123; console.log('我是 setTimeout 里的 宏任务')&#125;) 我们来分析下这段代码里的宏任务和微任务有哪些：宏任务：setTimeout 的回调微任务：两个 then 方法的回调 要点二：宏任务是一个一个执行的，而微任务是批量执行的，当前批次微任务没有完成之前，下一个宏任务不会执行 因此执行顺序是: 遇到 promise，参数里面的代码是同步的，所有会先执行 console.log(‘我是 promise 里的 同步任务’) 执行两个 then 方法的回调 执行 setTimeout 的回调 即： 1234// console.log('我是 promise 里的 同步任务')// console.log('我是微任务1')// console.log('我是微任务2')// console.log('我是 setTimeout 里的 宏任务') 浏览器下的 event loop 如图所示，代码执行步骤如下： js 在执行代码时，会将代码放入执行栈中，遇到同步任务，会依次执行；遇到如 DOM 点击事件、ajax 以及 定时器等异步任务，浏览器会交给其他辅线程调用 WebApis 进行处理。 如果 WebApis 处理的异步任务有了结果，就会将该任务推入到回调队列（callback queue）中，回调队列分为宏任务队列和微任务队列。 一旦执行栈内（stack）的任务执行完成，就会将回调队列里的任务放入执行栈中执行，顺序如下： 如果微任务队列中存在任务，则一次性执行所有微任务 将宏任务队列的第一个任务放入执行栈中执行 以上步骤的循环就是浏览器中的 event loop。 看一个简单例子感受下： 1234567891011setTimeout(function callback1()&#123;console.log(3)&#125;)Promise.resolve('success').then(function callback2()&#123;console.log(1);return 1&#125;).then(function callback3()&#123;console.log(2);return 2&#125;)console.log('start')// start// 1// 2// 3 遇到 setTimeout，等待时间到达后将 callback1 放入宏任务队列 遇到 promise.then，等待时间到达后将 callback2 与 callback3 按顺序放入微任务队列 执行同步任务 console.log。 执行完同步任务，将微任务队列里的任务一次性执行 微任务执行完之后，执行宏任务队列的第一个任务 node 下的 event loop123456789101112131415161718 ┌───────────────────────────┐ ┌─&gt;│ timers ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐ │ │ pending callbacks │ │ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐│ │ idle, prepare ││ └─────────────┬─────────────┘ ┌───────────────┐│ ┌─────────────┴─────────────┐ │ incoming: ││ │ poll │&lt;─────┤ connections, ││ └─────────────┬─────────────┘ │ data, etc. ││ ┌─────────────┴─────────────┐ └───────────────┘│ │ check ││ └─────────────┬─────────────┘│ ┌─────────────┴─────────────┐└──┤ close callbacks │ └───────────────────────────┘ 如上图所示，node 中的 event loop 分为6个循环阶段，当 node.js 启动的时候，会初始化 event loop timers： 这个阶段执行 setTimeout 和 setInterval 的回调函数 pending callbacks：在下一个循环中执行 I/O 回调函数 idle, prepare：只在 node 内部触发 poll：获取新的 I/O 事件，在适当的时候阻塞在这里 check：执行 setImmediate 的回调函数 close callbacks：执行关闭事件的回调函数，如 socket.on(‘close’, … ) 下面主要对 timers、poll、check 三个阶段进行解析： 一、timerstimers 阶段的回调函数可能并不会按照设定的时间延迟去执行，因为 event loop 初始化或者其他阶段回调函数的长时间执行会延迟它们的执行。 1234567891011121314151617181920const fs = require('fs');function someAsyncOperation(callback) &#123; // 假设读取文件需耗时 95ms fs.readFile('./a.txt', callback)&#125;cosnt timeoutScheduled = Date.now();setTimeout(() =&gt; &#123; const delay = Date.now() - timeoutScheduled; console.log(`$&#123;delay&#125;ms have passed since I was scheduled`);&#125;, 100)someAsyncOperation(() =&gt; &#123; const startCallbackTime = Date.now(); while (Date.now() - startCallbackTime &lt; 10) &#123; // do something &#125;&#125;) 上方示例在 node 里的大致执行步骤如下： timer 阶段：因为需要延迟 100ms，所以当前没有 callback 需要执行，进入 pending callback 阶段 pending callback阶段：没有 I/O 回调需要执行，进入 idle， idle 忽略 poll 阶段：因为此时有 I/O 操作，因此会阻塞在这里，等待95ms至文件读取结束，然后将 callback 放入队列进行执行，耗时10ms。调用结束后，当前队列为空，检查 timers，发现设定时间为95ms，当前运行时间超时了，因此进入 timer 阶段执行回调，所以会打印出”105ms has passed since I was scheduled” 二、pollpoll 阶段主要有两个功能： 1.计算它应该阻塞和轮询 I/O 多长时间 2.处理该阶段事件 当 event loop 进入 poll 阶段并且未设定定时器，会出现下面中的某个情况： 如果 poll 的队列不为空，那么就会遍历队列，并异步执行完所有回调函数，或者执行耗时达到系统设定的最大时间 如果 poll 队列为空，那以下情况中的一个会出现： 如果代码设定了 setImmediate 方法，event loop 会结束 poll 阶段，进入 check 阶段去执行 check 队列 如果没有设定 setImmediate 方法，就会阻塞在 poll 阶段，直到有 poll callback 添加到队列中，然后立刻执行。 如果 event loop 进入 poll 阶段并且设定了定时器： 一旦 poll 队列处于空闲状态，event loop 会查看 timers 里的回调函数，如果至少有一个回调函数的时间到了，event loop 会按循环顺序进入 timers 阶段去执行这些回调函数。 按循环顺序说的是 event loop 不会直接进入 timers 阶段，而是要先进入 check、close callback 之后，再进入 timers 阶段。 三、check 这个阶段用来存放 setImmediate 回调函数，如果代码中设定了，那么 event loop 不会阻塞等待在 poll 阶段，而是会进入 check 阶段。 当 poll 阶段结束，进入check 阶段后，会调用 libuv api 去执行回调函数 四、API 比较 setTimeout 和 setImmediate setTimeout 设定一个任务在等待指定时间后去执行 setImmediate 在 poll 阶段完成后立即去调用它设定的代码 它们回调函数执行的顺序依据它们执行的方式会有不同：如果它们的执行不在 I/O 操作里，那么顺序时不定的，如果在 I/O 中，永远都是 setImmediate 最先执行 process.nextTick 在技术上来说，nextTick 不属于 event loop 的一部分，凡是放进 nextTick 队列的回调函数会在下一次 event loop 循环开始前执行。需要注意的是，正是因为这个特性，如果递归调用 nextTick，会导致下一次 event loop 无法开始。 node 中宏任务和微任务因为 node 中的 宏任务分处于不同的阶段，并且微任务中的 process.nextTick 都是先于其它微任务执行，所以可以理解为 有4个宏任务队列以及2个微任务队列。 这里为了便于理解，借用一张图： 这里的宏任务和微任务流程模型与浏览器的相同，区别在于： node 中的宏任务队列执行顺序取决于 event loop 所处的阶段 微任务中，process.nextTick 独处一个队列，比其他微任务要早执行 总结event loop 相当于一个总指挥，负责 js 任务的协调与调度。 参考文献 https://juejin.cn/post/6844903670291628046#heading-5","categories":[],"tags":[]}],"categories":[],"tags":[]}